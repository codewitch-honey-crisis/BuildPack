'------------------------------------------------------------------------------
' <auto-generated>
'     This code was generated by a tool.
'     Runtime Version:4.0.30319.42000
'
'     Changes to this file may cause incorrect behavior and will be lost if
'     the code is regenerated.
' </auto-generated>
'------------------------------------------------------------------------------

Option Strict Off
Option Explicit On

Imports System
Imports System.Collections.Generic

Namespace ParsleyDemo
    '''<summary>Parses the indicated grammar. Refer to C:\dev\BuildPack\ParsleyDemoVB\Expression.xbnf</summary>
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")>  _
    Partial Friend Class ExpressionParser
        Friend Const ErrorSymbol As Integer = -1
        Friend Const EosSymbol As Integer = -2
        Public Const Unary As Integer = 0
        Public Const Leaf As Integer = 1
        Public Const TermList As Integer = 2
        Public Const FactorList As Integer = 3
        Public Const TermListRightAssoc As Integer = 4
        Public Const FactorListRightAssoc As Integer = 5
        Public Const Term As Integer = 6
        Public Const TermPart As Integer = 7
        Public Const Factor As Integer = 8
        Public Const FactorPart As Integer = 9
        Public Const TermListRightAssoc2 As Integer = 10
        Public Const FactorListRightAssoc2 As Integer = 11
        Public Const add As Integer = 12
        Public Const mul As Integer = 13
        Public Const [integer] As Integer = 14
        Public Const identifier As Integer = 15
        Public Const whitespace As Integer = 16
        Public Const Implicit As Integer = 17
        Public Const Implicit2 As Integer = 18
        Public Const Implicit3 As Integer = 19
        Public Const Implicit4 As Integer = 20
        Friend Shared Function ParseUnary(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'Unary -> add Unary
            If (ExpressionParser.add = context.SymbolId) Then
                Dim children(1) As ParseNode
                If (false  _
                            = (ExpressionParser.add = context.SymbolId)) Then
                    context.Error("Expecting add")
                End If
                children(0) = New ParseNode(ExpressionParser.add, "add", context.Value, context.Line, context.Column, context.Position)
                context.Advance
                children(1) = ExpressionParser.ParseUnary(context)
                Return New ParseNode(ExpressionParser.Unary, "Unary", children, line__, column__, position__)
            End If
            'Unary -> Implicit Unary
            If (ExpressionParser.Implicit = context.SymbolId) Then
                Dim children(1) As ParseNode
                If (false  _
                            = (ExpressionParser.Implicit = context.SymbolId)) Then
                    context.Error("Expecting Implicit")
                End If
                children(0) = New ParseNode(ExpressionParser.Implicit, "Implicit", context.Value, context.Line, context.Column, context.Position)
                context.Advance
                children(1) = ExpressionParser.ParseUnary(context)
                Return New ParseNode(ExpressionParser.Unary, "Unary", children, line__, column__, position__)
            End If
            'Unary -> Leaf
            If (((ExpressionParser.[integer] = context.SymbolId)  _
                        OrElse (ExpressionParser.identifier = context.SymbolId))  _
                        OrElse (ExpressionParser.Implicit3 = context.SymbolId)) Then
                Dim children(0) As ParseNode
                children(0) = ExpressionParser.ParseLeaf(context)
                Return New ParseNode(ExpressionParser.Unary, "Unary", children, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting add, Implicit, or Leaf", line__, column__, position__)
        End Function
        Friend Shared Function ParseLeaf(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'Leaf -> integer
            If (ExpressionParser.[integer] = context.SymbolId) Then
                Dim children(0) As ParseNode
                If (false  _
                            = (ExpressionParser.[integer] = context.SymbolId)) Then
                    context.Error("Expecting integer")
                End If
                children(0) = New ParseNode(ExpressionParser.[integer], "integer", context.Value, context.Line, context.Column, context.Position)
                context.Advance
                Return New ParseNode(ExpressionParser.Leaf, "Leaf", children, line__, column__, position__)
            End If
            'Leaf -> identifier
            If (ExpressionParser.identifier = context.SymbolId) Then
                Dim children(0) As ParseNode
                If (false  _
                            = (ExpressionParser.identifier = context.SymbolId)) Then
                    context.Error("Expecting identifier")
                End If
                children(0) = New ParseNode(ExpressionParser.identifier, "identifier", context.Value, context.Line, context.Column, context.Position)
                context.Advance
                Return New ParseNode(ExpressionParser.Leaf, "Leaf", children, line__, column__, position__)
            End If
            'Leaf -> Implicit3 Term Implicit4
            If (ExpressionParser.Implicit3 = context.SymbolId) Then
                Dim children(2) As ParseNode
                If (false  _
                            = (ExpressionParser.Implicit3 = context.SymbolId)) Then
                    context.Error("Expecting Implicit3")
                End If
                children(0) = New ParseNode(ExpressionParser.Implicit3, "Implicit3", context.Value, context.Line, context.Column, context.Position)
                context.Advance
                children(1) = ExpressionParser.ParseTerm(context)
                If (false  _
                            = (ExpressionParser.Implicit4 = context.SymbolId)) Then
                    context.Error("Expecting Implicit4")
                End If
                children(2) = New ParseNode(ExpressionParser.Implicit4, "Implicit4", context.Value, context.Line, context.Column, context.Position)
                context.Advance
                Return New ParseNode(ExpressionParser.Leaf, "Leaf", children, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting integer, identifier, or Implicit3", line__, column__, position__)
        End Function
        Friend Shared Function ParseTermList(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'TermList -> add Factor TermListRightAssoc TermListRightAssoc2
            If (ExpressionParser.add = context.SymbolId) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                If (false  _
                            = (ExpressionParser.add = context.SymbolId)) Then
                    context.Error("Expecting add")
                End If
                children.Add(New ParseNode(ExpressionParser.add, "add", context.Value, context.Line, context.Column, context.Position))
                context.Advance
                children.Add(ExpressionParser.ParseFactor(context))
                children.AddRange(ExpressionParser.ParseTermListRightAssoc(context).Children)
                children.AddRange(ExpressionParser.ParseTermListRightAssoc2(context).Children)
                Return New ParseNode(ExpressionParser.TermList, "TermList", children.ToArray, line__, column__, position__)
            End If
            'TermList -> Implicit Factor TermListRightAssoc TermListRightAssoc2
            If (ExpressionParser.Implicit = context.SymbolId) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                If (false  _
                            = (ExpressionParser.Implicit = context.SymbolId)) Then
                    context.Error("Expecting Implicit")
                End If
                children.Add(New ParseNode(ExpressionParser.Implicit, "Implicit", context.Value, context.Line, context.Column, context.Position))
                context.Advance
                children.Add(ExpressionParser.ParseFactor(context))
                children.AddRange(ExpressionParser.ParseTermListRightAssoc(context).Children)
                children.AddRange(ExpressionParser.ParseTermListRightAssoc2(context).Children)
                Return New ParseNode(ExpressionParser.TermList, "TermList", children.ToArray, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting add or Implicit", line__, column__, position__)
        End Function
        Friend Shared Function ParseFactorList(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'FactorList -> mul Unary FactorListRightAssoc FactorListRightAssoc2
            If (ExpressionParser.mul = context.SymbolId) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                If (false  _
                            = (ExpressionParser.mul = context.SymbolId)) Then
                    context.Error("Expecting mul")
                End If
                children.Add(New ParseNode(ExpressionParser.mul, "mul", context.Value, context.Line, context.Column, context.Position))
                context.Advance
                children.Add(ExpressionParser.ParseUnary(context))
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc(context).Children)
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc2(context).Children)
                Return New ParseNode(ExpressionParser.FactorList, "FactorList", children.ToArray, line__, column__, position__)
            End If
            'FactorList -> Implicit2 Unary FactorListRightAssoc FactorListRightAssoc2
            If (ExpressionParser.Implicit2 = context.SymbolId) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                If (false  _
                            = (ExpressionParser.Implicit2 = context.SymbolId)) Then
                    context.Error("Expecting Implicit2")
                End If
                children.Add(New ParseNode(ExpressionParser.Implicit2, "Implicit2", context.Value, context.Line, context.Column, context.Position))
                context.Advance
                children.Add(ExpressionParser.ParseUnary(context))
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc(context).Children)
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc2(context).Children)
                Return New ParseNode(ExpressionParser.FactorList, "FactorList", children.ToArray, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting mul or Implicit2", line__, column__, position__)
        End Function
        Friend Shared Function ParseTermListRightAssoc(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'TermListRightAssoc -> add Factor TermListRightAssoc
            If (ExpressionParser.add = context.SymbolId) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                If (false  _
                            = (ExpressionParser.add = context.SymbolId)) Then
                    context.Error("Expecting add")
                End If
                children.Add(New ParseNode(ExpressionParser.add, "add", context.Value, context.Line, context.Column, context.Position))
                context.Advance
                children.Add(ExpressionParser.ParseFactor(context))
                children.AddRange(ExpressionParser.ParseTermListRightAssoc(context).Children)
                Return New ParseNode(ExpressionParser.TermListRightAssoc, "TermListRightAssoc", children.ToArray, line__, column__, position__)
            End If
            'TermListRightAssoc ->
            If (((ExpressionParser.Implicit = context.SymbolId)  _
                        OrElse (ExpressionParser.EosSymbol = context.SymbolId))  _
                        OrElse (ExpressionParser.Implicit4 = context.SymbolId)) Then
                Dim children(-1) As ParseNode
                Return New ParseNode(ExpressionParser.TermListRightAssoc, "TermListRightAssoc", children, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting add", line__, column__, position__)
        End Function
        Friend Shared Function ParseFactorListRightAssoc(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'FactorListRightAssoc -> mul Unary FactorListRightAssoc
            If (ExpressionParser.mul = context.SymbolId) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                If (false  _
                            = (ExpressionParser.mul = context.SymbolId)) Then
                    context.Error("Expecting mul")
                End If
                children.Add(New ParseNode(ExpressionParser.mul, "mul", context.Value, context.Line, context.Column, context.Position))
                context.Advance
                children.Add(ExpressionParser.ParseUnary(context))
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc(context).Children)
                Return New ParseNode(ExpressionParser.FactorListRightAssoc, "FactorListRightAssoc", children.ToArray, line__, column__, position__)
            End If
            'FactorListRightAssoc ->
            If (((((ExpressionParser.Implicit2 = context.SymbolId)  _
                        OrElse (ExpressionParser.add = context.SymbolId))  _
                        OrElse (ExpressionParser.Implicit = context.SymbolId))  _
                        OrElse (ExpressionParser.EosSymbol = context.SymbolId))  _
                        OrElse (ExpressionParser.Implicit4 = context.SymbolId)) Then
                Dim children(-1) As ParseNode
                Return New ParseNode(ExpressionParser.FactorListRightAssoc, "FactorListRightAssoc", children, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting mul", line__, column__, position__)
        End Function
        Friend Shared Function ParseTerm(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'Term -> Factor TermPart
            If (((((ExpressionParser.add = context.SymbolId)  _
                        OrElse (ExpressionParser.Implicit = context.SymbolId))  _
                        OrElse (ExpressionParser.[integer] = context.SymbolId))  _
                        OrElse (ExpressionParser.identifier = context.SymbolId))  _
                        OrElse (ExpressionParser.Implicit3 = context.SymbolId)) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                children.Add(ExpressionParser.ParseFactor(context))
                children.AddRange(ExpressionParser.ParseTermPart(context).Children)
                Return New ParseNode(ExpressionParser.Term, "Term", children.ToArray, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting Factor", line__, column__, position__)
        End Function
        '''<summary>
        '''Parses a production of the form:
        '''Term= Factor { ( "+" | "-" ) Factor }
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Term -> Factor TermPart
        '''</remarks>
        '''<param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        Public Shared Function Parse(ByVal tokenizer As System.Collections.Generic.IEnumerable(Of Token)) As ParseNode
            Dim context As ParserContext = New ParserContext(tokenizer)
            context.EnsureStarted
            Dim result As ParseNode = ExpressionParser.ParseTerm(context)
            If (false = context.IsEnded) Then
                context.Error("Unexpected remainder in input.")
            End If
            Return result
        End Function
        Friend Shared Function ParseTermPart(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'TermPart -> TermList
            If ((ExpressionParser.add = context.SymbolId)  _
                        OrElse (ExpressionParser.Implicit = context.SymbolId)) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                children.AddRange(ExpressionParser.ParseTermList(context).Children)
                Return New ParseNode(ExpressionParser.TermPart, "TermPart", children.ToArray, line__, column__, position__)
            End If
            'TermPart ->
            If ((ExpressionParser.EosSymbol = context.SymbolId)  _
                        OrElse (ExpressionParser.Implicit4 = context.SymbolId)) Then
                Dim children(-1) As ParseNode
                Return New ParseNode(ExpressionParser.TermPart, "TermPart", children, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting TermList", line__, column__, position__)
        End Function
        Friend Shared Function ParseFactor(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'Factor -> Unary FactorPart
            If (((((ExpressionParser.add = context.SymbolId)  _
                        OrElse (ExpressionParser.Implicit = context.SymbolId))  _
                        OrElse (ExpressionParser.[integer] = context.SymbolId))  _
                        OrElse (ExpressionParser.identifier = context.SymbolId))  _
                        OrElse (ExpressionParser.Implicit3 = context.SymbolId)) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                children.Add(ExpressionParser.ParseUnary(context))
                children.AddRange(ExpressionParser.ParseFactorPart(context).Children)
                Return New ParseNode(ExpressionParser.Factor, "Factor", children.ToArray, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting Unary", line__, column__, position__)
        End Function
        Friend Shared Function ParseFactorPart(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'FactorPart -> FactorList
            If ((ExpressionParser.mul = context.SymbolId)  _
                        OrElse (ExpressionParser.Implicit2 = context.SymbolId)) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                children.AddRange(ExpressionParser.ParseFactorList(context).Children)
                Return New ParseNode(ExpressionParser.FactorPart, "FactorPart", children.ToArray, line__, column__, position__)
            End If
            'FactorPart ->
            If ((((ExpressionParser.add = context.SymbolId)  _
                        OrElse (ExpressionParser.Implicit = context.SymbolId))  _
                        OrElse (ExpressionParser.EosSymbol = context.SymbolId))  _
                        OrElse (ExpressionParser.Implicit4 = context.SymbolId)) Then
                Dim children(-1) As ParseNode
                Return New ParseNode(ExpressionParser.FactorPart, "FactorPart", children, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting FactorList", line__, column__, position__)
        End Function
        Friend Shared Function ParseTermListRightAssoc2(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'TermListRightAssoc2 -> Implicit Factor TermListRightAssoc2
            If (ExpressionParser.Implicit = context.SymbolId) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                If (false  _
                            = (ExpressionParser.Implicit = context.SymbolId)) Then
                    context.Error("Expecting Implicit")
                End If
                children.Add(New ParseNode(ExpressionParser.Implicit, "Implicit", context.Value, context.Line, context.Column, context.Position))
                context.Advance
                children.Add(ExpressionParser.ParseFactor(context))
                children.AddRange(ExpressionParser.ParseTermListRightAssoc2(context).Children)
                Return New ParseNode(ExpressionParser.TermListRightAssoc2, "TermListRightAssoc2", children.ToArray, line__, column__, position__)
            End If
            'TermListRightAssoc2 ->
            If ((ExpressionParser.EosSymbol = context.SymbolId)  _
                        OrElse (ExpressionParser.Implicit4 = context.SymbolId)) Then
                Dim children(-1) As ParseNode
                Return New ParseNode(ExpressionParser.TermListRightAssoc2, "TermListRightAssoc2", children, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting Implicit", line__, column__, position__)
        End Function
        Friend Shared Function ParseFactorListRightAssoc2(ByVal context As ParserContext) As ParseNode
            Dim line__ As Integer = context.Line
            Dim column__ As Integer = context.Column
            Dim position__ As Long = context.Position
            'FactorListRightAssoc2 -> Implicit2 Unary FactorListRightAssoc2
            If (ExpressionParser.Implicit2 = context.SymbolId) Then
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                If (false  _
                            = (ExpressionParser.Implicit2 = context.SymbolId)) Then
                    context.Error("Expecting Implicit2")
                End If
                children.Add(New ParseNode(ExpressionParser.Implicit2, "Implicit2", context.Value, context.Line, context.Column, context.Position))
                context.Advance
                children.Add(ExpressionParser.ParseUnary(context))
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc2(context).Children)
                Return New ParseNode(ExpressionParser.FactorListRightAssoc2, "FactorListRightAssoc2", children.ToArray, line__, column__, position__)
            End If
            'FactorListRightAssoc2 ->
            If ((((ExpressionParser.add = context.SymbolId)  _
                        OrElse (ExpressionParser.Implicit = context.SymbolId))  _
                        OrElse (ExpressionParser.EosSymbol = context.SymbolId))  _
                        OrElse (ExpressionParser.Implicit4 = context.SymbolId)) Then
                Dim children(-1) As ParseNode
                Return New ParseNode(ExpressionParser.FactorListRightAssoc2, "FactorListRightAssoc2", children, line__, column__, position__)
            End If
            Throw New SyntaxException("Expecting Implicit2", line__, column__, position__)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Term= Factor { ( "+" | "-" ) Factor }
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Term -> Factor TermPart
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function Evaluate(ByVal node As ParseNode) As Integer
            Return ExpressionParser.EvaluateTerm(node)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Term= Factor { ( "+" | "-" ) Factor }
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Term -> Factor TermPart
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function Evaluate(ByVal node As ParseNode, ByVal state As Object) As Integer
            Return ExpressionParser.EvaluateTerm(node, state)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Term= Factor { ( "+" | "-" ) Factor }
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Term -> Factor TermPart
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function EvaluateTerm(ByVal node As ParseNode, ByVal state As Object) As Integer
            If (ExpressionParser.Term = node.SymbolId) Then
                Dim result As Integer = ExpressionParser.EvaluateFactor(node.Children(0), state)
                Dim i As Integer = 2

                Do While (i < node.Children.Length)
                    If (node.Children((i - 1)).SymbolId = ParsleyDemo.ExpressionParser.add) Then
                        result = (result + ExpressionParser.EvaluateFactor(node.Children(i), state))
                    Else
                        result = (result - ExpressionParser.EvaluateFactor(node.Children(i), state))
                    End If
                    i = (i + 2)

                Loop
                Return CType(ExpressionParser._ChangeType(result, GetType(Integer)),Integer)
            End If
            Throw New SyntaxException("Expecting Term", node.Line, node.Column, node.Position)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Term= Factor { ( "+" | "-" ) Factor }
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Term -> Factor TermPart
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function EvaluateTerm(ByVal node As ParseNode) As Integer
            Return ExpressionParser.EvaluateTerm(node, Nothing)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Factor= Unary { ( "*" | "/" ) Unary }
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Factor -> Unary FactorPart
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function EvaluateFactor(ByVal node As ParseNode, ByVal state As Object) As Integer
            If (ExpressionParser.Factor = node.SymbolId) Then
                Dim result As Integer = ExpressionParser.EvaluateUnary(node.Children(0), state)
                Dim i As Integer = 2

                Do While (i < node.Children.Length)
                    'Child always returns an object type so
                    'be sure to cast as necessary
                    If (node.Children((i - 1)).SymbolId = ParsleyDemo.ExpressionParser.mul) Then
                        result = (result * CType(ExpressionParser._EvaluateAny(node.Children(i), state),Integer))
                    Else
                        result = (result / CType(ExpressionParser._EvaluateAny(node.Children(i), state),Integer))
                    End If
                    i = (i + 2)

                Loop
                Return CType(ExpressionParser._ChangeType(result, GetType(Integer)),Integer)
            End If
            Throw New SyntaxException("Expecting Factor", node.Line, node.Column, node.Position)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Factor= Unary { ( "*" | "/" ) Unary }
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Factor -> Unary FactorPart
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function EvaluateFactor(ByVal node As ParseNode) As Integer
            Return ExpressionParser.EvaluateFactor(node, Nothing)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Unary= ( "+" | "-" ) Unary | Leaf
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Unary -> add Unary
        '''Unary -> Implicit Unary
        '''Unary -> Leaf
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function EvaluateUnary(ByVal node As ParseNode, ByVal state As Object) As Integer
            If (ExpressionParser.Unary = node.SymbolId) Then
                If (node.Children.Length = 1) Then
                    Return CType(ExpressionParser._ChangeType(ExpressionParser.EvaluateLeaf(node.Children(0), state), GetType(Integer)),Integer)
                End If
                If (node.Children(0).SymbolId = ParsleyDemo.ExpressionParser.add) Then
                    Return CType(ExpressionParser._ChangeType(ExpressionParser.EvaluateUnary(node.Children(1), state), GetType(Integer)),Integer)
                Else
                    Return CType(ExpressionParser._ChangeType((0 - ExpressionParser.EvaluateUnary(node.Children(1), state)), GetType(Integer)),Integer)
                End If
            End If
            Throw New SyntaxException("Expecting Unary", node.Line, node.Column, node.Position)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Unary= ( "+" | "-" ) Unary | Leaf
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Unary -> add Unary
        '''Unary -> Implicit Unary
        '''Unary -> Leaf
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function EvaluateUnary(ByVal node As ParseNode) As Integer
            Return ExpressionParser.EvaluateUnary(node, Nothing)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Leaf= integer | identifier | "(" Term ")"
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Leaf -> integer
        '''Leaf -> identifier
        '''Leaf -> Implicit3 Term Implicit4
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function EvaluateLeaf(ByVal node As ParseNode, ByVal state As Object) As Integer
            If (ExpressionParser.Leaf = node.SymbolId) Then
                If (node.Children.Length = 1) Then
                    If (node.Children(0).SymbolId = ParsleyDemo.ExpressionParser.[integer]) Then
                        Return CType(ExpressionParser._ChangeType(node.Children(0).Value, GetType(Integer)),Integer)
                    Else
                        If (Not (state) Is Nothing) Then
                            Dim val As Integer
                            Dim d As IDictionary(Of String, Integer) = CType(state,IDictionary(Of String, Integer))
                            If d.TryGetValue(node.Children(0).Value, val) Then
                                Return CType(ExpressionParser._ChangeType(val, GetType(Integer)),Integer)
                            End If
                        End If
                        Throw New SyntaxException(String.Format("Reference to undefined variable {0}", node.Children(0).Value), node.Line, node.Column, node.Position)
                    End If
                Else
                    Return CType(ExpressionParser._ChangeType(ExpressionParser.EvaluateTerm(node.Children(1), state), GetType(Integer)),Integer)
                End If
            End If
            Throw New SyntaxException("Expecting Leaf", node.Line, node.Column, node.Position)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Leaf= integer | identifier | "(" Term ")"
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Leaf -> integer
        '''Leaf -> identifier
        '''Leaf -> Implicit3 Term Implicit4
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function EvaluateLeaf(ByVal node As ParseNode) As Integer
            Return ExpressionParser.EvaluateLeaf(node, Nothing)
        End Function
        Private Shared Function _ChangeType(ByVal obj As Object, ByVal type As System.Type) As Object
            Dim typeConverter As System.ComponentModel.TypeConverter = System.ComponentModel.TypeDescriptor.GetConverter(obj)
            If ((Nothing Is typeConverter)  _
                        OrElse (false = typeConverter.CanConvertTo(type))) Then
                Return System.Convert.ChangeType(obj, type)
            End If
            Return typeConverter.ConvertTo(obj, type)
        End Function
        Private Shared Function _EvaluateAny(ByVal node As ParseNode, ByVal state As Object) As Object
            If (node.SymbolId = ExpressionParser.Term) Then
                Return ExpressionParser.EvaluateTerm(node, state)
            End If
            If (node.SymbolId = ExpressionParser.Factor) Then
                Return ExpressionParser.EvaluateFactor(node, state)
            End If
            If (node.SymbolId = ExpressionParser.Unary) Then
                Return ExpressionParser.EvaluateUnary(node, state)
            End If
            If (node.SymbolId = ExpressionParser.Leaf) Then
                Return ExpressionParser.EvaluateLeaf(node, state)
            End If
            If (node.SymbolId = ExpressionParser.add) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.Implicit2) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.[integer]) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.identifier) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.mul) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.Implicit3) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.whitespace) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.Implicit) Then
                Return node.Value
            End If
            Return Nothing
        End Function
    End Class
    '''<summary>
    '''
    '''</summary>
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")>  _
    Friend Class SyntaxException
        Inherits Exception
        Private _line As Integer
        Private _column As Integer
        Private _position As Long
        '''<summary>
        '''Creates a syntax exception with the specified arguments
        '''</summary>
        '''<param name="message">The error message</param>
        '''<param name="line">The line where the error occurred</param>
        '''<param name="column">The column where the error occured</param>
        '''<param name="position">The position where the error occured</param>
        Public Sub New(ByVal message As String, ByVal line As Integer, ByVal column As Integer, ByVal position As Long)
            MyBase.New(SyntaxException._GetMessage(message, line, column, position))
            Me._line = line
            Me._column = column
            Me._position = position
        End Sub
        '''<summary>
        '''The line where the error occurred
        '''</summary>
        Public ReadOnly Property Line() As Integer
            Get
                Return Me._line
            End Get
        End Property
        '''<summary>
        '''The column where the error occurred
        '''</summary>
        Public ReadOnly Property Column() As Integer
            Get
                Return Me._column
            End Get
        End Property
        '''<summary>
        '''The position where the error occurred
        '''</summary>
        Public ReadOnly Property Position() As Long
            Get
                Return Me._position
            End Get
        End Property
        Shared Function _GetMessage(ByVal message As String, ByVal line As Integer, ByVal column As Integer, ByVal position As Long) As String
            Return String.Format("{0} at line {1}, column {2}, position {3}", message, line, column, position)
        End Function
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")>  _
    Partial Friend Class ParseNode
        Private _symbolId As Integer
        Private _symbol As String
        Private _value As String
        Private _line As Integer
        Private _column As Integer
        Private _position As Long
        Private _children() As ParseNode
        Public Sub New(ByVal symbolId As Integer, ByVal symbol As String, ByVal children() As ParseNode, ByVal line As Integer, ByVal column As Integer, ByVal position As Long)
            MyBase.New
            Me._symbolId = symbolId
            Me._symbol = symbol
            Me._value = Nothing
            Me._children = children
            Me._line = line
            Me._column = column
            Me._position = position
        End Sub
        Public Sub New(ByVal symbolId As Integer, ByVal symbol As String, ByVal value As String, ByVal line As Integer, ByVal column As Integer, ByVal position As Long)
            MyBase.New
            Me._symbolId = symbolId
            Me._symbol = symbol
            Me._value = value
            Me._children = Nothing
            Me._line = line
            Me._column = column
            Me._position = position
        End Sub
        Public ReadOnly Property IsNonTerminal() As Boolean
            Get
                Return (Not (Me._children) Is Nothing)
            End Get
        End Property
        Public ReadOnly Property Children() As ParseNode()
            Get
                Return Me._children
            End Get
        End Property
        Public ReadOnly Property SymbolId() As Integer
            Get
                Return Me._symbolId
            End Get
        End Property
        Public ReadOnly Property Symbol() As String
            Get
                Return Me._symbol
            End Get
        End Property
        Public ReadOnly Property Value() As String
            Get
                Return Me._value
            End Get
        End Property
        Public ReadOnly Property Line() As Integer
            Get
                Return Me._line
            End Get
        End Property
        Public ReadOnly Property Column() As Integer
            Get
                Return Me._column
            End Get
        End Property
        Public ReadOnly Property Position() As Long
            Get
                Return Me._position
            End Get
        End Property
        Public Overrides Function ToString() As String
            If Me.IsNonTerminal Then
                Return String.Concat(Me.Symbol, ": Count = ", Me._children.Length.ToString)
            End If
            Return String.Concat(Me.Symbol, ": ", Me.Value)
        End Function
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")>  _
    Partial Friend Class ParserContext
        Inherits [Object]
        Implements IDisposable
        Private _state As Integer
        Private _e As IEnumerator(Of Token)
        Private _el As LookAheadEnumerator(Of Token)
        Private _t As Token
        Private _advanceCount As Integer
        Private _line As Integer
        Private _column As Integer
        Private _position As Long
        Private _skipped As List(Of Token)
        Public Sub New(ByVal tokenizer As IEnumerable(Of Token))
            Me.New(tokenizer.GetEnumerator, true)
        End Sub
        Private Sub New(ByVal enumerator As IEnumerator(Of Token), ByVal wrap As Boolean)
            MyBase.New
            Me._e = enumerator
            If wrap Then
                Me._el = New LookAheadEnumerator(Of Token)(enumerator)
                Me._e = Me._el
                'we need both pointers to point to the lookahead
            End If
            Me._state = -1
            Me._t.SymbolId = -1
            Me._advanceCount = 0
            Me._skipped = New List(Of Token)()
        End Sub
        Public ReadOnly Property Skipped() As List(Of Token)
            Get
                Return Me._skipped
            End Get
        End Property
        Public Sub SetLocation(ByVal line As Integer, ByVal column As Integer, ByVal position As Long)
            Me._line = line
            Me._column = column
            Me._position = position
        End Sub
        Public Sub EnsureStarted()
            If (-1 = Me._state) Then
                Me.Advance
            End If
        End Sub
        Public Overloads Function GetLookAhead() As ParserContext
            If (Nothing Is Me._el) Then
                Throw New NotSupportedException("This parser context does not support lookahead.")
            End If
            Dim result As ParserContext = New ParserContext(Me._el.LookAhead.GetEnumerator, true)
            Return result
        End Function
        Public ReadOnly Property Current() As Token
            Get
                Return Me._t
            End Get
        End Property
        Public Overloads Function GetLookAhead(ByVal start As Boolean) As ParserContext
            Dim result As ParserContext = Me.GetLookAhead
            If start Then
                result.EnsureStarted
            End If
            Return result
        End Function
        Public ReadOnly Property AdvanceCount() As Integer
            Get
                Return Me._advanceCount
            End Get
        End Property
        Public Sub ResetAdvanceCount()
            Me._advanceCount = 0
        End Sub
        Public ReadOnly Property SymbolId() As Integer
            Get
                Return Me._t.SymbolId
            End Get
        End Property
        Public ReadOnly Property Value() As String
            Get
                Return Me._t.Value
            End Get
        End Property
        Public ReadOnly Property Line() As Integer
            Get
                Return Me._t.Line
            End Get
        End Property
        Public ReadOnly Property Column() As Integer
            Get
                Return Me._t.Column
            End Get
        End Property
        Public ReadOnly Property Position() As Long
            Get
                Return Me._t.Position
            End Get
        End Property
        Public ReadOnly Property IsEnded() As Boolean
            Get
                Return (-2 = Me._state)
            End Get
        End Property
        Public Function Advance() As Boolean
            If (false = Me._e.MoveNext) Then
                Me._t.SymbolId = -2
                Me._state = -2
            Else
                'sanity check. should never happen
                If (Integer.MaxValue = Me._advanceCount) Then
                    Me._advanceCount = -1
                End If
                Me._advanceCount = (Me._advanceCount + 1)
                Me._state = 0
                Me._t = Me._e.Current
                Me._t.Line = (Me._t.Line + Me._line)
                Me._t.Column = (Me._t.Column + Me._column)
                Me._t.Position = (Me._t.Position + Me._position)
                If (Not (Me._t.Skipped) Is Nothing) Then
                    Me._skipped.AddRange(Me._t.Skipped)
                End If
                Return true
            End If
            Return false
        End Function
        Public Overloads Sub [Error](ByVal message As String, ByVal line As Integer, ByVal column As Integer, ByVal position As Long)
            Throw New SyntaxException(String.Format((message + " at line {0}, column {1}, position"), line, column, position), line, column, position)
        End Sub
        Public Overloads Sub [Error](ByVal message As String)
            Me.Error(message, Me.Line, Me.Column, Me.Position)
        End Sub
        Public Sub Dispose() Implements IDisposable.Dispose
            Me._e.Dispose
            Me._state = -3
        End Sub
    End Class
    '''<summary>
    '''An enumerator that provides lookahead without advancing the cursor
    '''</summary>
    '''<typeparam name="T">The type to enumerate</typeparam>
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")>  _
    Friend Class LookAheadEnumerator(Of T)
        Inherits Object
        Implements IEnumerator(Of T)
        Private Const _Enumerating As Integer = 0
        Private Const _NotStarted As Integer = -2
        Private Const _Ended As Integer = -1
        Private Const _Disposed As Integer = -3
        Private _inner As IEnumerator(Of T)
        Private _state As Integer
        'for the lookahead queue
        Private Const _DefaultCapacity As Integer = 16
        Private Const _GrowthFactor As Single = 0.9!
        Private _queue() As T
        Private _queueHead As Integer
        Private _queueCount As Integer
        '''<summary>
        '''Creates a new instance. Once this is created, the inner/wrapped enumerator must not be touched.
        '''</summary>
        '''<param name="inner"></param>
        Public Sub New(ByVal inner As IEnumerator(Of T))
            MyBase.New
            Me._inner = inner
            Me._state = LookAheadEnumerator(Of T)._NotStarted
            Me._queue = New T((LookAheadEnumerator(Of T)._DefaultCapacity) - 1) {}
            Me._queueHead = 0
            Me._queueCount = 0
        End Sub
        '''<summary>
        '''Discards the lookahead and advances the cursor to the physical position.
        '''</summary>
        Public Sub DiscardLookAhead()

            Do While (1 < Me._queueCount)
                Me._Dequeue

            Loop
        End Sub
        '''<summary>
        '''Retrieves the value under the cursor
        '''</summary>
        Public ReadOnly Property Current() As T Implements IEnumerator(Of T).Current
            Get
                If (0 > Me._state) Then
                    If (LookAheadEnumerator(Of T)._NotStarted = Me._state) Then
                        Throw New InvalidOperationException("The cursor is before the start of the enumeration.")
                    End If
                    If (LookAheadEnumerator(Of T)._Ended = Me._state) Then
                        Throw New InvalidOperationException("The cursor is after the end of the enumeration.")
                    End If
                    Throw New ObjectDisposedException(GetType(LookAheadEnumerator(Of T)).Name)
                End If
                Return Me._queue(Me._queueHead)
            End Get
        End Property
        'legacy enum support (required)
        ReadOnly Property System_Collections_IEnumerator_Current() As Object Implements System.Collections.IEnumerator.Current
            Get
                Return Me.Current
            End Get
        End Property
        Friend ReadOnly Property QueueCount() As Integer
            Get
                Return Me._queueCount
            End Get
        End Property
        '''<summary>
        '''Attempts to peek the specified number of positions from the current position without advancing
        '''</summary>
        '''<param name="lookahead">The offset from the current position to peek at</param>
        '''<param name="value">The value returned</param>
        '''<returns>True if the peek could be satisfied, otherwise false</returns>
        Public Function TryPeek(ByVal lookahead As Integer, ByRef value As T) As Boolean
            If (LookAheadEnumerator(Of T)._Disposed = Me._state) Then
                Throw New ObjectDisposedException(GetType(LookAheadEnumerator(Of T)).Name)
            End If
            If (0 > lookahead) Then
                Throw New ArgumentOutOfRangeException("lookahead")
            End If
            If (LookAheadEnumerator(Of T)._Ended = Me._state) Then
                value = CType(Nothing, T)
                Return false
            End If
            If (LookAheadEnumerator(Of T)._NotStarted = Me._state) Then
                If (0 = lookahead) Then
                    value = CType(Nothing, T)
                    Return false
                End If
            End If
            If (lookahead < Me._queueCount) Then
                value = Me._queue(((lookahead + Me._queueHead)  _
                            Mod Me._queue.Length))
                Return true
            End If
            lookahead = (lookahead - Me._queueCount)
            value = CType(Nothing, T)

            Do While ((0 <= lookahead)  _
                        AndAlso Me._inner.MoveNext)
                value = Me._inner.Current
                Me._Enqueue(value)
                lookahead = (lookahead - 1)

            Loop
            Return (-1 = lookahead)
        End Function
        '''<summary>
        '''Peek the specified number of positions from the current position without advancing
        '''</summary>
        '''<param name="lookahead">The offset from the current position to peek at</param>
        '''<returns>The value at the specified position</returns>
        Public Function Peek(ByVal lookahead As Integer) As T
            Dim value As T
            If (false = Me.TryPeek(lookahead, value)) Then
                Throw New InvalidOperationException("There were not enough values in the enumeration to satisfy the request")
            End If
            Return value
        End Function
        Friend ReadOnly Property IsEnumerating() As Boolean
            Get
                Return (-1 < Me._state)
            End Get
        End Property
        Friend ReadOnly Property IsEnded() As Boolean
            Get
                Return (LookAheadEnumerator(Of T)._Ended = Me._state)
            End Get
        End Property
        '''<summary>
        '''Retrieves a lookahead cursor from the current cursor that can be navigated without moving the main cursor
        '''</summary>
        Public ReadOnly Property LookAhead() As IEnumerable(Of T)
            Get
                If (0 > Me._state) Then
                    If (Me._state = LookAheadEnumerator(Of T)._NotStarted) Then
                        Throw New InvalidOperationException("The cursor is before the start of the enumeration.")
                    End If
                    If (Me._state = LookAheadEnumerator(Of T)._Ended) Then
                        Throw New InvalidOperationException("The cursor is after the end of the enumeration.")
                    End If
                    Throw New ObjectDisposedException(GetType(LookAheadEnumerator(Of T)).Name)
                End If
                Return New LookAheadEnumeratorEnumerable(Of T)(Me)
            End Get
        End Property
        '''<summary>
        '''Advances the cursor
        '''</summary>
        '''<returns>True if more input was read, otherwise false</returns>
        Function System_Collections_IEnumerator_MoveNext() As Boolean Implements System.Collections.IEnumerator.MoveNext
            If (0 > Me._state) Then
                If (LookAheadEnumerator(Of T)._Disposed = Me._state) Then
                    Throw New ObjectDisposedException(GetType(LookAheadEnumerator(Of T)).Name)
                End If
                If (LookAheadEnumerator(Of T)._Ended = Me._state) Then
                    Return false
                End If
                If (LookAheadEnumerator(Of T)._NotStarted = Me._state) Then
                    If (0 < Me._queueCount) Then
                        Me._state = LookAheadEnumerator(Of T)._Enumerating
                        Return true
                    End If
                    If (false = Me._inner.MoveNext) Then
                        Me._state = LookAheadEnumerator(Of T)._Ended
                        Return false
                    End If
                    Me._Enqueue(Me._inner.Current)
                    Me._state = LookAheadEnumerator(Of T)._Enumerating
                    Return true
                End If
            End If
            Me._Dequeue
            If (0 = Me._queueCount) Then
                If (false = Me._inner.MoveNext) Then
                    Me._state = LookAheadEnumerator(Of T)._Ended
                    Return false
                End If
                Me._Enqueue(Me._inner.Current)
            End If
            Return true
        End Function
        '''<summary>
        '''Resets the cursor, and clears the queue.
        '''</summary>
        Sub System_Collections_IEnumerator_Reset() Implements System.Collections.IEnumerator.Reset
            Me._inner.Reset
            If ((0 < Me._queueCount)  _
                        AndAlso (Nothing Is CType(Nothing, T))) Then
                System.Array.Clear(Me._queue, Me._queueHead, (Me._queue.Length - Me._queueHead))
                If ((Me._queueHead + Me._queueCount)  _
                            >= Me._queue.Length) Then
                    System.Array.Clear(Me._queue, 0, (Me._queueHead  _
                                    + (Me._queueCount Mod Me._queue.Length)))
                End If
            End If
            Me._queueHead = 0
            Me._queueCount = 0
            Me._state = LookAheadEnumerator(Of T)._NotStarted
        End Sub
        #Region "IDisposable Support"
        '''<summary>
        '''Disposes of this instance
        '''</summary>
        Sub System_IDisposable_Dispose() Implements System.IDisposable.Dispose
            If (false  _
                        = (LookAheadEnumerator(Of T)._Disposed = Me._state)) Then
                Me._inner.Dispose
                Me._state = LookAheadEnumerator(Of T)._Disposed
            End If
        End Sub
        Sub _Enqueue(ByVal item As T)
            If (Me._queueCount = Me._queue.Length) Then
                Dim arr((CType((Me._queue.Length  _
                            * (1 + LookAheadEnumerator(Of T)._GrowthFactor)),Integer)) - 1) As T
                If ((Me._queueHead + Me._queueCount)  _
                            <= Me._queue.Length) Then
                    System.Array.Copy(Me._queue, arr, Me._queueCount)
                    Me._queueHead = 0
                    arr(Me._queueCount) = item
                    Me._queueCount = (Me._queueCount + 1)
                    Me._queue = arr
                Else
                    System.Array.Copy(Me._queue, Me._queueHead, arr, 0, (Me._queue.Length - Me._queueHead))
                    System.Array.Copy(Me._queue, 0, arr, (Me._queue.Length - Me._queueHead), Me._queueHead)
                    Me._queueHead = 0
                    arr(Me._queueCount) = item
                    Me._queueCount = (Me._queueCount + 1)
                    Me._queue = arr
                End If
            Else
                Me._queue(((Me._queueHead + Me._queueCount)  _
                            Mod Me._queue.Length)) = item
                Me._queueCount = (Me._queueCount + 1)
            End If
        End Sub
        Function _Dequeue() As T
            If (0 = Me._queueCount) Then
                Throw New InvalidOperationException("The queue is empty")
            End If
            Dim result As T = Me._queue(Me._queueHead)
            Me._queue(Me._queueHead) = CType(Nothing, T)
            Me._queueHead = (Me._queueHead + 1)
            Me._queueHead = (Me._queueHead Mod Me._queue.Length)
            Me._queueCount = (Me._queueCount - 1)
            Return result
        End Function
        #End Region
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")>  _
    Friend Class LookAheadEnumeratorEnumerable(Of T)
        Inherits Object
        Implements IEnumerable(Of T)
        Private _outer As LookAheadEnumerator(Of T)
        Public Sub New(ByVal outer As LookAheadEnumerator(Of T))
            MyBase.New
            Me._outer = outer
        End Sub
        Public Function GetEnumerator() As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator
            'for some reason VB was resolving new as AddressOf, so use this.
            Dim result As LookAheadEnumeratorEnumerator(Of T) = CType(System.Activator.CreateInstance(GetType(LookAheadEnumeratorEnumerator(Of T)), Me._outer),LookAheadEnumeratorEnumerator(Of T))
            Return result
        End Function
        Function System_Collections_IEnumerable_GetEnumerator() As System.Collections.IEnumerator Implements System.Collections.IEnumerable.GetEnumerator
            Return Me.GetEnumerator
        End Function
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")>  _
    Friend Class LookAheadEnumeratorEnumerator(Of T)
        Inherits Object
        Implements IEnumerator(Of T)
        Private Const _NotStarted As Integer = -2
        Private Const _Ended As Integer = -1
        Private Const _Disposed As Integer = -3
        Private _outer As LookAheadEnumerator(Of T)
        Private _index As Integer
        Private _current As T
        Public Sub New(ByVal outer As LookAheadEnumerator(Of T))
            MyBase.New
            Me._outer = outer
            If Me._outer.IsEnumerating Then
                Me._current = Me._outer.Current
            End If
            Me._index = LookAheadEnumeratorEnumerator(Of T)._NotStarted
        End Sub
        Public ReadOnly Property Current() As T Implements IEnumerator(Of T).Current
            Get
                If (0 > Me._index) Then
                    If (Me._index = LookAheadEnumeratorEnumerator(Of T)._NotStarted) Then
                        Throw New InvalidOperationException("The cursor is before the start of the enumeration.")
                    End If
                    If (Me._index = LookAheadEnumeratorEnumerator(Of T)._Ended) Then
                        Throw New InvalidOperationException("The cursor is after the end of the enumeration.")
                    End If
                    Throw New ObjectDisposedException(GetType(LookAheadEnumeratorEnumerator(Of T)).Name)
                End If
                Return Me._current
            End Get
        End Property
        ReadOnly Property System_Collections_IEnumerator_Current() As Object Implements System.Collections.IEnumerator.Current
            Get
                Return Me.Current
            End Get
        End Property
        Sub System_IDisposable_Dispose() Implements System.IDisposable.Dispose
            Me._index = LookAheadEnumeratorEnumerator(Of T)._Disposed
        End Sub
        Function System_Collections_IEnumerator_MoveNext() As Boolean Implements System.Collections.IEnumerator.MoveNext
            Dim value As T
            If (0 > Me._index) Then
                If (Me._index = LookAheadEnumeratorEnumerator(Of T)._Disposed) Then
                    Throw New ObjectDisposedException(GetType(LookAheadEnumeratorEnumerator(Of T)).Name)
                End If
                If (Me._index = LookAheadEnumeratorEnumerator(Of T)._Ended) Then
                    Return false
                End If
                Me._index = -1
            End If
            Me._index = (Me._index + 1)
            If (false = Me._outer.TryPeek(Me._index, value)) Then
                Me._index = LookAheadEnumeratorEnumerator(Of T)._Ended
                Return false
            End If
            Me._current = value
            Return true
        End Function
        Sub System_Collections_IEnumerator_Reset() Implements System.Collections.IEnumerator.Reset
            Me._index = LookAheadEnumeratorEnumerator(Of T)._NotStarted
        End Sub
    End Class
End Namespace
