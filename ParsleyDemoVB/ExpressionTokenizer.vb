'------------------------------------------------------------------------------
' <auto-generated>
'     This code was generated by a tool.
'     Runtime Version:4.0.30319.42000
'
'     Changes to this file may cause incorrect behavior and will be lost if
'     the code is regenerated.
' </auto-generated>
'------------------------------------------------------------------------------

Option Strict Off
Option Explicit On

Imports System
Imports System.Collections.Generic
Imports System.Text

Namespace ParsleyDemo
    '''<summary>
    '''Reference implementation for generated shared code
    '''</summary>
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Rolex", "0.2.0.0")>  _
    Friend Structure Token
        '''<summary>
        '''Indicates the line where the token occurs
        '''</summary>
        Public Line As Integer
        '''<summary>
        '''Indicates the column where the token occurs
        '''</summary>
        Public Column As Integer
        '''<summary>
        '''Indicates the position where the token occurs
        '''</summary>
        Public Position As Long
        '''<summary>
        '''Indicates the symbol id or -1 for the error symbol
        '''</summary>
        Public SymbolId As Integer
        '''<summary>
        '''Indicates the value of the token
        '''</summary>
        Public Value As String
    End Structure
    '''<summary>
    '''Reference implementation for a DfaEntry
    '''</summary>
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Rolex", "0.2.0.0")>  _
    Friend Structure DfaEntry
        '''<summary>
        '''The state transitions
        '''</summary>
        Public Transitions() As DfaTransitionEntry
        '''<summary>
        '''The accept symbol id or -1 for non-accepting
        '''</summary>
        Public AcceptSymbolId As Integer
        '''<summary>
        '''Constructs a new instance
        '''</summary>
        '''<param name="transitions">The state transitions</param>
        '''<param name="acceptSymbolId">The accept symbol id</param>
        Public Sub New(ByVal transitions() As DfaTransitionEntry, ByVal acceptSymbolId As Integer)
            Me.Transitions = transitions
            Me.AcceptSymbolId = acceptSymbolId
        End Sub
    End Structure
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Rolex", "0.2.0.0")>  _
    Friend Structure DfaTransitionEntry
        '''<summary>
        '''The character ranges, packed as adjacent pairs.
        '''</summary>
        Public PackedRanges() As Char
        '''<summary>
        '''The destination state
        '''</summary>
        Public Destination As Integer
        '''<summary>
        '''Constructs a new instance
        '''</summary>
        '''<param name="packedRanges">The packed character ranges</param>
        '''<param name="destination">The destination state</param>
        Public Sub New(ByVal packedRanges() As Char, ByVal destination As Integer)
            Me.PackedRanges = packedRanges
            Me.Destination = destination
        End Sub
    End Structure
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Rolex", "0.2.0.0")>  _
    Friend Class TableTokenizer
        Inherits Object
        Implements IEnumerable(Of Token)
        Public Const ErrorSymbol As Integer = -1
        'our state table
        Private _dfaTable() As DfaEntry
        'our block ends (specified like comment<blockEnd="*/">="/*" in a rolex spec file)
        Private _blockEnds() As String
        'our node flags. Currently only used for the hidden attribute
        Private _nodeFlags() As Integer
        'the input cursor. We can get this from a string, a char array, or some other source.
        Private _input As IEnumerable(Of Char)
        '''<summary>
        '''Retrieves an enumerator that can be used to iterate over the tokens
        '''</summary>
        '''<returns>An enumerator that can be used to iterate over the tokens</returns>
        Public Function GetEnumerator() As IEnumerator(Of Token) Implements IEnumerable(Of Token).GetEnumerator
            'just create our table tokenizer's enumerator, passing all of the relevant stuff
            'it's the real workhorse.
            Return New TableTokenizerEnumerator(Me._dfaTable, Me._blockEnds, Me._nodeFlags, Me._input.GetEnumerator)
        End Function
        'legacy collection support (required)
        Function System_Collections_IEnumerable_GetEnumerator() As System.Collections.IEnumerator Implements System.Collections.IEnumerable.GetEnumerator
            Return Me.GetEnumerator
        End Function
        '''<summary>
        '''Constructs a new instance
        '''</summary>
        '''<param name="dfaTable">The DFA state table to use</param>
        '''<param name="blockEnds">The block ends table</param>
        '''<param name="nodeFlags">The node flags table</param>
        '''<param name="input">The input character sequence</param>
        Public Sub New(ByVal dfaTable() As DfaEntry, ByVal blockEnds() As String, ByVal nodeFlags() As Integer, ByVal input As IEnumerable(Of Char))
            MyBase.New
            If (Nothing Is dfaTable) Then
                Throw New ArgumentNullException("dfaTable")
            End If
            If (Nothing Is blockEnds) Then
                Throw New ArgumentNullException("blockEnds")
            End If
            If (Nothing Is nodeFlags) Then
                Throw New ArgumentNullException("nodeFlags")
            End If
            If (Nothing Is input) Then
                Throw New ArgumentNullException("input")
            End If
            Me._dfaTable = dfaTable
            Me._blockEnds = blockEnds
            Me._nodeFlags = nodeFlags
            Me._input = input
        End Sub
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Rolex", "0.2.0.0")>  _
    Friend Class TableTokenizerEnumerator
        Inherits Object
        Implements IEnumerator(Of Token)
        'our error symbol. Always -1
        Public Const ErrorSymbol As Integer = -1
        'our end of stream symbol - returned by _Lex() and used internally but not reported
        Private Const _EosSymbol As Integer = -2
        'our disposed state indicator
        Private Const _Disposed As Integer = -4
        'the state indicates the cursor is before the beginning (initial state)
        Private Const _BeforeBegin As Integer = -3
        'the state indicates the cursor is after the end
        Private Const _AfterEnd As Integer = -2
        'the state indicates that the inner input enumeration has finished (we still have one more token to report)
        Private Const _InnerFinished As Integer = -1
        'indicates we're currently enumerating. We spend most of our time and effort in this state
        Private Const _Enumerating As Integer = 0
        'indicates the tab width, used for updating the Column property when we encounter a tab
        Private Const _TabWidth As Integer = 4
        'the DFA state table to use.
        Private _dfaTable() As DfaEntry
        'the blockEnds to use
        Private _blockEnds() As String
        'the nodeFlags to use
        Private _nodeFlags() As Integer
        'the input cursor
        Private _input As IEnumerator(Of Char)
        'our state
        Private _state As Integer
        'the current token
        Private _current As Token
        'a buffer used primarily by _Lex() to capture matched input
        Private _buffer As StringBuilder
        'the one based line
        Private _line As Integer
        'the one based column
        Private _column As Integer
        'the zero based position
        Private _position As Long
        Public Sub New(ByVal dfaTable() As DfaEntry, ByVal blockEnds() As String, ByVal nodeFlags() As Integer, ByVal input As IEnumerator(Of Char))
            MyBase.New
            'just set up our initial values
            Me._dfaTable = dfaTable
            Me._blockEnds = blockEnds
            Me._nodeFlags = nodeFlags
            Me._input = input
            Me._state = TableTokenizerEnumerator._BeforeBegin
            Me._buffer = New StringBuilder()
            Me._line = 1
            Me._column = 1
            Me._position = 0
        End Sub
        Public ReadOnly Property Current() As Token Implements IEnumerator(Of Token).Current
            Get
                'if we're not enumerating, find out what's going on
                If (TableTokenizerEnumerator._Enumerating > Me._state) Then
                    'check which state we're in, and throw accordingly
                    If (TableTokenizerEnumerator._BeforeBegin = Me._state) Then
                        Throw New InvalidOperationException("The cursor is before the start of the enumeration")
                    End If
                    If (TableTokenizerEnumerator._AfterEnd = Me._state) Then
                        Throw New InvalidOperationException("The cursor is after the end of the enumeration")
                    End If
                    If (TableTokenizerEnumerator._Disposed = Me._state) Then
                        TableTokenizerEnumerator._ThrowDisposed
                    End If
                End If
                Return Me._current
            End Get
        End Property
        ReadOnly Property System_Collections_IEnumerator_Current() As Object Implements System.Collections.IEnumerator.Current
            Get
                Return Me.Current
            End Get
        End Property
        Sub System_Collections_IEnumerator_Reset() Implements System.Collections.IEnumerator.Reset
            If (TableTokenizerEnumerator._Disposed = Me._state) Then
                TableTokenizerEnumerator._ThrowDisposed
            End If
            If (false  _
                        = (TableTokenizerEnumerator._BeforeBegin = Me._state)) Then
                Me._input.Reset
            End If
            Me._state = TableTokenizerEnumerator._BeforeBegin
            Me._line = 1
            Me._column = 1
            Me._position = 0
        End Sub
        Function System_Collections_IEnumerator_MoveNext() As Boolean Implements System.Collections.IEnumerator.MoveNext
            'if we're not enumerating
            If (TableTokenizerEnumerator._Enumerating > Me._state) Then
                If (TableTokenizerEnumerator._Disposed = Me._state) Then
                    TableTokenizerEnumerator._ThrowDisposed
                End If
                If (TableTokenizerEnumerator._AfterEnd = Me._state) Then
                    Return false
                End If
            End If
            Me._current = CType(Nothing, Token)
            Me._current.Line = Me._line
            Me._current.Column = Me._column
            Me._current.Position = Me._position
            Me._buffer.Clear
            'lex the next input
            Me._current.SymbolId = Me._Lex
            'now look for hiddens and block ends
            Dim done As Boolean = false

            Do While (false = done)
                done = true
                'if we're on a valid symbol
                If (TableTokenizerEnumerator.ErrorSymbol < Me._current.SymbolId) Then
                    'get the block end for our symbol
                    Dim be As String = Me._blockEnds(Me._current.SymbolId)
                    If ((Not (be) Is Nothing)  _
                                AndAlso (false  _
                                = (0 = be.Length))) Then
                        'read until we find it or end of input
                        If (false = Me._TryReadUntilBlockEnd(be)) Then
                            Me._current.SymbolId = TableTokenizerEnumerator.ErrorSymbol
                        End If
                    End If
                    If ((TableTokenizerEnumerator.ErrorSymbol < Me._current.SymbolId)  _
                                AndAlso (false  _
                                = (0  _
                                = (Me._nodeFlags(Me._current.SymbolId) And 1)))) Then
                        'update the cursor position and lex the next input, skipping this one
                        done = false
                        Me._current.Line = Me._line
                        Me._current.Column = Me._column
                        Me._current.Position = Me._position
                        Me._buffer.Clear
                        Me._current.SymbolId = Me._Lex
                    End If
                End If

            Loop
            Me._current.Value = Me._buffer.ToString
            'update our state if we hit the end
            If (TableTokenizerEnumerator._EosSymbol = Me._current.SymbolId) Then
                Me._state = TableTokenizerEnumerator._AfterEnd
            End If
            Return (false  _
                        = (TableTokenizerEnumerator._AfterEnd = Me._state))
        End Function
        Sub IDisposable_Dispose() Implements IDisposable.Dispose
            Me._input.Dispose
            Me._state = TableTokenizerEnumerator._Disposed
        End Sub
        'moves to the next position, updates the state accordingly, and tracks the cursor position
        Function _MoveNextInput() As Boolean
            If Me._input.MoveNext Then
                If (false  _
                            = (TableTokenizerEnumerator._BeforeBegin = Me._state)) Then
                    Me._position = (Me._position + 1)
                    If (Global.Microsoft.VisualBasic.ChrW(10) = Me._input.Current) Then
                        Me._column = 1
                        Me._line = (Me._line + 1)
                    Else
                        If (Global.Microsoft.VisualBasic.ChrW(9) = Me._input.Current) Then
                            Me._column = (Me._column + TableTokenizerEnumerator._TabWidth)
                        Else
                            Me._column = (Me._column + 1)
                        End If
                    End If
                Else
                    'corner case for first move
                    If (Global.Microsoft.VisualBasic.ChrW(10) = Me._input.Current) Then
                        Me._column = 1
                        Me._line = (Me._line + 1)
                    Else
                        If (Global.Microsoft.VisualBasic.ChrW(9) = Me._input.Current) Then
                            Me._column = (Me._column  _
                                        + (TableTokenizerEnumerator._TabWidth - 1))
                        End If
                    End If
                End If
                Return true
            End If
            Me._state = TableTokenizerEnumerator._InnerFinished
            Return false
        End Function
        'reads until the specified character, consuming it, returning false if it wasn't found
        Function _TryReadUntil(ByVal character As Char) As Boolean
            Dim ch As Char = Me._input.Current
            Me._buffer.Append(ch)
            If (ch = character) Then
                Return true
            End If

            Do While (Me._MoveNextInput  _
                        AndAlso (false  _
                        = (Me._input.Current = character)))
                Me._buffer.Append(Me._input.Current)

            Loop
            If (false  _
                        = (Me._state = TableTokenizerEnumerator._InnerFinished)) Then
                Me._buffer.Append(Me._input.Current)
                Return (Me._input.Current = character)
            End If
            Return false
        End Function
        'reads until the string is encountered, capturing it.
        Function _TryReadUntilBlockEnd(ByVal blockEnd As String) As Boolean

            Do While ((false  _
                        = (TableTokenizerEnumerator._InnerFinished = Me._state))  _
                        AndAlso Me._TryReadUntil(blockEnd(0)))
                Dim found As Boolean = true
                Dim i As Integer = 1
                Do While (found  _
                            AndAlso (i < blockEnd.Length))
                    If (false  _
                                = (Me._MoveNextInput  _
                                OrElse (false  _
                                = (Me._input.Current = blockEnd(i))))) Then
                        found = false
                    Else
                        If (false  _
                                    = (TableTokenizerEnumerator._InnerFinished = Me._state)) Then
                            Me._buffer.Append(Me._input.Current)
                        End If
                    End If
                    i = (i + 1)
                Loop
                If found Then
                    Me._MoveNextInput
                    Return true
                End If

            Loop
            Return false
        End Function
        'lex the next token
        Function _Lex() As Integer
            'our accepting symbol id
            Dim acceptSymbolId As Integer
            Dim dfaState As Integer = 0
            If (TableTokenizerEnumerator._BeforeBegin = Me._state) Then
                If (false = Me._MoveNextInput) Then
                    'if we're on an accepting state, return that
                    'otherwise, error
                    acceptSymbolId = Me._dfaTable(dfaState).AcceptSymbolId
                    If (false  _
                                = (-1 = acceptSymbolId)) Then
                        Return acceptSymbolId
                    Else
                        Return TableTokenizerEnumerator.ErrorSymbol
                    End If
                End If
                Me._state = TableTokenizerEnumerator._Enumerating
            Else
                If ((TableTokenizerEnumerator._InnerFinished = Me._state)  _
                            OrElse (TableTokenizerEnumerator._AfterEnd = Me._state)) Then
                    'if we're at the end just return the end symbol
                    Return TableTokenizerEnumerator._EosSymbol
                End If
            End If
            Dim done As Boolean = false

            Do While (false = done)
                Dim nextDfaState As Integer = -1
                Dim i As Integer = 0
                Do While (i < Me._dfaTable(dfaState).Transitions.Length)
                    Dim entry As DfaTransitionEntry = Me._dfaTable(dfaState).Transitions(i)
                    Dim found As Boolean = false
                    Dim j As Integer = 0
                    Do While (j < entry.PackedRanges.Length)
                        Dim ch As Char = Me._input.Current
                        Dim first As Char = entry.PackedRanges(j)
                        j = (j + 1)
                        Dim last As Char = entry.PackedRanges(j)
                        If (ch <= last) Then
                            If (first <= ch) Then
                                found = true
                            End If
                            j = (Integer.MaxValue - 1)
                            'break
                        End If
                        j = (j + 1)
                    Loop
                    If found Then
                        'set the transition destination
                        nextDfaState = entry.Destination
                        i = (Integer.MaxValue - 1)
                        'break
                    End If
                    i = (i + 1)
                Loop
                If (false  _
                            = (-1 = nextDfaState)) Then
                    'capture our character
                    Me._buffer.Append(Me._input.Current)
                    'and iterate to our next state
                    dfaState = nextDfaState
                    If (false = Me._MoveNextInput) Then
                        'end of stream, if we're on an accepting state,
                        'return that, just like we do on empty string
                        'if we're not, then we error, just like before
                        acceptSymbolId = Me._dfaTable(dfaState).AcceptSymbolId
                        If (false  _
                                    = (-1 = acceptSymbolId)) Then
                            Return acceptSymbolId
                        Else
                            Return TableTokenizerEnumerator.ErrorSymbol
                        End If
                    End If
                Else
                    done = true
                End If
                'no valid transition, we can exit the loop

            Loop
            acceptSymbolId = Me._dfaTable(dfaState).AcceptSymbolId
            If (false  _
                        = (-1 = acceptSymbolId)) Then
                Return acceptSymbolId
            Else
                'handle the error condition
                'we have to capture the input
                'here and then advance or the
                'machine will never halt
                Me._buffer.Append(Me._input.Current)
                Me._MoveNextInput
                Return TableTokenizerEnumerator.ErrorSymbol
            End If
        End Function
        Shared Sub _ThrowDisposed()
            Throw New ObjectDisposedException("TableTokenizerEnumerator")
        End Sub
    End Class
    Friend Class ExpressionTokenizer
        Inherits TableTokenizer
        Friend Shared DfaTable() As DfaEntry = New DfaEntry() {New DfaEntry(New DfaTransitionEntry() {New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(43), Global.Microsoft.VisualBasic.ChrW(43)}, 1), New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(42), Global.Microsoft.VisualBasic.ChrW(42)}, 2), New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(48), Global.Microsoft.VisualBasic.ChrW(57)}, 3), New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(65), Global.Microsoft.VisualBasic.ChrW(90), Global.Microsoft.VisualBasic.ChrW(95), Global.Microsoft.VisualBasic.ChrW(95), Global.Microsoft.VisualBasic.ChrW(97), Global.Microsoft.VisualBasic.ChrW(122)}, 4), New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(9), Global.Microsoft.VisualBasic.ChrW(13), Global.Microsoft.VisualBasic.ChrW(32), Global.Microsoft.VisualBasic.ChrW(32)}, 6), New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(45), Global.Microsoft.VisualBasic.ChrW(45)}, 7), New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(47), Global.Microsoft.VisualBasic.ChrW(47)}, 8), New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(40), Global.Microsoft.VisualBasic.ChrW(40)}, 9), New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(41), Global.Microsoft.VisualBasic.ChrW(41)}, 10)}, -1), New DfaEntry(New DfaTransitionEntry(-1) {}, 12), New DfaEntry(New DfaTransitionEntry(-1) {}, 18), New DfaEntry(New DfaTransitionEntry() {New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(48), Global.Microsoft.VisualBasic.ChrW(57)}, 3)}, 14), New DfaEntry(New DfaTransitionEntry() {New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(48), Global.Microsoft.VisualBasic.ChrW(57), Global.Microsoft.VisualBasic.ChrW(65), Global.Microsoft.VisualBasic.ChrW(90), Global.Microsoft.VisualBasic.ChrW(95), Global.Microsoft.VisualBasic.ChrW(95), Global.Microsoft.VisualBasic.ChrW(97), Global.Microsoft.VisualBasic.ChrW(122)}, 5)}, 15), New DfaEntry(New DfaTransitionEntry() {New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(48), Global.Microsoft.VisualBasic.ChrW(57), Global.Microsoft.VisualBasic.ChrW(65), Global.Microsoft.VisualBasic.ChrW(90), Global.Microsoft.VisualBasic.ChrW(95), Global.Microsoft.VisualBasic.ChrW(95), Global.Microsoft.VisualBasic.ChrW(97), Global.Microsoft.VisualBasic.ChrW(122)}, 5)}, 15), New DfaEntry(New DfaTransitionEntry() {New DfaTransitionEntry(New Char() {Global.Microsoft.VisualBasic.ChrW(9), Global.Microsoft.VisualBasic.ChrW(13), Global.Microsoft.VisualBasic.ChrW(32), Global.Microsoft.VisualBasic.ChrW(32)}, 6)}, 20), New DfaEntry(New DfaTransitionEntry(-1) {}, 13), New DfaEntry(New DfaTransitionEntry(-1) {}, 19), New DfaEntry(New DfaTransitionEntry(-1) {}, 16), New DfaEntry(New DfaTransitionEntry(-1) {}, 17)}
        Friend Shared NodeFlags() As Integer = New Integer() {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
        Friend Shared BlockEnds() As String = New String() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}
        Public Sub New(ByVal input As IEnumerable(Of Char))
            MyBase.New(ExpressionTokenizer.DfaTable, ExpressionTokenizer.BlockEnds, ExpressionTokenizer.NodeFlags, input)
        End Sub
        Public Const add As Integer = 12
        Public Const Implicit As Integer = 13
        Public Const [integer] As Integer = 14
        Public Const identifier As Integer = 15
        Public Const Implicit3 As Integer = 16
        Public Const Implicit4 As Integer = 17
        Public Const mul As Integer = 18
        Public Const Implicit2 As Integer = 19
        Public Const whitespace As Integer = 20
    End Class
End Namespace
