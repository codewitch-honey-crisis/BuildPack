'------------------------------------------------------------------------------
' <auto-generated>
'     This code was generated by a tool.
'     Runtime Version:4.0.30319.42000
'
'     Changes to this file may cause incorrect behavior and will be lost if
'     the code is regenerated.
' </auto-generated>
'------------------------------------------------------------------------------

Option Strict Off
Option Explicit On

Imports System
Imports System.Collections.Generic

Namespace ParsleyDemo
    '''<summary>Parses the following grammar:
    '''Expression= Term "+" Expression | Term;
    '''Term= Term "*" Factor | Factor;
    '''Factor= "(" Expression ")" | integer | identifier;
    '''integer= '[0-9]+';
    '''identifier= '[A-Z_a-z][0-9A-Z_a-z]*';
    '''(whitespace)= '\s+';
    '''add= "+";
    '''sub= "-";
    '''mul= "*";
    '''div= "/";
    '''lparen= "(";
    '''rparen= ")";
    '''</summary>
    '''<remarks>The rules for the factored grammar are as follows:
    '''Term -> Factor TermRightAssoc
    '''Factor -> lparen Expression rparen
    '''Factor -> integer
    '''Factor -> identifier
    '''TermRightAssoc -> mul Factor TermRightAssoc
    '''TermRightAssoc ->
    '''Expression -> Term ExpressionPart
    '''ExpressionPart -> add Expression
    '''ExpressionPart ->
    '''</remarks>
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")>  _
    Partial Friend Class ExpressionParser
        Friend Const ErrorSymbol As Integer = -1
        Friend Const EosSymbol As Integer = -2
        Public Const Term As Integer = 0
        Public Const Factor As Integer = 1
        Public Const TermRightAssoc As Integer = 2
        Public Const Expression As Integer = 3
        Public Const ExpressionPart As Integer = 4
        Public Const lparen As Integer = 5
        Public Const rparen As Integer = 6
        Public Const [integer] As Integer = 7
        Public Const identifier As Integer = 8
        Public Const mul As Integer = 9
        Public Const add As Integer = 10
        Public Const whitespace As Integer = 11
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",9)
        Private Shared Function _ParseTerm(ByVal context As ParserContext) As ParseNode
            Dim line As Integer = context.Line
            Dim column As Integer = context.Column
            Dim position As Long = context.Position
            If (((ExpressionParser.lparen = context.SymbolId)  _
                        OrElse (ExpressionParser.[integer] = context.SymbolId))  _
                        OrElse (ExpressionParser.identifier = context.SymbolId)) Then
                'Term -> Factor TermRightAssoc
                Dim children(1) As ParseNode
                children(0) = ExpressionParser._ParseFactor(context)
                children(1) = ExpressionParser._ParseTermRightAssoc(context)
                Return New ParseNode(ExpressionParser.Term, "Term", children, line, column, position)
            End If
            context.Error("Expecting lparen, integer, or identifier")
            Return Nothing
        End Function
        
        #End ExternalSource
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",17)
        Private Shared Function _ParseFactor(ByVal context As ParserContext) As ParseNode
            Dim line As Integer = context.Line
            Dim column As Integer = context.Column
            Dim position As Long = context.Position
            If (ExpressionParser.lparen = context.SymbolId) Then
                'Factor -> lparen Expression rparen
                Dim children(2) As ParseNode
                children(0) = New ParseNode(ExpressionParser.lparen, "lparen", context.Value, line, column, position)
                context.Advance
                children(1) = ExpressionParser._ParseExpression(context)
                children(2) = New ParseNode(ExpressionParser.rparen, "rparen", context.Value, line, column, position)
                If (ExpressionParser.rparen = context.SymbolId) Then
                    context.Advance
                    Return New ParseNode(ExpressionParser.Factor, "Factor", children, line, column, position)
                End If
                context.Error("Expecting rparen")
            End If
            If (ExpressionParser.[integer] = context.SymbolId) Then
                'Factor -> integer
                Dim children(0) As ParseNode
                children(0) = New ParseNode(ExpressionParser.[integer], "integer", context.Value, line, column, position)
                context.Advance
                Return New ParseNode(ExpressionParser.Factor, "Factor", children, line, column, position)
            End If
            If (ExpressionParser.identifier = context.SymbolId) Then
                'Factor -> identifier
                Dim children(0) As ParseNode
                children(0) = New ParseNode(ExpressionParser.identifier, "identifier", context.Value, line, column, position)
                context.Advance
                Return New ParseNode(ExpressionParser.Factor, "Factor", children, line, column, position)
            End If
            context.Error("Expecting lparen, integer, or identifier")
            Return Nothing
        End Function
        
        #End ExternalSource
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",9)
        Private Shared Function _ParseTermRightAssoc(ByVal context As ParserContext) As ParseNode
            Dim line As Integer = context.Line
            Dim column As Integer = context.Column
            Dim position As Long = context.Position
            If (ExpressionParser.mul = context.SymbolId) Then
                'TermRightAssoc -> mul Factor TermRightAssoc
                Dim children(2) As ParseNode
                children(0) = New ParseNode(ExpressionParser.mul, "mul", context.Value, line, column, position)
                context.Advance
                children(1) = ExpressionParser._ParseFactor(context)
                children(2) = ExpressionParser._ParseTermRightAssoc(context)
                Return New ParseNode(ExpressionParser.Term, "Term", children, line, column, position)
            End If
            If (((ExpressionParser.add = context.SymbolId)  _
                        OrElse (ExpressionParser.EosSymbol = context.SymbolId))  _
                        OrElse (ExpressionParser.rparen = context.SymbolId)) Then
                'TermRightAssoc ->
                Dim children(-1) As ParseNode
                Return New ParseNode(ExpressionParser.Term, "Term", children, line, column, position)
            End If
            context.Error("Expecting mul, add, #EOS, or rparen")
            Return Nothing
        End Function
        
        #End ExternalSource
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",1)
        Private Shared Function _ParseExpression(ByVal context As ParserContext) As ParseNode
            Dim line As Integer = context.Line
            Dim column As Integer = context.Column
            Dim position As Long = context.Position
            If (((ExpressionParser.lparen = context.SymbolId)  _
                        OrElse (ExpressionParser.[integer] = context.SymbolId))  _
                        OrElse (ExpressionParser.identifier = context.SymbolId)) Then
                'Expression -> Term ExpressionPart
                Dim children As System.Collections.Generic.List(Of ParseNode) = New System.Collections.Generic.List(Of ParseNode)()
                children.Add(ExpressionParser._ParseTerm(context))
                children.AddRange(ExpressionParser._ParseExpressionPart(context).Children)
                Return New ParseNode(ExpressionParser.Expression, "Expression", children.ToArray, line, column, position)
            End If
            context.Error("Expecting lparen, integer, or identifier")
            Return Nothing
        End Function
        
        #End ExternalSource
        Private Shared Function _ParseExpressionPart(ByVal context As ParserContext) As ParseNode
            Dim line As Integer = context.Line
            Dim column As Integer = context.Column
            Dim position As Long = context.Position
            If (ExpressionParser.add = context.SymbolId) Then
                'ExpressionPart -> add Expression
                Dim children(1) As ParseNode
                children(0) = New ParseNode(ExpressionParser.add, "add", context.Value, line, column, position)
                context.Advance
                children(1) = ExpressionParser._ParseExpression(context)
                Return New ParseNode(ExpressionParser.ExpressionPart, "ExpressionPart", children, line, column, position)
            End If
            If ((ExpressionParser.EosSymbol = context.SymbolId)  _
                        OrElse (ExpressionParser.rparen = context.SymbolId)) Then
                'ExpressionPart ->
                Dim children(-1) As ParseNode
                Return New ParseNode(ExpressionParser.ExpressionPart, "ExpressionPart", children, line, column, position)
            End If
            context.Error("Expecting add, #EOS, or rparen")
            Return Nothing
        End Function
        '''<summary>
        '''Parses a production of the form:
        '''Expression= Term "+" Expression | Term
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Expression -> Term ExpressionPart
        '''</remarks>
        '''<param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",1)
        Public Shared Function ParseExpression(ByVal tokenizer As System.Collections.Generic.IEnumerable(Of Token)) As ParseNode
            Dim context As ParserContext = New ParserContext(tokenizer)
            context.EnsureStarted
            Return ExpressionParser._ParseExpression(context)
        End Function
        
        #End ExternalSource
        '''<summary>
        '''Parses a production of the form:
        '''Term= Term "*" Factor | Factor
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Term -> Factor TermRightAssoc
        '''</remarks>
        '''<param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",9)
        Public Shared Function ParseTerm(ByVal tokenizer As System.Collections.Generic.IEnumerable(Of Token)) As ParseNode
            Dim context As ParserContext = New ParserContext(tokenizer)
            context.EnsureStarted
            Return ExpressionParser._ParseTerm(context)
        End Function
        
        #End ExternalSource
        '''<summary>
        '''Parses a production of the form:
        '''Factor= "(" Expression ")" | integer | identifier
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Factor -> lparen Expression rparen
        '''Factor -> integer
        '''Factor -> identifier
        '''</remarks>
        '''<param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",17)
        Public Shared Function ParseFactor(ByVal tokenizer As System.Collections.Generic.IEnumerable(Of Token)) As ParseNode
            Dim context As ParserContext = New ParserContext(tokenizer)
            context.EnsureStarted
            Return ExpressionParser._ParseFactor(context)
        End Function
        
        #End ExternalSource
        '''<summary>
        '''Parses a derivation of the form:
        '''Expression= Term "+" Expression | Term
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Expression -> Term ExpressionPart
        '''</remarks>
        '''<param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",1)
        Public Shared Function Parse(ByVal tokenizer As System.Collections.Generic.IEnumerable(Of Token)) As ParseNode
            Dim context As ParserContext = New ParserContext(tokenizer)
            context.EnsureStarted
            Return ExpressionParser._ParseExpression(context)
        End Function
        
        #End ExternalSource
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Expression= Term "+" Expression | Term
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Expression -> Term ExpressionPart
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<returns>The result of the evaluation</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",1)
        Public Overloads Shared Function Evaluate(ByVal node As ParseNode) As Integer
            Return ExpressionParser.EvaluateExpression(node)
        End Function
        
        #End ExternalSource
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Expression= Term "+" Expression | Term
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Expression -> Term ExpressionPart
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",1)
        Public Overloads Shared Function Evaluate(ByVal node As ParseNode, ByVal state As Object) As Integer
            Return ExpressionParser.EvaluateExpression(node, state)
        End Function
        
        #End ExternalSource
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Expression= Term "+" Expression | Term
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Expression -> Term ExpressionPart
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",1)
        Public Overloads Shared Function EvaluateExpression(ByVal node As ParseNode, ByVal state As Object) As Integer
            If (ExpressionParser.Expression = node.SymbolId) Then
                If (node.Children.Length = 1) Then
                    Return CType(ExpressionParser._ChangeType(ExpressionParser.EvaluateTerm(node.Children(0), state), GetType(Integer)),Integer)
                End If
                If (node.Children(1).SymbolId = ParsleyDemo.ExpressionParser.add) Then
                    Return CType(ExpressionParser._ChangeType((ExpressionParser.EvaluateTerm(node.Children(0), state) + ExpressionParser.EvaluateExpression(node.Children(2), state)), GetType(Integer)),Integer)
                Else
                    Return CType(ExpressionParser._ChangeType((ExpressionParser.EvaluateTerm(node.Children(0), state) - ExpressionParser.EvaluateExpression(node.Children(2), state)), GetType(Integer)),Integer)
                End If
            End If
            Throw New SyntaxException("Expecting Expression", node.Line, node.Column, node.Position)
        End Function
        
        #End ExternalSource
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Expression= Term "+" Expression | Term
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Expression -> Term ExpressionPart
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<returns>The result of the evaluation</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",1)
        Public Overloads Shared Function EvaluateExpression(ByVal node As ParseNode) As Integer
            Return ExpressionParser.EvaluateExpression(node, Nothing)
        End Function
        
        #End ExternalSource
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Term= Term "*" Factor | Factor
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Term -> Factor TermRightAssoc
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",9)
        Public Overloads Shared Function EvaluateTerm(ByVal node As ParseNode, ByVal state As Object) As Integer
            If (ExpressionParser.Term = node.SymbolId) Then
                If (node.Children.Length = 1) Then
                    Return CType(ExpressionParser._ChangeType(ExpressionParser.EvaluateFactor(node.Children(0), state), GetType(Integer)),Integer)
                End If
                If (node.Children(1).SymbolId = ParsleyDemo.ExpressionParser.mul) Then
                    Return CType(ExpressionParser._ChangeType((ExpressionParser.EvaluateTerm(node.Children(0), state) * ExpressionParser.EvaluateFactor(node.Children(2), state)), GetType(Integer)),Integer)
                Else
                    Return CType(ExpressionParser._ChangeType((ExpressionParser.EvaluateTerm(node.Children(0), state) / ExpressionParser.EvaluateFactor(node.Children(2), state)), GetType(Integer)),Integer)
                End If
            End If
            Throw New SyntaxException("Expecting Term", node.Line, node.Column, node.Position)
        End Function
        
        #End ExternalSource
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Term= Term "*" Factor | Factor
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Term -> Factor TermRightAssoc
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<returns>The result of the evaluation</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",9)
        Public Overloads Shared Function EvaluateTerm(ByVal node As ParseNode) As Integer
            Return ExpressionParser.EvaluateTerm(node, Nothing)
        End Function
        
        #End ExternalSource
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Factor= "(" Expression ")" | integer | identifier
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Factor -> lparen Expression rparen
        '''Factor -> integer
        '''Factor -> identifier
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",17)
        Public Overloads Shared Function EvaluateFactor(ByVal node As ParseNode, ByVal state As Object) As Integer
            If (ExpressionParser.Factor = node.SymbolId) Then
                If (node.Children.Length = 1) Then
                    If (node.Children(0).SymbolId = ParsleyDemo.ExpressionParser.[integer]) Then
                        Return CType(ExpressionParser._ChangeType(node.Children(0).Value, GetType(Integer)),Integer)
                    Else
                        If (Nothing Is state) Then
                            Throw New InvalidOperationException("Variables were not defined.")
                        End If
                        Return CType(ExpressionParser._ChangeType(CType(state,IDictionary(Of String, Integer))(node.Children(0).Value), GetType(Integer)),Integer)
                    End If
                End If
                Return CType(ExpressionParser._ChangeType(ExpressionParser.EvaluateExpression(node.Children(1), state), GetType(Integer)),Integer)
            End If
            Throw New SyntaxException("Expecting Factor", node.Line, node.Column, node.Position)
        End Function
        
        #End ExternalSource
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Factor= "(" Expression ")" | integer | identifier
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Factor -> lparen Expression rparen
        '''Factor -> integer
        '''Factor -> identifier
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<returns>The result of the evaluation</returns>
        
        #ExternalSource("C:\dev\BuildPack\Parsley\Expression.xbnf",17)
        Public Overloads Shared Function EvaluateFactor(ByVal node As ParseNode) As Integer
            Return ExpressionParser.EvaluateFactor(node, Nothing)
        End Function
        
        #End ExternalSource
        Private Shared Function _ChangeType(ByVal obj As Object, ByVal type As System.Type) As Object
            Dim typeConverter As System.ComponentModel.TypeConverter = System.ComponentModel.TypeDescriptor.GetConverter(obj)
            If ((Nothing Is typeConverter)  _
                        OrElse (false = typeConverter.CanConvertTo(type))) Then
                Return System.Convert.ChangeType(obj, type)
            End If
            Return typeConverter.ConvertTo(obj, type)
        End Function
    End Class
    '''<summary>
    '''
    '''</summary>
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")>  _
    Friend Class SyntaxException
        Inherits Exception
        Private _line As Integer
        Private _column As Integer
        Private _position As Long
        '''<summary>
        '''Creates a syntax exception with the specified arguments
        '''</summary>
        '''<param name="message">The error message</param>
        '''<param name="line">The line where the error occurred</param>
        '''<param name="column">The column where the error occured</param>
        '''<param name="position">The position where the error occured</param>
        Public Sub New(ByVal message As String, ByVal line As Integer, ByVal column As Integer, ByVal position As Long)
            MyBase.New(SyntaxException._GetMessage(message, line, column, position))
            Me._line = line
            Me._column = column
            Me._position = position
        End Sub
        '''<summary>
        '''The line where the error occurred
        '''</summary>
        Public ReadOnly Property Line() As Integer
            Get
                Return Me._line
            End Get
        End Property
        '''<summary>
        '''The column where the error occurred
        '''</summary>
        Public ReadOnly Property Column() As Integer
            Get
                Return Me._column
            End Get
        End Property
        '''<summary>
        '''The position where the error occurred
        '''</summary>
        Public ReadOnly Property Position() As Long
            Get
                Return Me._position
            End Get
        End Property
        Shared Function _GetMessage(ByVal message As String, ByVal line As Integer, ByVal column As Integer, ByVal position As Long) As String
            Return String.Format("{0} at line {1}, column {2}, position {3}", message, line, column, position)
        End Function
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")>  _
    Partial Friend Class ParseNode
        Private _symbolId As Integer
        Private _symbol As String
        Private _value As String
        Private _line As Integer
        Private _column As Integer
        Private _position As Long
        Private _children() As ParseNode
        Public Sub New(ByVal symbolId As Integer, ByVal symbol As String, ByVal children() As ParseNode, ByVal line As Integer, ByVal column As Integer, ByVal position As Long)
            MyBase.New
            Me._symbolId = symbolId
            Me._symbol = symbol
            Me._value = Nothing
            Me._children = children
            Me._line = line
            Me._column = column
            Me._position = position
        End Sub
        Public Sub New(ByVal symbolId As Integer, ByVal symbol As String, ByVal value As String, ByVal line As Integer, ByVal column As Integer, ByVal position As Long)
            MyBase.New
            Me._symbolId = symbolId
            Me._symbol = symbol
            Me._value = value
            Me._children = Nothing
            Me._line = line
            Me._column = column
            Me._position = position
        End Sub
        Public ReadOnly Property IsNonTerminal() As Boolean
            Get
                Return (Not (Me._children) Is Nothing)
            End Get
        End Property
        Public ReadOnly Property Children() As ParseNode()
            Get
                Return Me._children
            End Get
        End Property
        Public ReadOnly Property SymbolId() As Integer
            Get
                Return Me._symbolId
            End Get
        End Property
        Public ReadOnly Property Symbol() As String
            Get
                Return Me._symbol
            End Get
        End Property
        Public ReadOnly Property Value() As String
            Get
                Return Me._value
            End Get
        End Property
        Public ReadOnly Property Line() As Integer
            Get
                Return Me._line
            End Get
        End Property
        Public ReadOnly Property Column() As Integer
            Get
                Return Me._column
            End Get
        End Property
        Public ReadOnly Property Position() As Long
            Get
                Return Me._position
            End Get
        End Property
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")>  _
    Partial Friend Class ParserContext
        Inherits [Object]
        Implements IDisposable
        Private _state As Integer
        Private _e As IEnumerator(Of Token)
        Private _t As Token
        Public Sub New(ByVal tokenizer As IEnumerable(Of Token))
            MyBase.New
            Me._e = tokenizer.GetEnumerator
            Me._state = -1
            Me._t.SymbolId = -1
        End Sub
        Public Sub EnsureStarted()
            If (-1 = Me._state) Then
                Me.Advance
            End If
        End Sub
        Public ReadOnly Property SymbolId() As Integer
            Get
                Return Me._t.SymbolId
            End Get
        End Property
        Public ReadOnly Property Value() As String
            Get
                Return Me._t.Value
            End Get
        End Property
        Public ReadOnly Property Line() As Integer
            Get
                Return Me._t.Line
            End Get
        End Property
        Public ReadOnly Property Column() As Integer
            Get
                Return Me._t.Column
            End Get
        End Property
        Public ReadOnly Property Position() As Long
            Get
                Return Me._t.Position
            End Get
        End Property
        Public ReadOnly Property IsEnded() As Boolean
            Get
                Return (-2 = Me._state)
            End Get
        End Property
        Public Function Advance() As Boolean
            If (false = Me._e.MoveNext) Then
                Me._t.SymbolId = -2
                Me._state = -2
            Else
                Me._state = 0
                Me._t = Me._e.Current
                Return true
            End If
            Return false
        End Function
        Public Overloads Sub [Error](ByVal message As String, ByVal arg1 As Object, ByVal arg2 As Object, ByVal arg3 As Object)
            Throw New SyntaxException(String.Format(message, arg1, arg2, arg3), Me.Line, Me.Column, Me.Position)
        End Sub
        Public Overloads Sub [Error](ByVal message As String, ByVal arg1 As Object, ByVal arg2 As Object)
            Throw New SyntaxException(String.Format(message, arg1, arg2), Me.Line, Me.Column, Me.Position)
        End Sub
        Public Overloads Sub [Error](ByVal message As String, ByVal arg As Object)
            Throw New SyntaxException(String.Format(message, arg), Me.Line, Me.Column, Me.Position)
        End Sub
        Public Overloads Sub [Error](ByVal message As String)
            Throw New SyntaxException(message, Me.Line, Me.Column, Me.Position)
        End Sub
        Public Sub Dispose() Implements IDisposable.Dispose
            Me._e.Dispose
            Me._state = -3
        End Sub
    End Class
End Namespace
