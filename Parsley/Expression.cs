//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;


/// <summary>Parses the following grammar:
/// Term= Factor { ( "+" | "-" ) Factor };
/// Factor= Unary { ( "*" | "/" ) Unary };
/// Unary= ( "+" | "-" ) Unary | Leaf;
/// Leaf= integer | identifier | "(" Term ")";
/// add= "+";
/// mul= "*";
/// integer= '[0-9]+';
/// identifier= '[A-Z_a-z][0-9A-Z_a-z]*';
/// (whitespace)= '[ \t\r\n]+';
/// (lineComment)= "//";
/// (blockComment)= "/*";
/// </summary>
/// <remarks>The rules for the factored grammar are as follows:
/// Unary -> add Unary
/// Unary -> Implicit Unary
/// Unary -> Leaf
/// Leaf -> integer
/// Leaf -> identifier
/// Leaf -> Implicit3 Term Implicit4
/// TermList -> add Factor TermListRightAssoc TermListRightAssoc2
/// TermList -> Implicit Factor TermListRightAssoc TermListRightAssoc2
/// FactorList -> mul Unary FactorListRightAssoc FactorListRightAssoc2
/// FactorList -> Implicit2 Unary FactorListRightAssoc FactorListRightAssoc2
/// TermListRightAssoc -> add Factor TermListRightAssoc
/// TermListRightAssoc ->
/// FactorListRightAssoc -> mul Unary FactorListRightAssoc
/// FactorListRightAssoc ->
/// Term -> Factor TermPart
/// TermPart -> TermList
/// TermPart ->
/// Factor -> Unary FactorPart
/// FactorPart -> FactorList
/// FactorPart ->
/// TermListRightAssoc2 -> Implicit Factor TermListRightAssoc2
/// TermListRightAssoc2 ->
/// FactorListRightAssoc2 -> Implicit2 Unary FactorListRightAssoc2
/// FactorListRightAssoc2 ->
/// </remarks>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
internal partial class Expression {
    internal const int ErrorSymbol = -1;
    internal const int EosSymbol = -2;
    public const int Unary = 0;
    public const int Leaf = 1;
    public const int TermList = 2;
    public const int FactorList = 3;
    public const int TermListRightAssoc = 4;
    public const int FactorListRightAssoc = 5;
    public const int Term = 6;
    public const int TermPart = 7;
    public const int Factor = 8;
    public const int FactorPart = 9;
    public const int TermListRightAssoc2 = 10;
    public const int FactorListRightAssoc2 = 11;
    public const int add = 12;
    public const int Implicit = 13;
    public const int integer = 14;
    public const int identifier = 15;
    public const int Implicit3 = 16;
    public const int Implicit4 = 17;
    public const int mul = 18;
    public const int Implicit2 = 19;
    public const int whitespace = 20;
    public const int lineComment = 21;
    public const int blockComment = 22;
    private static ParseNode _ParseUnary(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Unary -> add Unary
        if ((Expression.add == context.SymbolId)) {
            ParseNode[] children = new ParseNode[2];
            children[0] = new ParseNode(Expression.add, "add", context.Value, line, column, position);
            context.Advance();
            children[1] = Expression._ParseUnary(context);
            return new ParseNode(Expression.Unary, "Unary", children, line, column, position);
        }
        // Unary -> Implicit Unary
        if ((Expression.Implicit == context.SymbolId)) {
            ParseNode[] children = new ParseNode[2];
            children[0] = new ParseNode(Expression.Implicit, "Implicit", context.Value, line, column, position);
            context.Advance();
            children[1] = Expression._ParseUnary(context);
            return new ParseNode(Expression.Unary, "Unary", children, line, column, position);
        }
        // Unary -> Leaf
        if ((((Expression.integer == context.SymbolId) 
                    || (Expression.identifier == context.SymbolId)) 
                    || (Expression.Implicit3 == context.SymbolId))) {
            ParseNode[] children = new ParseNode[1];
            children[0] = Expression._ParseLeaf(context);
            return new ParseNode(Expression.Unary, "Unary", children, line, column, position);
        }
        context.Error("Expecting add, Implicit, integer, identifier, or Implicit3");
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Unary= ( "+" | "-" ) Unary | Leaf
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Unary -> add Unary
    /// Unary -> Implicit Unary
    /// Unary -> Leaf
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseUnary(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return Expression._ParseUnary(context);
    }
    private static ParseNode _ParseLeaf(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Leaf -> integer
        if ((Expression.integer == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = new ParseNode(Expression.integer, "integer", context.Value, line, column, position);
            context.Advance();
            return new ParseNode(Expression.Leaf, "Leaf", children, line, column, position);
        }
        // Leaf -> identifier
        if ((Expression.identifier == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = new ParseNode(Expression.identifier, "identifier", context.Value, line, column, position);
            context.Advance();
            return new ParseNode(Expression.Leaf, "Leaf", children, line, column, position);
        }
        // Leaf -> Implicit3 Term Implicit4
        if ((Expression.Implicit3 == context.SymbolId)) {
            ParseNode[] children = new ParseNode[3];
            children[0] = new ParseNode(Expression.Implicit3, "Implicit3", context.Value, line, column, position);
            context.Advance();
            children[1] = Expression._ParseTerm(context);
            if ((Expression.Implicit4 == context.SymbolId)) {
                children[2] = new ParseNode(Expression.Implicit4, "Implicit4", context.Value, line, column, position);
                context.Advance();
            }
            return new ParseNode(Expression.Leaf, "Leaf", children, line, column, position);
        }
        context.Error("Expecting integer, identifier, or Implicit3");
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Leaf= integer | identifier | "(" Term ")"
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Leaf -> integer
    /// Leaf -> identifier
    /// Leaf -> Implicit3 Term Implicit4
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseLeaf(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return Expression._ParseLeaf(context);
    }
    private static ParseNode _ParseTermList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TermList -> add Factor TermListRightAssoc TermListRightAssoc2
        if ((Expression.add == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(new ParseNode(Expression.add, "add", context.Value, line, column, position));
            context.Advance();
            children.Add(Expression._ParseFactor(context));
            children.AddRange(Expression._ParseTermListRightAssoc(context).Children);
            children.AddRange(Expression._ParseTermListRightAssoc2(context).Children);
            return new ParseNode(Expression.TermList, "TermList", children.ToArray(), line, column, position);
        }
        // TermList -> Implicit Factor TermListRightAssoc TermListRightAssoc2
        if ((Expression.Implicit == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(new ParseNode(Expression.Implicit, "Implicit", context.Value, line, column, position));
            context.Advance();
            children.Add(Expression._ParseFactor(context));
            children.AddRange(Expression._ParseTermListRightAssoc(context).Children);
            children.AddRange(Expression._ParseTermListRightAssoc2(context).Children);
            return new ParseNode(Expression.TermList, "TermList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting add or Implicit");
        return null;
    }
    private static ParseNode _ParseFactorList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // FactorList -> mul Unary FactorListRightAssoc FactorListRightAssoc2
        if ((Expression.mul == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(new ParseNode(Expression.mul, "mul", context.Value, line, column, position));
            context.Advance();
            children.Add(Expression._ParseUnary(context));
            children.AddRange(Expression._ParseFactorListRightAssoc(context).Children);
            children.AddRange(Expression._ParseFactorListRightAssoc2(context).Children);
            return new ParseNode(Expression.FactorList, "FactorList", children.ToArray(), line, column, position);
        }
        // FactorList -> Implicit2 Unary FactorListRightAssoc FactorListRightAssoc2
        if ((Expression.Implicit2 == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(new ParseNode(Expression.Implicit2, "Implicit2", context.Value, line, column, position));
            context.Advance();
            children.Add(Expression._ParseUnary(context));
            children.AddRange(Expression._ParseFactorListRightAssoc(context).Children);
            children.AddRange(Expression._ParseFactorListRightAssoc2(context).Children);
            return new ParseNode(Expression.FactorList, "FactorList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting mul or Implicit2");
        return null;
    }
    private static ParseNode _ParseTermListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TermListRightAssoc -> add Factor TermListRightAssoc
        if ((Expression.add == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(new ParseNode(Expression.add, "add", context.Value, line, column, position));
            context.Advance();
            children.Add(Expression._ParseFactor(context));
            children.AddRange(Expression._ParseTermListRightAssoc(context).Children);
            return new ParseNode(Expression.TermListRightAssoc, "TermListRightAssoc", children.ToArray(), line, column, position);
        }
        // TermListRightAssoc ->
        if ((((Expression.Implicit == context.SymbolId) 
                    || (Expression.EosSymbol == context.SymbolId)) 
                    || (Expression.Implicit4 == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(Expression.TermListRightAssoc, "TermListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting add, Implicit, #EOS, or Implicit4");
        return null;
    }
    private static ParseNode _ParseFactorListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // FactorListRightAssoc -> mul Unary FactorListRightAssoc
        if ((Expression.mul == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(new ParseNode(Expression.mul, "mul", context.Value, line, column, position));
            context.Advance();
            children.Add(Expression._ParseUnary(context));
            children.AddRange(Expression._ParseFactorListRightAssoc(context).Children);
            return new ParseNode(Expression.FactorListRightAssoc, "FactorListRightAssoc", children.ToArray(), line, column, position);
        }
        // FactorListRightAssoc ->
        if ((((((Expression.Implicit2 == context.SymbolId) 
                    || (Expression.add == context.SymbolId)) 
                    || (Expression.Implicit == context.SymbolId)) 
                    || (Expression.EosSymbol == context.SymbolId)) 
                    || (Expression.Implicit4 == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(Expression.FactorListRightAssoc, "FactorListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting mul, Implicit2, add, Implicit, #EOS, or Implicit4");
        return null;
    }
    private static ParseNode _ParseTerm(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Term -> Factor TermPart
        if ((((((Expression.add == context.SymbolId) 
                    || (Expression.Implicit == context.SymbolId)) 
                    || (Expression.integer == context.SymbolId)) 
                    || (Expression.identifier == context.SymbolId)) 
                    || (Expression.Implicit3 == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(Expression._ParseFactor(context));
            children.AddRange(Expression._ParseTermPart(context).Children);
            return new ParseNode(Expression.Term, "Term", children.ToArray(), line, column, position);
        }
        context.Error("Expecting add, Implicit, integer, identifier, or Implicit3");
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Term= Factor { ( "+" | "-" ) Factor }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Term -> Factor TermPart
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseTerm(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return Expression._ParseTerm(context);
    }
    /// <summary>
    /// Parses a production of the form:
    /// Term= Factor { ( "+" | "-" ) Factor }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Term -> Factor TermPart
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode Parse(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return Expression._ParseTerm(context);
    }
    private static ParseNode _ParseTermPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TermPart -> TermList
        if (((Expression.add == context.SymbolId) 
                    || (Expression.Implicit == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(Expression._ParseTermList(context).Children);
            return new ParseNode(Expression.TermPart, "TermPart", children.ToArray(), line, column, position);
        }
        // TermPart ->
        if (((Expression.EosSymbol == context.SymbolId) 
                    || (Expression.Implicit4 == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(Expression.TermPart, "TermPart", children, line, column, position);
        }
        context.Error("Expecting add, Implicit, #EOS, or Implicit4");
        return null;
    }
    private static ParseNode _ParseFactor(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Factor -> Unary FactorPart
        if ((((((Expression.add == context.SymbolId) 
                    || (Expression.Implicit == context.SymbolId)) 
                    || (Expression.integer == context.SymbolId)) 
                    || (Expression.identifier == context.SymbolId)) 
                    || (Expression.Implicit3 == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(Expression._ParseUnary(context));
            children.AddRange(Expression._ParseFactorPart(context).Children);
            return new ParseNode(Expression.Factor, "Factor", children.ToArray(), line, column, position);
        }
        context.Error("Expecting add, Implicit, integer, identifier, or Implicit3");
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Factor= Unary { ( "*" | "/" ) Unary }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Factor -> Unary FactorPart
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseFactor(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return Expression._ParseFactor(context);
    }
    private static ParseNode _ParseFactorPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // FactorPart -> FactorList
        if (((Expression.mul == context.SymbolId) 
                    || (Expression.Implicit2 == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(Expression._ParseFactorList(context).Children);
            return new ParseNode(Expression.FactorPart, "FactorPart", children.ToArray(), line, column, position);
        }
        // FactorPart ->
        if (((((Expression.add == context.SymbolId) 
                    || (Expression.Implicit == context.SymbolId)) 
                    || (Expression.EosSymbol == context.SymbolId)) 
                    || (Expression.Implicit4 == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(Expression.FactorPart, "FactorPart", children, line, column, position);
        }
        context.Error("Expecting mul, Implicit2, add, Implicit, #EOS, or Implicit4");
        return null;
    }
    private static ParseNode _ParseTermListRightAssoc2(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TermListRightAssoc2 -> Implicit Factor TermListRightAssoc2
        if ((Expression.Implicit == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(new ParseNode(Expression.Implicit, "Implicit", context.Value, line, column, position));
            context.Advance();
            children.Add(Expression._ParseFactor(context));
            children.AddRange(Expression._ParseTermListRightAssoc2(context).Children);
            return new ParseNode(Expression.TermListRightAssoc2, "TermListRightAssoc2", children.ToArray(), line, column, position);
        }
        // TermListRightAssoc2 ->
        if (((Expression.EosSymbol == context.SymbolId) 
                    || (Expression.Implicit4 == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(Expression.TermListRightAssoc2, "TermListRightAssoc2", children, line, column, position);
        }
        context.Error("Expecting Implicit, #EOS, or Implicit4");
        return null;
    }
    private static ParseNode _ParseFactorListRightAssoc2(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // FactorListRightAssoc2 -> Implicit2 Unary FactorListRightAssoc2
        if ((Expression.Implicit2 == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(new ParseNode(Expression.Implicit2, "Implicit2", context.Value, line, column, position));
            context.Advance();
            children.Add(Expression._ParseUnary(context));
            children.AddRange(Expression._ParseFactorListRightAssoc2(context).Children);
            return new ParseNode(Expression.FactorListRightAssoc2, "FactorListRightAssoc2", children.ToArray(), line, column, position);
        }
        // FactorListRightAssoc2 ->
        if (((((Expression.add == context.SymbolId) 
                    || (Expression.Implicit == context.SymbolId)) 
                    || (Expression.EosSymbol == context.SymbolId)) 
                    || (Expression.Implicit4 == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(Expression.FactorListRightAssoc2, "FactorListRightAssoc2", children, line, column, position);
        }
        context.Error("Expecting Implicit2, add, Implicit, #EOS, or Implicit4");
        return null;
    }
    /// <summary>
    /// Evaluates a derivation of the form:
    /// Term= Factor { ( "+" | "-" ) Factor }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Term -> Factor TermPart
    /// </remarks>
    /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
    /// <returns>The result of the evaluation</returns>
    public static object Evaluate(ParseNode node) {
        return Expression.EvaluateTerm(node);
    }
    /// <summary>
    /// Evaluates a derivation of the form:
    /// Term= Factor { ( "+" | "-" ) Factor }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Term -> Factor TermPart
    /// </remarks>
    /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
    /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
    /// <returns>The result of the evaluation</returns>
    public static object Evaluate(ParseNode node, object state) {
        return Expression.EvaluateTerm(node, state);
    }
    /// <summary>
    /// Evaluates a derivation of the form:
    /// Term= Factor { ( "+" | "-" ) Factor }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Term -> Factor TermPart
    /// </remarks>
    /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
    /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
    /// <returns>The result of the evaluation</returns>
    public static object EvaluateTerm(ParseNode node, object state) {
        if ((Expression.Term == node.SymbolId)) {
            int result = ((int)(Expression.EvaluateFactor(node.Children[0])));
            int i = 2;
            for (
            ; (i < node.Children.Length); 
            ) {
                if ((node.Children[(i - 1)].SymbolId == Expression.add)) {
                    result = (result + ((int)(Expression.EvaluateFactor(node.Children[i]))));
                }
                else {
                    result = (result - ((int)(Expression.EvaluateFactor(node.Children[i]))));
                }
                i = (i + 2);
            }
            return result;
        }
        throw new SyntaxException("Expecting Term", node.Line, node.Column, node.Position);
    }
    /// <summary>
    /// Evaluates a derivation of the form:
    /// Term= Factor { ( "+" | "-" ) Factor }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Term -> Factor TermPart
    /// </remarks>
    /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
    /// <returns>The result of the evaluation</returns>
    public static object EvaluateTerm(ParseNode node) {
        return Expression.EvaluateTerm(node, null);
    }
    /// <summary>
    /// Evaluates a derivation of the form:
    /// Factor= Unary { ( "*" | "/" ) Unary }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Factor -> Unary FactorPart
    /// </remarks>
    /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
    /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
    /// <returns>The result of the evaluation</returns>
    public static object EvaluateFactor(ParseNode node, object state) {
        if ((Expression.Factor == node.SymbolId)) {
            int result = ((int)(Expression.EvaluateUnary(node.Children[0])));
            int i = 2;
            for (
            ; (i < node.Children.Length); 
            ) {
                if ((node.Children[i].SymbolId == Expression.Unary)) {
                    if ((node.Children[(i - 1)].SymbolId == Expression.mul)) {
                        result = (result * ((int)(Expression.EvaluateUnary(node.Children[i]))));
                    }
                    else {
                        result = (result / ((int)(Expression.EvaluateUnary(node.Children[i]))));
                    }
                }
                else {
                    if ((node.Children[(i - 1)].SymbolId == Expression.mul)) {
                        result = (result * ((int)(Expression.EvaluateFactor(node.Children[i]))));
                    }
                    else {
                        result = (result / ((int)(Expression.EvaluateFactor(node.Children[i]))));
                    }
                }
                i = (i + 2);
            }
            return result;
        }
        throw new SyntaxException("Expecting Factor", node.Line, node.Column, node.Position);
    }
    /// <summary>
    /// Evaluates a derivation of the form:
    /// Factor= Unary { ( "*" | "/" ) Unary }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Factor -> Unary FactorPart
    /// </remarks>
    /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
    /// <returns>The result of the evaluation</returns>
    public static object EvaluateFactor(ParseNode node) {
        return Expression.EvaluateFactor(node, null);
    }
    /// <summary>
    /// Evaluates a derivation of the form:
    /// Unary= ( "+" | "-" ) Unary | Leaf
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Unary -> add Unary
    /// Unary -> Implicit Unary
    /// Unary -> Leaf
    /// </remarks>
    /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
    /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
    /// <returns>The result of the evaluation</returns>
    public static object EvaluateUnary(ParseNode node, object state) {
        if ((Expression.Unary == node.SymbolId)) {
            if ((node.Children.Length == 1)) {
                return Expression.EvaluateLeaf(node.Children[0]);
            }
            if ((node.Children[0].SymbolId == Expression.add)) {
                return Expression.EvaluateUnary(node.Children[1]);
            }
            else {
                return (0 - ((int)(Expression.EvaluateUnary(node.Children[1]))));
            }
        }
        throw new SyntaxException("Expecting Unary", node.Line, node.Column, node.Position);
    }
    /// <summary>
    /// Evaluates a derivation of the form:
    /// Unary= ( "+" | "-" ) Unary | Leaf
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Unary -> add Unary
    /// Unary -> Implicit Unary
    /// Unary -> Leaf
    /// </remarks>
    /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
    /// <returns>The result of the evaluation</returns>
    public static object EvaluateUnary(ParseNode node) {
        return Expression.EvaluateUnary(node, null);
    }
    /// <summary>
    /// Evaluates a derivation of the form:
    /// Leaf= integer | identifier | "(" Term ")"
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Leaf -> integer
    /// Leaf -> identifier
    /// Leaf -> Implicit3 Term Implicit4
    /// </remarks>
    /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
    /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
    /// <returns>The result of the evaluation</returns>
    public static object EvaluateLeaf(ParseNode node, object state) {
        if ((Expression.Leaf == node.SymbolId)) {
            if ((node.Children.Length == 1)) {
                if ((node.Children[1].SymbolId == Expression.integer)) {
                    return int.Parse(node.Children[0].Value);
                }
                else {
                    throw new NotImplementedException("Variables are not implemented.");
                }
            }
            else {
                return Expression.EvaluateTerm(node.Children[1]);
            }
        }
        throw new SyntaxException("Expecting Leaf", node.Line, node.Column, node.Position);
    }
    /// <summary>
    /// Evaluates a derivation of the form:
    /// Leaf= integer | identifier | "(" Term ")"
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Leaf -> integer
    /// Leaf -> identifier
    /// Leaf -> Implicit3 Term Implicit4
    /// </remarks>
    /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
    /// <returns>The result of the evaluation</returns>
    public static object EvaluateLeaf(ParseNode node) {
        return Expression.EvaluateLeaf(node, null);
    }
}
