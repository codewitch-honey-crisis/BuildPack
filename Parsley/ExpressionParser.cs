//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ParsleyDemo {
    using System;
    using System.Collections.Generic;
    
    /// <summary>Parses the following grammar:
    /// Term= Factor { ( "+" | "-" ) Factor };
    /// Factor= Leaf { ( "*" | "/" ) Leaf };
    /// Leaf= integer | "(" Term ")";
    /// add= "+";
    /// sub= "-";
    /// mul= "*";
    /// lparen= "(";
    /// rparen= ")";
    /// integer= '[0-9]+';
    /// (whitespace)= '\s+';
    /// </summary>
    /// <remarks>The rules for the factored grammar are as follows:
    /// Leaf -> integer
    /// Leaf -> lparen Term rparen
    /// ImplicitList -> add Factor ImplicitListRightAssoc ImplicitListRightAssoc2
    /// ImplicitList -> sub Factor ImplicitListRightAssoc ImplicitListRightAssoc2
    /// ImplicitList2 -> mul Leaf ImplicitList2RightAssoc ImplicitList2RightAssoc2
    /// ImplicitList2 -> Implicit Leaf ImplicitList2RightAssoc ImplicitList2RightAssoc2
    /// ImplicitListRightAssoc -> add Factor ImplicitListRightAssoc
    /// ImplicitListRightAssoc ->
    /// ImplicitList2RightAssoc -> mul Leaf ImplicitList2RightAssoc
    /// ImplicitList2RightAssoc ->
    /// Term -> Factor TermPart
    /// TermPart -> ImplicitList
    /// TermPart ->
    /// Factor -> Leaf FactorPart
    /// FactorPart -> ImplicitList2
    /// FactorPart ->
    /// ImplicitListRightAssoc2 -> sub Factor ImplicitListRightAssoc2
    /// ImplicitListRightAssoc2 ->
    /// ImplicitList2RightAssoc2 -> Implicit Leaf ImplicitList2RightAssoc2
    /// ImplicitList2RightAssoc2 ->
    /// </remarks>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
    internal partial class ExpressionParser {
        internal const int ErrorSymbol = -1;
        internal const int EosSymbol = -2;
        public const int Leaf = 0;
        public const int ImplicitList = 1;
        public const int ImplicitList2 = 2;
        public const int ImplicitListRightAssoc = 3;
        public const int ImplicitList2RightAssoc = 4;
        public const int Term = 5;
        public const int TermPart = 6;
        public const int Factor = 7;
        public const int FactorPart = 8;
        public const int ImplicitListRightAssoc2 = 9;
        public const int ImplicitList2RightAssoc2 = 10;
        public const int integer = 11;
        public const int lparen = 12;
        public const int rparen = 13;
        public const int add = 14;
        public const int sub = 15;
        public const int mul = 16;
        public const int Implicit = 17;
        public const int whitespace = 18;
        private static ParseNode _ParseLeaf(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            if ((ExpressionParser.integer == context.SymbolId)) {
                // Leaf -> integer
                ParseNode[] children = new ParseNode[1];
                children[0] = new ParseNode(ExpressionParser.integer, "integer", context.Value, line, column, position);
                context.Advance();
                return new ParseNode(ExpressionParser.Leaf, "Leaf", children, line, column, position);
            }
            if ((ExpressionParser.lparen == context.SymbolId)) {
                // Leaf -> lparen Term rparen
                ParseNode[] children = new ParseNode[3];
                children[0] = new ParseNode(ExpressionParser.lparen, "lparen", context.Value, line, column, position);
                context.Advance();
                children[1] = ExpressionParser._ParseTerm(context);
                children[2] = new ParseNode(ExpressionParser.rparen, "rparen", context.Value, line, column, position);
                if ((ExpressionParser.rparen == context.SymbolId)) {
                    context.Advance();
                    return new ParseNode(ExpressionParser.Leaf, "Leaf", children, line, column, position);
                }
                context.Error("Expecting rparen");
            }
            context.Error("Expecting integer or lparen");
            return null;
        }
        private static ParseNode _ParseImplicitList(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            if ((ExpressionParser.add == context.SymbolId)) {
                // ImplicitList -> add Factor ImplicitListRightAssoc ImplicitListRightAssoc2
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(ExpressionParser.add, "add", context.Value, line, column, position));
                context.Advance();
                children.Add(ExpressionParser._ParseFactor(context));
                children.AddRange(ExpressionParser._ParseImplicitListRightAssoc(context).Children);
                children.AddRange(ExpressionParser._ParseImplicitListRightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.ImplicitList, "ImplicitList", children.ToArray(), line, column, position);
            }
            if ((ExpressionParser.sub == context.SymbolId)) {
                // ImplicitList -> sub Factor ImplicitListRightAssoc ImplicitListRightAssoc2
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(ExpressionParser.sub, "sub", context.Value, line, column, position));
                context.Advance();
                children.Add(ExpressionParser._ParseFactor(context));
                children.AddRange(ExpressionParser._ParseImplicitListRightAssoc(context).Children);
                children.AddRange(ExpressionParser._ParseImplicitListRightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.ImplicitList, "ImplicitList", children.ToArray(), line, column, position);
            }
            context.Error("Expecting add or sub");
            return null;
        }
        private static ParseNode _ParseImplicitList2(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            if ((ExpressionParser.mul == context.SymbolId)) {
                // ImplicitList2 -> mul Leaf ImplicitList2RightAssoc ImplicitList2RightAssoc2
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(ExpressionParser.mul, "mul", context.Value, line, column, position));
                context.Advance();
                children.Add(ExpressionParser._ParseLeaf(context));
                children.AddRange(ExpressionParser._ParseImplicitList2RightAssoc(context).Children);
                children.AddRange(ExpressionParser._ParseImplicitList2RightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.ImplicitList2, "ImplicitList2", children.ToArray(), line, column, position);
            }
            if ((ExpressionParser.Implicit == context.SymbolId)) {
                // ImplicitList2 -> Implicit Leaf ImplicitList2RightAssoc ImplicitList2RightAssoc2
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(ExpressionParser.Implicit, "Implicit", context.Value, line, column, position));
                context.Advance();
                children.Add(ExpressionParser._ParseLeaf(context));
                children.AddRange(ExpressionParser._ParseImplicitList2RightAssoc(context).Children);
                children.AddRange(ExpressionParser._ParseImplicitList2RightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.ImplicitList2, "ImplicitList2", children.ToArray(), line, column, position);
            }
            context.Error("Expecting mul or Implicit");
            return null;
        }
        private static ParseNode _ParseImplicitListRightAssoc(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            if ((ExpressionParser.add == context.SymbolId)) {
                // ImplicitListRightAssoc -> add Factor ImplicitListRightAssoc
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(ExpressionParser.add, "add", context.Value, line, column, position));
                context.Advance();
                children.Add(ExpressionParser._ParseFactor(context));
                children.AddRange(ExpressionParser._ParseImplicitListRightAssoc(context).Children);
                return new ParseNode(ExpressionParser.ImplicitListRightAssoc, "ImplicitListRightAssoc", children.ToArray(), line, column, position);
            }
            if ((((ExpressionParser.sub == context.SymbolId) 
                        || (ExpressionParser.EosSymbol == context.SymbolId)) 
                        || (ExpressionParser.rparen == context.SymbolId))) {
                // ImplicitListRightAssoc ->
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.ImplicitListRightAssoc, "ImplicitListRightAssoc", children, line, column, position);
            }
            context.Error("Expecting add, sub, #EOS, or rparen");
            return null;
        }
        private static ParseNode _ParseImplicitList2RightAssoc(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            if ((ExpressionParser.mul == context.SymbolId)) {
                // ImplicitList2RightAssoc -> mul Leaf ImplicitList2RightAssoc
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(ExpressionParser.mul, "mul", context.Value, line, column, position));
                context.Advance();
                children.Add(ExpressionParser._ParseLeaf(context));
                children.AddRange(ExpressionParser._ParseImplicitList2RightAssoc(context).Children);
                return new ParseNode(ExpressionParser.ImplicitList2RightAssoc, "ImplicitList2RightAssoc", children.ToArray(), line, column, position);
            }
            if ((((((ExpressionParser.Implicit == context.SymbolId) 
                        || (ExpressionParser.add == context.SymbolId)) 
                        || (ExpressionParser.sub == context.SymbolId)) 
                        || (ExpressionParser.EosSymbol == context.SymbolId)) 
                        || (ExpressionParser.rparen == context.SymbolId))) {
                // ImplicitList2RightAssoc ->
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.ImplicitList2RightAssoc, "ImplicitList2RightAssoc", children, line, column, position);
            }
            context.Error("Expecting mul, Implicit, add, sub, #EOS, or rparen");
            return null;
        }
        private static ParseNode _ParseTerm(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            if (((ExpressionParser.integer == context.SymbolId) 
                        || (ExpressionParser.lparen == context.SymbolId))) {
                // Term -> Factor TermPart
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(ExpressionParser._ParseFactor(context));
                children.AddRange(ExpressionParser._ParseTermPart(context).Children);
                return new ParseNode(ExpressionParser.Term, "Term", children.ToArray(), line, column, position);
            }
            context.Error("Expecting integer or lparen");
            return null;
        }
        private static ParseNode _ParseTermPart(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            if (((ExpressionParser.add == context.SymbolId) 
                        || (ExpressionParser.sub == context.SymbolId))) {
                // TermPart -> ImplicitList
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.AddRange(ExpressionParser._ParseImplicitList(context).Children);
                return new ParseNode(ExpressionParser.TermPart, "TermPart", children.ToArray(), line, column, position);
            }
            if (((ExpressionParser.EosSymbol == context.SymbolId) 
                        || (ExpressionParser.rparen == context.SymbolId))) {
                // TermPart ->
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.TermPart, "TermPart", children, line, column, position);
            }
            context.Error("Expecting add, sub, #EOS, or rparen");
            return null;
        }
        private static ParseNode _ParseFactor(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            if (((ExpressionParser.integer == context.SymbolId) 
                        || (ExpressionParser.lparen == context.SymbolId))) {
                // Factor -> Leaf FactorPart
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(ExpressionParser._ParseLeaf(context));
                children.AddRange(ExpressionParser._ParseFactorPart(context).Children);
                return new ParseNode(ExpressionParser.Factor, "Factor", children.ToArray(), line, column, position);
            }
            context.Error("Expecting integer or lparen");
            return null;
        }
        private static ParseNode _ParseFactorPart(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            if (((ExpressionParser.mul == context.SymbolId) 
                        || (ExpressionParser.Implicit == context.SymbolId))) {
                // FactorPart -> ImplicitList2
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.AddRange(ExpressionParser._ParseImplicitList2(context).Children);
                return new ParseNode(ExpressionParser.FactorPart, "FactorPart", children.ToArray(), line, column, position);
            }
            if (((((ExpressionParser.add == context.SymbolId) 
                        || (ExpressionParser.sub == context.SymbolId)) 
                        || (ExpressionParser.EosSymbol == context.SymbolId)) 
                        || (ExpressionParser.rparen == context.SymbolId))) {
                // FactorPart ->
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.FactorPart, "FactorPart", children, line, column, position);
            }
            context.Error("Expecting mul, Implicit, add, sub, #EOS, or rparen");
            return null;
        }
        private static ParseNode _ParseImplicitListRightAssoc2(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            if ((ExpressionParser.sub == context.SymbolId)) {
                // ImplicitListRightAssoc2 -> sub Factor ImplicitListRightAssoc2
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(ExpressionParser.sub, "sub", context.Value, line, column, position));
                context.Advance();
                children.Add(ExpressionParser._ParseFactor(context));
                children.AddRange(ExpressionParser._ParseImplicitListRightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.ImplicitListRightAssoc2, "ImplicitListRightAssoc2", children.ToArray(), line, column, position);
            }
            if (((ExpressionParser.EosSymbol == context.SymbolId) 
                        || (ExpressionParser.rparen == context.SymbolId))) {
                // ImplicitListRightAssoc2 ->
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.ImplicitListRightAssoc2, "ImplicitListRightAssoc2", children, line, column, position);
            }
            context.Error("Expecting sub, #EOS, or rparen");
            return null;
        }
        private static ParseNode _ParseImplicitList2RightAssoc2(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            if ((ExpressionParser.Implicit == context.SymbolId)) {
                // ImplicitList2RightAssoc2 -> Implicit Leaf ImplicitList2RightAssoc2
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(ExpressionParser.Implicit, "Implicit", context.Value, line, column, position));
                context.Advance();
                children.Add(ExpressionParser._ParseLeaf(context));
                children.AddRange(ExpressionParser._ParseImplicitList2RightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.ImplicitList2RightAssoc2, "ImplicitList2RightAssoc2", children.ToArray(), line, column, position);
            }
            if (((((ExpressionParser.add == context.SymbolId) 
                        || (ExpressionParser.sub == context.SymbolId)) 
                        || (ExpressionParser.EosSymbol == context.SymbolId)) 
                        || (ExpressionParser.rparen == context.SymbolId))) {
                // ImplicitList2RightAssoc2 ->
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.ImplicitList2RightAssoc2, "ImplicitList2RightAssoc2", children, line, column, position);
            }
            context.Error("Expecting Implicit, add, sub, #EOS, or rparen");
            return null;
        }
        /// <summary>
        /// Parses a production of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseTerm(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return ExpressionParser._ParseTerm(context);
        }
        /// <summary>
        /// Parses a production of the form:
        /// Factor= Leaf { ( "*" | "/" ) Leaf }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Factor -> Leaf FactorPart
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseFactor(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return ExpressionParser._ParseFactor(context);
        }
        /// <summary>
        /// Parses a production of the form:
        /// Leaf= integer | "(" Term ")"
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Leaf -> integer
        /// Leaf -> lparen Term rparen
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseLeaf(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return ExpressionParser._ParseLeaf(context);
        }
        /// <summary>
        /// Parses a derivation of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode Parse(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return ExpressionParser._ParseTerm(context);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <returns>The result of the evaluation</returns>
        public static int Evaluate(ParseNode node) {
            return ExpressionParser.EvaluateTerm(node);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        /// <returns>The result of the evaluation</returns>
        public static int Evaluate(ParseNode node, object state) {
            return ExpressionParser.EvaluateTerm(node, state);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateTerm(ParseNode node, object state) {
            if ((ExpressionParser.Term == node.SymbolId)) {
                int result = ExpressionParser.EvaluateFactor(node.Children[0], state);
                int i = 2;
                for (
                ; (i < node.Children.Length); 
                ) {
                    if ((node.Children[(i - 1)].SymbolId == ParsleyDemo.ExpressionParser.add)) {
                        result = (result + ParsleyDemo.ExpressionParser.EvaluateFactor(node.Children[i], state));
                    }
                    else {
                        result = (result - ParsleyDemo.ExpressionParser.EvaluateFactor(node.Children[i], state));
                    }
                    i = (i + 2);
                }
                return ((int)(ExpressionParser._ChangeType(result, typeof(int))));
            }
            throw new SyntaxException("Expecting Term", node.Line, node.Column, node.Position);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateTerm(ParseNode node) {
            return ExpressionParser.EvaluateTerm(node, null);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Factor= Leaf { ( "*" | "/" ) Leaf }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Factor -> Leaf FactorPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateFactor(ParseNode node, object state) {
            if ((ExpressionParser.Factor == node.SymbolId)) {
                int result = ExpressionParser.EvaluateLeaf(node.Children[0], state);
                int i = 2;
                for (
                ; (i < node.Children.Length); 
                ) {
                    if ((node.Children[i].SymbolId == ParsleyDemo.ExpressionParser.Leaf)) {
                        if ((node.Children[(i - 1)].SymbolId == ParsleyDemo.ExpressionParser.mul)) {
                            result = (result * ParsleyDemo.ExpressionParser.EvaluateLeaf(node.Children[i], state));
                        }
                        else {
                            result = (result / ParsleyDemo.ExpressionParser.EvaluateLeaf(node.Children[i], state));
                        }
                    }
                    else {
                        if ((node.Children[(i - 1)].SymbolId == ParsleyDemo.ExpressionParser.mul)) {
                            result = (result * ParsleyDemo.ExpressionParser.EvaluateFactor(node.Children[i], state));
                        }
                        else {
                            result = (result / ParsleyDemo.ExpressionParser.EvaluateFactor(node.Children[(i - 1)], state));
                        }
                    }
                    i = (i + 2);
                }
                return ((int)(ExpressionParser._ChangeType(result, typeof(int))));
            }
            throw new SyntaxException("Expecting Factor", node.Line, node.Column, node.Position);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Factor= Leaf { ( "*" | "/" ) Leaf }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Factor -> Leaf FactorPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateFactor(ParseNode node) {
            return ExpressionParser.EvaluateFactor(node, null);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Leaf= integer | "(" Term ")"
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Leaf -> integer
        /// Leaf -> lparen Term rparen
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateLeaf(ParseNode node, object state) {
            if ((ExpressionParser.Leaf == node.SymbolId)) {
                if ((node.Children.Length == 1)) {
                    return ((int)(ExpressionParser._ChangeType(node.Children[0].Value, typeof(int))));
                }
                else {
                    return ((int)(ExpressionParser._ChangeType(ExpressionParser.EvaluateTerm(node.Children[1], state), typeof(int))));
                }
            }
            throw new SyntaxException("Expecting Leaf", node.Line, node.Column, node.Position);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Leaf= integer | "(" Term ")"
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Leaf -> integer
        /// Leaf -> lparen Term rparen
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateLeaf(ParseNode node) {
            return ExpressionParser.EvaluateLeaf(node, null);
        }
        private static object _ChangeType(object obj, System.Type type) {
            System.ComponentModel.TypeConverter typeConverter = System.ComponentModel.TypeDescriptor.GetConverter(obj);
            if (((null == typeConverter) 
                        || (false == typeConverter.CanConvertTo(type)))) {
                return System.Convert.ChangeType(obj, type);
            }
            return typeConverter.ConvertTo(obj, type);
        }
    }
    /// <summary>
    /// 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
    internal class SyntaxException : Exception {
        private int _line;
        private int _column;
        private long _position;
        /// <summary>
        /// Creates a syntax exception with the specified arguments
        /// </summary>
        /// <param name="message">The error message</param>
        /// <param name="line">The line where the error occurred</param>
        /// <param name="column">The column where the error occured</param>
        /// <param name="position">The position where the error occured</param>
        public SyntaxException(string message, int line, int column, long position) : 
                base(SyntaxException._GetMessage(message, line, column, position)) {
            this._line = line;
            this._column = column;
            this._position = position;
        }
        /// <summary>
        /// The line where the error occurred
        /// </summary>
        public int Line {
            get {
                return this._line;
            }
        }
        /// <summary>
        /// The column where the error occurred
        /// </summary>
        public int Column {
            get {
                return this._column;
            }
        }
        /// <summary>
        /// The position where the error occurred
        /// </summary>
        public long Position {
            get {
                return this._position;
            }
        }
        static string _GetMessage(string message, int line, int column, long position) {
            return string.Format("{0} at line {1}, column {2}, position {3}", message, line, column, position);
        }
    }
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
    internal partial class ParseNode {
        private int _symbolId;
        private string _symbol;
        private string _value;
        private int _line;
        private int _column;
        private long _position;
        private ParseNode[] _children;
        public ParseNode(int symbolId, string symbol, ParseNode[] children, int line, int column, long position) {
            this._symbolId = symbolId;
            this._symbol = symbol;
            this._value = null;
            this._children = children;
            this._line = line;
            this._column = column;
            this._position = position;
        }
        public ParseNode(int symbolId, string symbol, string value, int line, int column, long position) {
            this._symbolId = symbolId;
            this._symbol = symbol;
            this._value = value;
            this._children = null;
            this._line = line;
            this._column = column;
            this._position = position;
        }
        public bool IsNonTerminal {
            get {
                return (null != this._children);
            }
        }
        public ParseNode[] Children {
            get {
                return this._children;
            }
        }
        public int SymbolId {
            get {
                return this._symbolId;
            }
        }
        public string Symbol {
            get {
                return this._symbol;
            }
        }
        public string Value {
            get {
                return this._value;
            }
        }
        public int Line {
            get {
                return this._line;
            }
        }
        public int Column {
            get {
                return this._column;
            }
        }
        public long Position {
            get {
                return this._position;
            }
        }
    }
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
    internal partial class ParserContext : Object, IDisposable {
        private int _state;
        private IEnumerator<Token> _e;
        private Token _t;
        public ParserContext(IEnumerable<Token> tokenizer) {
            this._e = tokenizer.GetEnumerator();
            this._state = -1;
            this._t.SymbolId = -1;
        }
        public void EnsureStarted() {
            if ((-1 == this._state)) {
                this.Advance();
            }
        }
        public int SymbolId {
            get {
                return this._t.SymbolId;
            }
        }
        public string Value {
            get {
                return this._t.Value;
            }
        }
        public int Line {
            get {
                return this._t.Line;
            }
        }
        public int Column {
            get {
                return this._t.Column;
            }
        }
        public long Position {
            get {
                return this._t.Position;
            }
        }
        public bool IsEnded {
            get {
                return (-2 == this._state);
            }
        }
        public bool Advance() {
            if ((false == this._e.MoveNext())) {
                this._t.SymbolId = -2;
                this._state = -2;
            }
            else {
                this._state = 0;
                this._t = this._e.Current;
                return true;
            }
            return false;
        }
        public void Error(string message, object arg1, object arg2, object arg3) {
            throw new SyntaxException(string.Format(message, arg1, arg2, arg3), this.Line, this.Column, this.Position);
        }
        public void Error(string message, object arg1, object arg2) {
            throw new SyntaxException(string.Format(message, arg1, arg2), this.Line, this.Column, this.Position);
        }
        public void Error(string message, object arg) {
            throw new SyntaxException(string.Format(message, arg), this.Line, this.Column, this.Position);
        }
        public void Error(string message) {
            throw new SyntaxException(message, this.Line, this.Column, this.Position);
        }
        public void Dispose() {
            this._e.Dispose();
            this._state = -3;
        }
    }
}
