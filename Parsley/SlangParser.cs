//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;


/// <summary>Parses the following grammar:
/// Expression= Term;
/// Term= Factor { ( "+" | "-" ) Factor };
/// Factor= MemberRef { ( "*" | "/" | "%" ) MemberRef };
/// MemberRef= Unary | Unary { MemberAnyRef }+;
/// MemberFieldRef= "." Identifier;
/// MemberInvokeRef= "(" [ MethodArg { "," MethodArg } ] ")";
/// MemberIndexerRef= "[" Expression { "," Expression } "]";
/// {MemberAnyRef}= MemberFieldRef | MemberInvokeRef | MemberIndexerRef;
/// MethodArg= [ outKeyword | refKeyword ] Expression;
/// TypeRef= Type;
/// TypeBase= identifier { "." identifier };
/// Type= TypeElement { TypeArraySpec };
/// TypeCastPart= Type ")";
/// TypeElement= TypeBase [ TypeGenericPart ];
/// TypeGenericPart= "<" [ Type { "," Type } ] ">";
/// TypeArraySpec= "[" { ArraySpecRank } "]";
/// TypeArraySpecRank= comma;
/// Cast;
/// ExpressionOrCast;
/// Unary= ( "+" | "-" ) Unary | ExpressionOrCast | Leaf;
/// Leaf= Identifier | verbatimStringLiteral | integerLiteral | floatLiteral | stringLiteral;
/// {Identifier}= verbatimIdentifier | identifier;
/// outKeyword= "out";
/// refKeyword= "ref";
/// verbatimIdentifier= '@(_|[[:IsLetter:]])(_|[[:IsLetterOrDigit:]])*';
/// verbatimStringLiteral= '@"([^"|""])*"';
/// identifier= '(_|[[:IsLetter:]])(_|[[:IsLetterOrDigit:]])*';
/// stringLiteral= '"([^\\"\'\a\b\f\n\r\t\v\0]|\\[^\r\n]|\\[0-7]{3}|\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}|\\U[0-9A-Fa-f]{8})*"';
/// (lineComment)= '\/\/[^\n]*';
/// (blockComment)= "/*";
/// characterLiteral= '[\u0027]([^\\"\'\a\b\f\n\r\t\v\0]|\\[^\r\n]|\\[0-7]{3}|\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}|\\U[0-9A-Fa-f]{8})[\u0027]';
/// (whitespace)= '[ \t\r\n\v\f]+';
/// lte= "<=";
/// lt= "<";
/// gte= ">=";
/// gt= ">";
/// eqEq= "==";
/// notEq= "!=";
/// eq= "=";
/// inc= "++";
/// addAssign= "+=";
/// add= "+";
/// dec= "--";
/// subAssign= "-=";
/// sub= "-";
/// mulAssign= "*=";
/// mul= "*";
/// divAssign= "/=";
/// div= "/";
/// modAssign= "%=";
/// mod= "%";
/// and= "&&";
/// bitwiseAndAssign= "&=";
/// bitwiseAnd= "&";
/// or= "||";
/// bitwiseOrAssign= "|=";
/// bitwiseOr= "|";
/// not= "!";
/// lbracket= "[";
/// rbracket= "]";
/// lparen= "(";
/// rparen= ")";
/// lbrace= "{";
/// rbrace= "}";
/// comma= ",";
/// colonColon= "::";
/// colon= ":";
/// semi= ";";
/// dot= ".";
/// integerLiteral= '(0x[0-9A-Fa-f]{1,16}|(0|[1-9][0-9]*))([Uu][Ll]?|[Ll][Uu]?)?';
/// floatLiteral= '((0|[1-9][0-9]*)(\.[0-9]+)?([Ee][\+\-]?[0-9]+)?[DdMmFf]?)|((\.[0-9]+)([Ee][\+\-]?[0-9]+)?[DdMmFf]?)';
/// directive= '#[ \t]*[a-z]+[ \t]*';
/// </summary>
/// <remarks>The rules for the factored grammar are as follows:
/// Expression -> Term
/// MemberFieldRef -> dot Identifier
/// MemberAnyRef -> MemberFieldRef
/// MemberAnyRef -> MemberInvokeRef
/// MemberAnyRef -> MemberIndexerRef
/// MethodArg -> outKeyword Expression
/// MethodArg -> refKeyword Expression
/// MethodArg -> Expression
/// TypeRef -> Type
/// TypeCastPart -> Type rparen
/// TypeArraySpecRank -> comma
/// ExpressionOrCast -> lparen
/// Unary -> add Unary
/// Unary -> sub Unary
/// Unary -> ExpressionOrCast
/// Unary -> Leaf
/// Leaf -> Identifier
/// Leaf -> verbatimStringLiteral
/// Leaf -> integerLiteral
/// Leaf -> floatLiteral
/// Leaf -> stringLiteral
/// Identifier -> verbatimIdentifier
/// Identifier -> identifier
/// TermList -> add Factor TermListRightAssoc TermListRightAssoc2
/// TermList -> sub Factor TermListRightAssoc TermListRightAssoc2
/// FactorList -> mul MemberRef FactorListRightAssoc FactorListRightAssoc2 FactorListRightAssoc3
/// FactorList -> div MemberRef FactorListRightAssoc FactorListRightAssoc2 FactorListRightAssoc3
/// FactorList -> mod MemberRef FactorListRightAssoc FactorListRightAssoc2 FactorListRightAssoc3
/// MemberAnyRefList -> MemberAnyRef MemberAnyRefListRightAssoc
/// MemberInvokeRefList -> comma MethodArg MemberInvokeRefListRightAssoc
/// MemberIndexerRefList -> comma Expression MemberIndexerRefListRightAssoc
/// TypeBaseList -> dot identifier TypeBaseListRightAssoc
/// TypeArraySpecList -> TypeArraySpec TypeArraySpecListRightAssoc
/// TypeGenericPartList -> comma Type TypeGenericPartListRightAssoc
/// ArraySpecRankList -> ArraySpecRank ArraySpecRankListRightAssoc
/// TermListRightAssoc -> add Factor TermListRightAssoc
/// TermListRightAssoc ->
/// FactorListRightAssoc -> mul MemberRef FactorListRightAssoc
/// FactorListRightAssoc ->
/// FactorListRightAssoc2 -> mod MemberRef FactorListRightAssoc2
/// FactorListRightAssoc2 ->
/// MemberAnyRefListRightAssoc -> MemberAnyRef MemberAnyRefListRightAssoc
/// MemberAnyRefListRightAssoc ->
/// MemberInvokeRefListRightAssoc -> comma MethodArg MemberInvokeRefListRightAssoc
/// MemberInvokeRefListRightAssoc ->
/// MemberIndexerRefListRightAssoc -> comma Expression MemberIndexerRefListRightAssoc
/// MemberIndexerRefListRightAssoc ->
/// TypeBaseListRightAssoc -> dot identifier TypeBaseListRightAssoc
/// TypeBaseListRightAssoc ->
/// TypeArraySpecListRightAssoc -> TypeArraySpec TypeArraySpecListRightAssoc
/// TypeArraySpecListRightAssoc ->
/// TypeGenericPartListRightAssoc -> comma Type TypeGenericPartListRightAssoc
/// TypeGenericPartListRightAssoc ->
/// ArraySpecRankListRightAssoc -> ArraySpecRank ArraySpecRankListRightAssoc
/// ArraySpecRankListRightAssoc ->
/// Term -> Factor TermPart
/// TermPart -> TermList
/// TermPart ->
/// Factor -> MemberRef FactorPart
/// FactorPart -> FactorList
/// FactorPart ->
/// MemberRef -> Unary MemberRefPart
/// MemberRefPart ->
/// MemberRefPart -> MemberAnyRefList
/// MemberInvokeRefPart -> MemberInvokeRefList rparen
/// MemberInvokeRefPart -> rparen
/// MemberIndexerRef -> lbracket Expression MemberIndexerRefPart
/// MemberIndexerRefPart -> MemberIndexerRefList rbracket
/// MemberIndexerRefPart -> rbracket
/// TypeBase -> identifier TypeBasePart
/// TypeBasePart -> TypeBaseList
/// TypeBasePart ->
/// Type -> TypeElement TypePart
/// TypePart -> TypeArraySpecList
/// TypePart ->
/// TypeElement -> TypeBase TypeElementPart
/// TypeElementPart -> TypeGenericPart
/// TypeElementPart ->
/// TypeGenericPartPart -> TypeGenericPartList gt
/// TypeGenericPartPart -> gt
/// TypeArraySpec -> lbracket TypeArraySpecPart
/// TypeArraySpecPart -> ArraySpecRankList rbracket
/// TypeArraySpecPart -> rbracket
/// TermListRightAssoc2 -> sub Factor TermListRightAssoc2
/// TermListRightAssoc2 ->
/// FactorListRightAssoc3 -> div MemberRef FactorListRightAssoc3
/// FactorListRightAssoc3 ->
/// MemberInvokeRef -> lparen MemberInvokeRefPart2
/// MemberInvokeRefPart2 -> rparen
/// MemberInvokeRefPart2 -> MethodArg MemberInvokeRefPart
/// TypeGenericPart -> lt TypeGenericPartPart2
/// TypeGenericPartPart2 -> gt
/// TypeGenericPartPart2 -> Type TypeGenericPartPart
/// </remarks>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
internal partial class SlangParser {
    internal const int ErrorSymbol = -1;
    internal const int EosSymbol = -2;
    public const int Expression = 0;
    public const int MemberFieldRef = 1;
    public const int MemberAnyRef = 2;
    public const int MethodArg = 3;
    public const int TypeRef = 4;
    public const int TypeCastPart = 5;
    public const int TypeArraySpecRank = 6;
    public const int ExpressionOrCast = 7;
    public const int Unary = 8;
    public const int Leaf = 9;
    public const int Identifier = 10;
    public const int TermList = 11;
    public const int FactorList = 12;
    public const int MemberAnyRefList = 13;
    public const int MemberInvokeRefList = 14;
    public const int MemberIndexerRefList = 15;
    public const int TypeBaseList = 16;
    public const int TypeArraySpecList = 17;
    public const int TypeGenericPartList = 18;
    public const int ArraySpecRankList = 19;
    public const int TermListRightAssoc = 20;
    public const int FactorListRightAssoc = 21;
    public const int FactorListRightAssoc2 = 22;
    public const int MemberAnyRefListRightAssoc = 23;
    public const int MemberInvokeRefListRightAssoc = 24;
    public const int MemberIndexerRefListRightAssoc = 25;
    public const int TypeBaseListRightAssoc = 26;
    public const int TypeArraySpecListRightAssoc = 27;
    public const int TypeGenericPartListRightAssoc = 28;
    public const int ArraySpecRankListRightAssoc = 29;
    public const int Term = 30;
    public const int TermPart = 31;
    public const int Factor = 32;
    public const int FactorPart = 33;
    public const int MemberRef = 34;
    public const int MemberRefPart = 35;
    public const int MemberInvokeRefPart = 36;
    public const int MemberIndexerRef = 37;
    public const int MemberIndexerRefPart = 38;
    public const int TypeBase = 39;
    public const int TypeBasePart = 40;
    public const int Type = 41;
    public const int TypePart = 42;
    public const int TypeElement = 43;
    public const int TypeElementPart = 44;
    public const int TypeGenericPartPart = 45;
    public const int TypeArraySpec = 46;
    public const int TypeArraySpecPart = 47;
    public const int TermListRightAssoc2 = 48;
    public const int FactorListRightAssoc3 = 49;
    public const int MemberInvokeRef = 50;
    public const int MemberInvokeRefPart2 = 51;
    public const int TypeGenericPart = 52;
    public const int TypeGenericPartPart2 = 53;
    public const int dot = 54;
    public const int outKeyword = 55;
    public const int refKeyword = 56;
    public const int rparen = 57;
    public const int comma = 58;
    public const int lparen = 59;
    public const int add = 60;
    public const int sub = 61;
    public const int verbatimStringLiteral = 62;
    public const int integerLiteral = 63;
    public const int floatLiteral = 64;
    public const int stringLiteral = 65;
    public const int verbatimIdentifier = 66;
    public const int identifier2 = 67;
    public const int mul = 68;
    public const int div = 69;
    public const int mod = 70;
    public const int ArraySpecRank = 71;
    public const int lbracket = 72;
    public const int rbracket = 73;
    public const int gt = 74;
    public const int lt = 75;
    public const int Cast = 76;
    public const int lineComment = 77;
    public const int blockComment = 78;
    public const int whitespace = 79;
    public const int directive = 80;
    static HashSet<string> Keywords = _BuildKeywords();
    static HashSet<string> _BuildKeywords() {
        var result = new HashSet<string>();
        string[] sa = @"abstract|as|ascending|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|descending|do|double|dynamic|else|enum|equals|explicit|extern|event|false|finally|fixed|float|for|foreach|get|global|goto|if|implicit|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|partial|private|protected|public|readonly|ref|return|sbyte|sealed|set|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|var|virtual|void|volatile|while|yield".Split(new char[] {
                    '|'});
        for (var i = 0; (i < sa.Length); i = (i + 1)) {
            result.Add(sa[i]);
        }
        return result;
    }
    static ParseNode _ParseCast(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        if (("(" != context.Value)) {
            context.Error("Expecting ( as start of expression or cast");
        }
        ParseNode lp = new ParseNode(SlangParser.lparen, "lparen", context.Value, context.Line, context.Column, context.Position);
        context.Advance();
        ParseNode type = ParseTypeCastPart(context);
        ParseNode expr = ParseExpression(context);
        return new ParseNode(SlangParser.Cast, "Cast", new ParseNode[] {
                    type,
                    expr}, line, column, position);
    }
    private static ParseNode ParseExpression(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Expression -> Term
        if ((((((((((SlangParser.add == context.SymbolId) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.lparen == context.SymbolId)) 
                    || (SlangParser.verbatimIdentifier == context.SymbolId)) 
                    || (SlangParser.identifier2 == context.SymbolId)) 
                    || (SlangParser.verbatimStringLiteral == context.SymbolId)) 
                    || (SlangParser.integerLiteral == context.SymbolId)) 
                    || (SlangParser.floatLiteral == context.SymbolId)) 
                    || (SlangParser.stringLiteral == context.SymbolId))) {
            ParseNode[] children = new ParseNode[1];
            children[0] = SlangParser.ParseTerm(context);
            return new ParseNode(SlangParser.Expression, "Expression", children, line, column, position);
        }
        context.Error("Expecting add, sub, lparen, verbatimIdentifier, identifier, verbatimStringLiteral" +
                ", integerLiteral, floatLiteral, or stringLiteral at line {0}, column {1}, positi" +
                "on {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Expression= Term
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Expression -> Term
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseExpression(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseExpression(context);
    }
    /// <summary>
    /// Parses a production of the form:
    /// Expression= Term
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Expression -> Term
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode Parse(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseExpression(context);
    }
    private static ParseNode ParseMemberFieldRef(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberFieldRef -> dot Identifier
        if ((SlangParser.dot == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.dot == context.SymbolId))) {
                context.Error("Expecting dot at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.dot, "dot", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.AddRange(SlangParser.ParseIdentifier(context).Children);
            return new ParseNode(SlangParser.MemberFieldRef, "MemberFieldRef", children.ToArray(), line, column, position);
        }
        context.Error("Expecting dot at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// MemberFieldRef= "." Identifier
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// MemberFieldRef -> dot Identifier
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseMemberFieldRef(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseMemberFieldRef(context);
    }
    private static ParseNode ParseMemberAnyRef(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberAnyRef -> MemberFieldRef
        if ((SlangParser.dot == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = SlangParser.ParseMemberFieldRef(context);
            return new ParseNode(SlangParser.MemberAnyRef, "MemberAnyRef", children, line, column, position);
        }
        // MemberAnyRef -> MemberInvokeRef
        if ((SlangParser.lparen == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = SlangParser.ParseMemberInvokeRef(context);
            return new ParseNode(SlangParser.MemberAnyRef, "MemberAnyRef", children, line, column, position);
        }
        // MemberAnyRef -> MemberIndexerRef
        if ((SlangParser.lbracket == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = SlangParser.ParseMemberIndexerRef(context);
            return new ParseNode(SlangParser.MemberAnyRef, "MemberAnyRef", children, line, column, position);
        }
        context.Error("Expecting dot, lparen, or lbracket at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseMethodArg(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MethodArg -> outKeyword Expression
        if ((SlangParser.outKeyword == context.SymbolId)) {
            ParseNode[] children = new ParseNode[2];
            if ((false 
                        == (SlangParser.outKeyword == context.SymbolId))) {
                context.Error("Expecting outKeyword at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.outKeyword, "outKeyword", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            children[1] = SlangParser.ParseExpression(context);
            return new ParseNode(SlangParser.MethodArg, "MethodArg", children, line, column, position);
        }
        // MethodArg -> refKeyword Expression
        if ((SlangParser.refKeyword == context.SymbolId)) {
            ParseNode[] children = new ParseNode[2];
            if ((false 
                        == (SlangParser.refKeyword == context.SymbolId))) {
                context.Error("Expecting refKeyword at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.refKeyword, "refKeyword", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            children[1] = SlangParser.ParseExpression(context);
            return new ParseNode(SlangParser.MethodArg, "MethodArg", children, line, column, position);
        }
        // MethodArg -> Expression
        if ((((((((((SlangParser.add == context.SymbolId) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.lparen == context.SymbolId)) 
                    || (SlangParser.verbatimIdentifier == context.SymbolId)) 
                    || (SlangParser.identifier2 == context.SymbolId)) 
                    || (SlangParser.verbatimStringLiteral == context.SymbolId)) 
                    || (SlangParser.integerLiteral == context.SymbolId)) 
                    || (SlangParser.floatLiteral == context.SymbolId)) 
                    || (SlangParser.stringLiteral == context.SymbolId))) {
            ParseNode[] children = new ParseNode[1];
            children[0] = SlangParser.ParseExpression(context);
            return new ParseNode(SlangParser.MethodArg, "MethodArg", children, line, column, position);
        }
        context.Error("Expecting outKeyword, refKeyword, add, sub, lparen, verbatimIdentifier, identifie" +
                "r, verbatimStringLiteral, integerLiteral, floatLiteral, or stringLiteral at line" +
                " {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// MethodArg= [ outKeyword | refKeyword ] Expression
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// MethodArg -> outKeyword Expression
    /// MethodArg -> refKeyword Expression
    /// MethodArg -> Expression
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseMethodArg(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseMethodArg(context);
    }
    private static ParseNode ParseTypeRef(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeRef -> Type
        if ((SlangParser.identifier2 == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = SlangParser.ParseType(context);
            return new ParseNode(SlangParser.TypeRef, "TypeRef", children, line, column, position);
        }
        context.Error("Expecting identifier at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// TypeRef= Type
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// TypeRef -> Type
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseTypeRef(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseTypeRef(context);
    }
    private static ParseNode ParseTypeCastPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeCastPart -> Type rparen
        if ((SlangParser.identifier2 == context.SymbolId)) {
            ParseNode[] children = new ParseNode[2];
            children[0] = SlangParser.ParseType(context);
            if ((false 
                        == (SlangParser.rparen == context.SymbolId))) {
                context.Error("Expecting rparen at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[1] = new ParseNode(SlangParser.rparen, "rparen", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.TypeCastPart, "TypeCastPart", children, line, column, position);
        }
        context.Error("Expecting identifier at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// TypeCastPart= Type ")"
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// TypeCastPart -> Type rparen
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseTypeCastPart(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseTypeCastPart(context);
    }
    private static ParseNode ParseTypeArraySpecRank(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeArraySpecRank -> comma
        if ((SlangParser.comma == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.comma == context.SymbolId))) {
                context.Error("Expecting comma at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.comma, "comma", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.TypeArraySpecRank, "TypeArraySpecRank", children, line, column, position);
        }
        context.Error("Expecting comma at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// TypeArraySpecRank= comma
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// TypeArraySpecRank -> comma
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseTypeArraySpecRank(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseTypeArraySpecRank(context);
    }
    private static ParseNode ParseExpressionOrCast(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // ExpressionOrCast -> lparen
        if ((SlangParser.lparen == context.SymbolId)) {
            // possibly a cast, or possibly a subexpression
            // we can't know for sure so this gets complicated
            // basically we need to backtrack.
            ParseNode expr;
            var pc2 = context.GetLookAhead(true);
            try {
                expr = _ParseCast(pc2);
            }
            catch (Exception ex) {
                try {
                    if ((false == context.Advance())) {
                        context.Error("Unterminated cast or subexpression");
                    }
                    expr = ParseExpression(context);
                    if ((")" != context.Value)) {
                        context.Error("Invalid cast or subexpression");
                    }
                    context.Advance();
                    return expr;
                }
                catch (Exception eex) {
                    throw eex;
                }
            }
            return _ParseCast(context);
        }
        context.Error("Expecting lparen at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// ExpressionOrCast
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// ExpressionOrCast -> lparen
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseExpressionOrCast(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseExpressionOrCast(context);
    }
    private static ParseNode ParseUnary(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Unary -> add Unary
        if ((SlangParser.add == context.SymbolId)) {
            ParseNode[] children = new ParseNode[2];
            if ((false 
                        == (SlangParser.add == context.SymbolId))) {
                context.Error("Expecting add at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.add, "add", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            children[1] = SlangParser.ParseUnary(context);
            return new ParseNode(SlangParser.Unary, "Unary", children, line, column, position);
        }
        // Unary -> sub Unary
        if ((SlangParser.sub == context.SymbolId)) {
            ParseNode[] children = new ParseNode[2];
            if ((false 
                        == (SlangParser.sub == context.SymbolId))) {
                context.Error("Expecting sub at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.sub, "sub", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            children[1] = SlangParser.ParseUnary(context);
            return new ParseNode(SlangParser.Unary, "Unary", children, line, column, position);
        }
        // Unary -> ExpressionOrCast
        if ((SlangParser.lparen == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = SlangParser.ParseExpressionOrCast(context);
            return new ParseNode(SlangParser.Unary, "Unary", children, line, column, position);
        }
        // Unary -> Leaf
        if (((((((SlangParser.verbatimIdentifier == context.SymbolId) 
                    || (SlangParser.identifier2 == context.SymbolId)) 
                    || (SlangParser.verbatimStringLiteral == context.SymbolId)) 
                    || (SlangParser.integerLiteral == context.SymbolId)) 
                    || (SlangParser.floatLiteral == context.SymbolId)) 
                    || (SlangParser.stringLiteral == context.SymbolId))) {
            ParseNode[] children = new ParseNode[1];
            children[0] = SlangParser.ParseLeaf(context);
            return new ParseNode(SlangParser.Unary, "Unary", children, line, column, position);
        }
        context.Error("Expecting add, sub, lparen, verbatimIdentifier, identifier, verbatimStringLiteral" +
                ", integerLiteral, floatLiteral, or stringLiteral at line {0}, column {1}, positi" +
                "on {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Unary= ( "+" | "-" ) Unary | ExpressionOrCast | Leaf
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Unary -> add Unary
    /// Unary -> sub Unary
    /// Unary -> ExpressionOrCast
    /// Unary -> Leaf
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseUnary(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseUnary(context);
    }
    private static ParseNode ParseLeaf(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Leaf -> Identifier
        if (((SlangParser.verbatimIdentifier == context.SymbolId) 
                    || (SlangParser.identifier2 == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseIdentifier(context).Children);
            return new ParseNode(SlangParser.Leaf, "Leaf", children.ToArray(), line, column, position);
        }
        // Leaf -> verbatimStringLiteral
        if ((SlangParser.verbatimStringLiteral == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.verbatimStringLiteral == context.SymbolId))) {
                context.Error("Expecting verbatimStringLiteral at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.verbatimStringLiteral, "verbatimStringLiteral", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.Leaf, "Leaf", children, line, column, position);
        }
        // Leaf -> integerLiteral
        if ((SlangParser.integerLiteral == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.integerLiteral == context.SymbolId))) {
                context.Error("Expecting integerLiteral at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.integerLiteral, "integerLiteral", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.Leaf, "Leaf", children, line, column, position);
        }
        // Leaf -> floatLiteral
        if ((SlangParser.floatLiteral == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.floatLiteral == context.SymbolId))) {
                context.Error("Expecting floatLiteral at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.floatLiteral, "floatLiteral", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.Leaf, "Leaf", children, line, column, position);
        }
        // Leaf -> stringLiteral
        if ((SlangParser.stringLiteral == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.stringLiteral == context.SymbolId))) {
                context.Error("Expecting stringLiteral at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.stringLiteral, "stringLiteral", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.Leaf, "Leaf", children, line, column, position);
        }
        context.Error("Expecting verbatimIdentifier, identifier, verbatimStringLiteral, integerLiteral, " +
                "floatLiteral, or stringLiteral at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Leaf= Identifier | verbatimStringLiteral | integerLiteral | floatLiteral | stringLiteral
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Leaf -> Identifier
    /// Leaf -> verbatimStringLiteral
    /// Leaf -> integerLiteral
    /// Leaf -> floatLiteral
    /// Leaf -> stringLiteral
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseLeaf(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseLeaf(context);
    }
    private static ParseNode ParseIdentifier(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Identifier -> verbatimIdentifier
        if (((SlangParser.verbatimIdentifier == context.SymbolId) 
                    && SlangParser._WhereIdentifier(context.GetLookAhead(true)))) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.verbatimIdentifier == context.SymbolId))) {
                context.Error("Expecting verbatimIdentifier at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.verbatimIdentifier, "verbatimIdentifier", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.Identifier, "Identifier", children, line, column, position);
        }
        // Identifier -> identifier
        if (((SlangParser.identifier2 == context.SymbolId) 
                    && SlangParser._WhereIdentifier(context.GetLookAhead(true)))) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.identifier2 == context.SymbolId))) {
                context.Error("Expecting identifier at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.identifier2, "identifier", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.Identifier, "Identifier", children, line, column, position);
        }
        context.Error("Expecting verbatimIdentifier or identifier at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static bool _WhereIdentifier(ParserContext context) {
        return (false == Keywords.Contains(context.Value));
    }
    private static ParseNode ParseTermList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TermList -> add Factor TermListRightAssoc TermListRightAssoc2
        if ((SlangParser.add == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.add == context.SymbolId))) {
                context.Error("Expecting add at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.add, "add", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseFactor(context));
            children.AddRange(SlangParser.ParseTermListRightAssoc(context).Children);
            children.AddRange(SlangParser.ParseTermListRightAssoc2(context).Children);
            return new ParseNode(SlangParser.TermList, "TermList", children.ToArray(), line, column, position);
        }
        // TermList -> sub Factor TermListRightAssoc TermListRightAssoc2
        if ((SlangParser.sub == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.sub == context.SymbolId))) {
                context.Error("Expecting sub at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.sub, "sub", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseFactor(context));
            children.AddRange(SlangParser.ParseTermListRightAssoc(context).Children);
            children.AddRange(SlangParser.ParseTermListRightAssoc2(context).Children);
            return new ParseNode(SlangParser.TermList, "TermList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting add or sub at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseFactorList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // FactorList -> mul MemberRef FactorListRightAssoc FactorListRightAssoc2 FactorListRightAssoc3
        if ((SlangParser.mul == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.mul == context.SymbolId))) {
                context.Error("Expecting mul at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.mul, "mul", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseMemberRef(context));
            children.AddRange(SlangParser.ParseFactorListRightAssoc(context).Children);
            children.AddRange(SlangParser.ParseFactorListRightAssoc2(context).Children);
            children.AddRange(SlangParser.ParseFactorListRightAssoc3(context).Children);
            return new ParseNode(SlangParser.FactorList, "FactorList", children.ToArray(), line, column, position);
        }
        // FactorList -> div MemberRef FactorListRightAssoc FactorListRightAssoc2 FactorListRightAssoc3
        if ((SlangParser.div == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.div == context.SymbolId))) {
                context.Error("Expecting div at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.div, "div", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseMemberRef(context));
            children.AddRange(SlangParser.ParseFactorListRightAssoc(context).Children);
            children.AddRange(SlangParser.ParseFactorListRightAssoc2(context).Children);
            children.AddRange(SlangParser.ParseFactorListRightAssoc3(context).Children);
            return new ParseNode(SlangParser.FactorList, "FactorList", children.ToArray(), line, column, position);
        }
        // FactorList -> mod MemberRef FactorListRightAssoc FactorListRightAssoc2 FactorListRightAssoc3
        if ((SlangParser.mod == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.mod == context.SymbolId))) {
                context.Error("Expecting mod at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.mod, "mod", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseMemberRef(context));
            children.AddRange(SlangParser.ParseFactorListRightAssoc(context).Children);
            children.AddRange(SlangParser.ParseFactorListRightAssoc2(context).Children);
            children.AddRange(SlangParser.ParseFactorListRightAssoc3(context).Children);
            return new ParseNode(SlangParser.FactorList, "FactorList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting mul, div, or mod at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseMemberAnyRefList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberAnyRefList -> MemberAnyRef MemberAnyRefListRightAssoc
        if ((((SlangParser.dot == context.SymbolId) 
                    || (SlangParser.lparen == context.SymbolId)) 
                    || (SlangParser.lbracket == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseMemberAnyRef(context).Children);
            children.AddRange(SlangParser.ParseMemberAnyRefListRightAssoc(context).Children);
            return new ParseNode(SlangParser.MemberAnyRefList, "MemberAnyRefList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting dot, lparen, or lbracket at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseMemberInvokeRefList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberInvokeRefList -> comma MethodArg MemberInvokeRefListRightAssoc
        if ((SlangParser.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.comma == context.SymbolId))) {
                context.Error("Expecting comma at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.comma, "comma", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseMethodArg(context));
            children.AddRange(SlangParser.ParseMemberInvokeRefListRightAssoc(context).Children);
            return new ParseNode(SlangParser.MemberInvokeRefList, "MemberInvokeRefList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting comma at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseMemberIndexerRefList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberIndexerRefList -> comma Expression MemberIndexerRefListRightAssoc
        if ((SlangParser.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.comma == context.SymbolId))) {
                context.Error("Expecting comma at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.comma, "comma", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseExpression(context));
            children.AddRange(SlangParser.ParseMemberIndexerRefListRightAssoc(context).Children);
            return new ParseNode(SlangParser.MemberIndexerRefList, "MemberIndexerRefList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting comma at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTypeBaseList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeBaseList -> dot identifier TypeBaseListRightAssoc
        if ((SlangParser.dot == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.dot == context.SymbolId))) {
                context.Error("Expecting dot at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.dot, "dot", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            if ((false 
                        == (SlangParser.identifier2 == context.SymbolId))) {
                context.Error("Expecting identifier at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.identifier2, "identifier", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.AddRange(SlangParser.ParseTypeBaseListRightAssoc(context).Children);
            return new ParseNode(SlangParser.TypeBaseList, "TypeBaseList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting dot at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTypeArraySpecList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeArraySpecList -> TypeArraySpec TypeArraySpecListRightAssoc
        if ((SlangParser.lbracket == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(SlangParser.ParseTypeArraySpec(context));
            children.AddRange(SlangParser.ParseTypeArraySpecListRightAssoc(context).Children);
            return new ParseNode(SlangParser.TypeArraySpecList, "TypeArraySpecList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting lbracket at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTypeGenericPartList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeGenericPartList -> comma Type TypeGenericPartListRightAssoc
        if ((SlangParser.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.comma == context.SymbolId))) {
                context.Error("Expecting comma at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.comma, "comma", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseType(context));
            children.AddRange(SlangParser.ParseTypeGenericPartListRightAssoc(context).Children);
            return new ParseNode(SlangParser.TypeGenericPartList, "TypeGenericPartList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting comma at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseArraySpecRankList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // ArraySpecRankList -> ArraySpecRank ArraySpecRankListRightAssoc
        if ((SlangParser.ArraySpecRank == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.ArraySpecRank == context.SymbolId))) {
                context.Error("Expecting ArraySpecRank at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.ArraySpecRank, "ArraySpecRank", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.AddRange(SlangParser.ParseArraySpecRankListRightAssoc(context).Children);
            return new ParseNode(SlangParser.ArraySpecRankList, "ArraySpecRankList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting ArraySpecRank at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTermListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TermListRightAssoc -> add Factor TermListRightAssoc
        if ((SlangParser.add == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.add == context.SymbolId))) {
                context.Error("Expecting add at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.add, "add", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseFactor(context));
            children.AddRange(SlangParser.ParseTermListRightAssoc(context).Children);
            return new ParseNode(SlangParser.TermListRightAssoc, "TermListRightAssoc", children.ToArray(), line, column, position);
        }
        // TermListRightAssoc ->
        if ((((((SlangParser.sub == context.SymbolId) 
                    || (SlangParser.EosSymbol == context.SymbolId)) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.rbracket == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.TermListRightAssoc, "TermListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting add, sub, #EOS, comma, rparen, or rbracket at line {0}, column {1}, pos" +
                "ition {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseFactorListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // FactorListRightAssoc -> mul MemberRef FactorListRightAssoc
        if ((SlangParser.mul == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.mul == context.SymbolId))) {
                context.Error("Expecting mul at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.mul, "mul", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseMemberRef(context));
            children.AddRange(SlangParser.ParseFactorListRightAssoc(context).Children);
            return new ParseNode(SlangParser.FactorListRightAssoc, "FactorListRightAssoc", children.ToArray(), line, column, position);
        }
        // FactorListRightAssoc ->
        if (((((((((SlangParser.mod == context.SymbolId) 
                    || (SlangParser.div == context.SymbolId)) 
                    || (SlangParser.add == context.SymbolId)) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.EosSymbol == context.SymbolId)) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.rbracket == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.FactorListRightAssoc, "FactorListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting mul, mod, div, add, sub, #EOS, comma, rparen, or rbracket at line {0}, " +
                "column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseFactorListRightAssoc2(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // FactorListRightAssoc2 -> mod MemberRef FactorListRightAssoc2
        if ((SlangParser.mod == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.mod == context.SymbolId))) {
                context.Error("Expecting mod at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.mod, "mod", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseMemberRef(context));
            children.AddRange(SlangParser.ParseFactorListRightAssoc2(context).Children);
            return new ParseNode(SlangParser.FactorListRightAssoc2, "FactorListRightAssoc2", children.ToArray(), line, column, position);
        }
        // FactorListRightAssoc2 ->
        if ((((((((SlangParser.div == context.SymbolId) 
                    || (SlangParser.add == context.SymbolId)) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.EosSymbol == context.SymbolId)) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.rbracket == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.FactorListRightAssoc2, "FactorListRightAssoc2", children, line, column, position);
        }
        context.Error("Expecting mod, div, add, sub, #EOS, comma, rparen, or rbracket at line {0}, colum" +
                "n {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseMemberAnyRefListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberAnyRefListRightAssoc -> MemberAnyRef MemberAnyRefListRightAssoc
        if ((((SlangParser.dot == context.SymbolId) 
                    || (SlangParser.lparen == context.SymbolId)) 
                    || (SlangParser.lbracket == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseMemberAnyRef(context).Children);
            children.AddRange(SlangParser.ParseMemberAnyRefListRightAssoc(context).Children);
            return new ParseNode(SlangParser.MemberAnyRefListRightAssoc, "MemberAnyRefListRightAssoc", children.ToArray(), line, column, position);
        }
        // MemberAnyRefListRightAssoc ->
        if ((((((((((SlangParser.mul == context.SymbolId) 
                    || (SlangParser.mod == context.SymbolId)) 
                    || (SlangParser.div == context.SymbolId)) 
                    || (SlangParser.add == context.SymbolId)) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.EosSymbol == context.SymbolId)) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.rbracket == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.MemberAnyRefListRightAssoc, "MemberAnyRefListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting dot, lparen, lbracket, mul, mod, div, add, sub, #EOS, comma, rparen, or" +
                " rbracket at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseMemberInvokeRefListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberInvokeRefListRightAssoc -> comma MethodArg MemberInvokeRefListRightAssoc
        if ((SlangParser.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.comma == context.SymbolId))) {
                context.Error("Expecting comma at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.comma, "comma", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseMethodArg(context));
            children.AddRange(SlangParser.ParseMemberInvokeRefListRightAssoc(context).Children);
            return new ParseNode(SlangParser.MemberInvokeRefListRightAssoc, "MemberInvokeRefListRightAssoc", children.ToArray(), line, column, position);
        }
        // MemberInvokeRefListRightAssoc ->
        if ((SlangParser.rparen == context.SymbolId)) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.MemberInvokeRefListRightAssoc, "MemberInvokeRefListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting comma or rparen at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseMemberIndexerRefListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberIndexerRefListRightAssoc -> comma Expression MemberIndexerRefListRightAssoc
        if ((SlangParser.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.comma == context.SymbolId))) {
                context.Error("Expecting comma at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.comma, "comma", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseExpression(context));
            children.AddRange(SlangParser.ParseMemberIndexerRefListRightAssoc(context).Children);
            return new ParseNode(SlangParser.MemberIndexerRefListRightAssoc, "MemberIndexerRefListRightAssoc", children.ToArray(), line, column, position);
        }
        // MemberIndexerRefListRightAssoc ->
        if ((SlangParser.rbracket == context.SymbolId)) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.MemberIndexerRefListRightAssoc, "MemberIndexerRefListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting comma or rbracket at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTypeBaseListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeBaseListRightAssoc -> dot identifier TypeBaseListRightAssoc
        if ((SlangParser.dot == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.dot == context.SymbolId))) {
                context.Error("Expecting dot at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.dot, "dot", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            if ((false 
                        == (SlangParser.identifier2 == context.SymbolId))) {
                context.Error("Expecting identifier at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.identifier2, "identifier", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.AddRange(SlangParser.ParseTypeBaseListRightAssoc(context).Children);
            return new ParseNode(SlangParser.TypeBaseListRightAssoc, "TypeBaseListRightAssoc", children.ToArray(), line, column, position);
        }
        // TypeBaseListRightAssoc ->
        if ((((((SlangParser.lt == context.SymbolId) 
                    || (SlangParser.lbracket == context.SymbolId)) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.gt == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.TypeBaseListRightAssoc, "TypeBaseListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting dot, lt, lbracket, rparen, comma, or gt at line {0}, column {1}, positi" +
                "on {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTypeArraySpecListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeArraySpecListRightAssoc -> TypeArraySpec TypeArraySpecListRightAssoc
        if ((SlangParser.lbracket == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(SlangParser.ParseTypeArraySpec(context));
            children.AddRange(SlangParser.ParseTypeArraySpecListRightAssoc(context).Children);
            return new ParseNode(SlangParser.TypeArraySpecListRightAssoc, "TypeArraySpecListRightAssoc", children.ToArray(), line, column, position);
        }
        // TypeArraySpecListRightAssoc ->
        if ((((SlangParser.rparen == context.SymbolId) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.gt == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.TypeArraySpecListRightAssoc, "TypeArraySpecListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting lbracket, rparen, comma, or gt at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTypeGenericPartListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeGenericPartListRightAssoc -> comma Type TypeGenericPartListRightAssoc
        if ((SlangParser.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.comma == context.SymbolId))) {
                context.Error("Expecting comma at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.comma, "comma", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseType(context));
            children.AddRange(SlangParser.ParseTypeGenericPartListRightAssoc(context).Children);
            return new ParseNode(SlangParser.TypeGenericPartListRightAssoc, "TypeGenericPartListRightAssoc", children.ToArray(), line, column, position);
        }
        // TypeGenericPartListRightAssoc ->
        if ((SlangParser.gt == context.SymbolId)) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.TypeGenericPartListRightAssoc, "TypeGenericPartListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting comma or gt at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseArraySpecRankListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // ArraySpecRankListRightAssoc -> ArraySpecRank ArraySpecRankListRightAssoc
        if ((SlangParser.ArraySpecRank == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.ArraySpecRank == context.SymbolId))) {
                context.Error("Expecting ArraySpecRank at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.ArraySpecRank, "ArraySpecRank", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.AddRange(SlangParser.ParseArraySpecRankListRightAssoc(context).Children);
            return new ParseNode(SlangParser.ArraySpecRankListRightAssoc, "ArraySpecRankListRightAssoc", children.ToArray(), line, column, position);
        }
        // ArraySpecRankListRightAssoc ->
        if ((SlangParser.rbracket == context.SymbolId)) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.ArraySpecRankListRightAssoc, "ArraySpecRankListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting ArraySpecRank or rbracket at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTerm(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Term -> Factor TermPart
        if ((((((((((SlangParser.add == context.SymbolId) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.lparen == context.SymbolId)) 
                    || (SlangParser.verbatimIdentifier == context.SymbolId)) 
                    || (SlangParser.identifier2 == context.SymbolId)) 
                    || (SlangParser.verbatimStringLiteral == context.SymbolId)) 
                    || (SlangParser.integerLiteral == context.SymbolId)) 
                    || (SlangParser.floatLiteral == context.SymbolId)) 
                    || (SlangParser.stringLiteral == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(SlangParser.ParseFactor(context));
            children.AddRange(SlangParser.ParseTermPart(context).Children);
            return new ParseNode(SlangParser.Term, "Term", children.ToArray(), line, column, position);
        }
        context.Error("Expecting add, sub, lparen, verbatimIdentifier, identifier, verbatimStringLiteral" +
                ", integerLiteral, floatLiteral, or stringLiteral at line {0}, column {1}, positi" +
                "on {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Term= Factor { ( "+" | "-" ) Factor }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Term -> Factor TermPart
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseTerm(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseTerm(context);
    }
    private static ParseNode ParseTermPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TermPart -> TermList
        if (((SlangParser.add == context.SymbolId) 
                    || (SlangParser.sub == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseTermList(context).Children);
            return new ParseNode(SlangParser.TermPart, "TermPart", children.ToArray(), line, column, position);
        }
        // TermPart ->
        if (((((SlangParser.EosSymbol == context.SymbolId) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.rbracket == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.TermPart, "TermPart", children, line, column, position);
        }
        context.Error("Expecting add, sub, #EOS, comma, rparen, or rbracket at line {0}, column {1}, pos" +
                "ition {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseFactor(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Factor -> MemberRef FactorPart
        if ((((((((((SlangParser.add == context.SymbolId) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.lparen == context.SymbolId)) 
                    || (SlangParser.verbatimIdentifier == context.SymbolId)) 
                    || (SlangParser.identifier2 == context.SymbolId)) 
                    || (SlangParser.verbatimStringLiteral == context.SymbolId)) 
                    || (SlangParser.integerLiteral == context.SymbolId)) 
                    || (SlangParser.floatLiteral == context.SymbolId)) 
                    || (SlangParser.stringLiteral == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(SlangParser.ParseMemberRef(context));
            children.AddRange(SlangParser.ParseFactorPart(context).Children);
            return new ParseNode(SlangParser.Factor, "Factor", children.ToArray(), line, column, position);
        }
        context.Error("Expecting add, sub, lparen, verbatimIdentifier, identifier, verbatimStringLiteral" +
                ", integerLiteral, floatLiteral, or stringLiteral at line {0}, column {1}, positi" +
                "on {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Factor= MemberRef { ( "*" | "/" | "%" ) MemberRef }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Factor -> MemberRef FactorPart
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseFactor(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseFactor(context);
    }
    private static ParseNode ParseFactorPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // FactorPart -> FactorList
        if ((((SlangParser.mul == context.SymbolId) 
                    || (SlangParser.div == context.SymbolId)) 
                    || (SlangParser.mod == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseFactorList(context).Children);
            return new ParseNode(SlangParser.FactorPart, "FactorPart", children.ToArray(), line, column, position);
        }
        // FactorPart ->
        if (((((((SlangParser.add == context.SymbolId) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.EosSymbol == context.SymbolId)) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.rbracket == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.FactorPart, "FactorPart", children, line, column, position);
        }
        context.Error("Expecting mul, div, mod, add, sub, #EOS, comma, rparen, or rbracket at line {0}, " +
                "column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseMemberRef(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberRef -> Unary MemberRefPart
        if ((((((((((SlangParser.add == context.SymbolId) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.lparen == context.SymbolId)) 
                    || (SlangParser.verbatimIdentifier == context.SymbolId)) 
                    || (SlangParser.identifier2 == context.SymbolId)) 
                    || (SlangParser.verbatimStringLiteral == context.SymbolId)) 
                    || (SlangParser.integerLiteral == context.SymbolId)) 
                    || (SlangParser.floatLiteral == context.SymbolId)) 
                    || (SlangParser.stringLiteral == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(SlangParser.ParseUnary(context));
            children.AddRange(SlangParser.ParseMemberRefPart(context).Children);
            return new ParseNode(SlangParser.MemberRef, "MemberRef", children.ToArray(), line, column, position);
        }
        context.Error("Expecting add, sub, lparen, verbatimIdentifier, identifier, verbatimStringLiteral" +
                ", integerLiteral, floatLiteral, or stringLiteral at line {0}, column {1}, positi" +
                "on {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// MemberRef= Unary | Unary { MemberAnyRef }+
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// MemberRef -> Unary MemberRefPart
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseMemberRef(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseMemberRef(context);
    }
    private static ParseNode ParseMemberRefPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberRefPart ->
        if ((((((((((SlangParser.mul == context.SymbolId) 
                    || (SlangParser.mod == context.SymbolId)) 
                    || (SlangParser.div == context.SymbolId)) 
                    || (SlangParser.add == context.SymbolId)) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.EosSymbol == context.SymbolId)) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.rbracket == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.MemberRefPart, "MemberRefPart", children, line, column, position);
        }
        // MemberRefPart -> MemberAnyRefList
        if ((((SlangParser.dot == context.SymbolId) 
                    || (SlangParser.lparen == context.SymbolId)) 
                    || (SlangParser.lbracket == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseMemberAnyRefList(context).Children);
            return new ParseNode(SlangParser.MemberRefPart, "MemberRefPart", children.ToArray(), line, column, position);
        }
        context.Error("Expecting mul, mod, div, add, sub, #EOS, comma, rparen, rbracket, dot, lparen, or" +
                " lbracket at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseMemberInvokeRefPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberInvokeRefPart -> MemberInvokeRefList rparen
        if ((SlangParser.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseMemberInvokeRefList(context).Children);
            if ((false 
                        == (SlangParser.rparen == context.SymbolId))) {
                context.Error("Expecting rparen at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.rparen, "rparen", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            return new ParseNode(SlangParser.MemberInvokeRefPart, "MemberInvokeRefPart", children.ToArray(), line, column, position);
        }
        // MemberInvokeRefPart -> rparen
        if ((SlangParser.rparen == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.rparen == context.SymbolId))) {
                context.Error("Expecting rparen at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.rparen, "rparen", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.MemberInvokeRefPart, "MemberInvokeRefPart", children, line, column, position);
        }
        context.Error("Expecting comma or rparen at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseMemberIndexerRef(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberIndexerRef -> lbracket Expression MemberIndexerRefPart
        if ((SlangParser.lbracket == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.lbracket == context.SymbolId))) {
                context.Error("Expecting lbracket at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.lbracket, "lbracket", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseExpression(context));
            children.AddRange(SlangParser.ParseMemberIndexerRefPart(context).Children);
            return new ParseNode(SlangParser.MemberIndexerRef, "MemberIndexerRef", children.ToArray(), line, column, position);
        }
        context.Error("Expecting lbracket at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// MemberIndexerRef= "[" Expression { "," Expression } "]"
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// MemberIndexerRef -> lbracket Expression MemberIndexerRefPart
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseMemberIndexerRef(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseMemberIndexerRef(context);
    }
    private static ParseNode ParseMemberIndexerRefPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberIndexerRefPart -> MemberIndexerRefList rbracket
        if ((SlangParser.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseMemberIndexerRefList(context).Children);
            if ((false 
                        == (SlangParser.rbracket == context.SymbolId))) {
                context.Error("Expecting rbracket at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.rbracket, "rbracket", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            return new ParseNode(SlangParser.MemberIndexerRefPart, "MemberIndexerRefPart", children.ToArray(), line, column, position);
        }
        // MemberIndexerRefPart -> rbracket
        if ((SlangParser.rbracket == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.rbracket == context.SymbolId))) {
                context.Error("Expecting rbracket at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.rbracket, "rbracket", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.MemberIndexerRefPart, "MemberIndexerRefPart", children, line, column, position);
        }
        context.Error("Expecting comma or rbracket at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTypeBase(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeBase -> identifier TypeBasePart
        if ((SlangParser.identifier2 == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.identifier2 == context.SymbolId))) {
                context.Error("Expecting identifier at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.identifier2, "identifier", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.AddRange(SlangParser.ParseTypeBasePart(context).Children);
            return new ParseNode(SlangParser.TypeBase, "TypeBase", children.ToArray(), line, column, position);
        }
        context.Error("Expecting identifier at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// TypeBase= identifier { "." identifier }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// TypeBase -> identifier TypeBasePart
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseTypeBase(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseTypeBase(context);
    }
    private static ParseNode ParseTypeBasePart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeBasePart -> TypeBaseList
        if ((SlangParser.dot == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseTypeBaseList(context).Children);
            return new ParseNode(SlangParser.TypeBasePart, "TypeBasePart", children.ToArray(), line, column, position);
        }
        // TypeBasePart ->
        if ((((((SlangParser.lt == context.SymbolId) 
                    || (SlangParser.lbracket == context.SymbolId)) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.gt == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.TypeBasePart, "TypeBasePart", children, line, column, position);
        }
        context.Error("Expecting dot, lt, lbracket, rparen, comma, or gt at line {0}, column {1}, positi" +
                "on {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseType(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Type -> TypeElement TypePart
        if ((SlangParser.identifier2 == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(SlangParser.ParseTypeElement(context));
            children.AddRange(SlangParser.ParseTypePart(context).Children);
            return new ParseNode(SlangParser.Type, "Type", children.ToArray(), line, column, position);
        }
        context.Error("Expecting identifier at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Type= TypeElement { TypeArraySpec }
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Type -> TypeElement TypePart
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseType(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseType(context);
    }
    private static ParseNode ParseTypePart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypePart -> TypeArraySpecList
        if ((SlangParser.lbracket == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseTypeArraySpecList(context).Children);
            return new ParseNode(SlangParser.TypePart, "TypePart", children.ToArray(), line, column, position);
        }
        // TypePart ->
        if ((((SlangParser.rparen == context.SymbolId) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.gt == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.TypePart, "TypePart", children, line, column, position);
        }
        context.Error("Expecting lbracket, rparen, comma, or gt at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTypeElement(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeElement -> TypeBase TypeElementPart
        if ((SlangParser.identifier2 == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(SlangParser.ParseTypeBase(context));
            children.AddRange(SlangParser.ParseTypeElementPart(context).Children);
            return new ParseNode(SlangParser.TypeElement, "TypeElement", children.ToArray(), line, column, position);
        }
        context.Error("Expecting identifier at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// TypeElement= TypeBase [ TypeGenericPart ]
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// TypeElement -> TypeBase TypeElementPart
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseTypeElement(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseTypeElement(context);
    }
    private static ParseNode ParseTypeElementPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeElementPart -> TypeGenericPart
        if ((SlangParser.lt == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = SlangParser.ParseTypeGenericPart(context);
            return new ParseNode(SlangParser.TypeElementPart, "TypeElementPart", children, line, column, position);
        }
        // TypeElementPart ->
        if (((((SlangParser.lbracket == context.SymbolId) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.gt == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.TypeElementPart, "TypeElementPart", children, line, column, position);
        }
        context.Error("Expecting lt, lbracket, rparen, comma, or gt at line {0}, column {1}, position {2" +
                "}", line, column, position);
        return null;
    }
    private static ParseNode ParseTypeGenericPartPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeGenericPartPart -> TypeGenericPartList gt
        if ((SlangParser.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseTypeGenericPartList(context).Children);
            if ((false 
                        == (SlangParser.gt == context.SymbolId))) {
                context.Error("Expecting gt at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.gt, "gt", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            return new ParseNode(SlangParser.TypeGenericPartPart, "TypeGenericPartPart", children.ToArray(), line, column, position);
        }
        // TypeGenericPartPart -> gt
        if ((SlangParser.gt == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.gt == context.SymbolId))) {
                context.Error("Expecting gt at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.gt, "gt", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.TypeGenericPartPart, "TypeGenericPartPart", children, line, column, position);
        }
        context.Error("Expecting comma or gt at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTypeArraySpec(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeArraySpec -> lbracket TypeArraySpecPart
        if ((SlangParser.lbracket == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.lbracket == context.SymbolId))) {
                context.Error("Expecting lbracket at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.lbracket, "lbracket", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.AddRange(SlangParser.ParseTypeArraySpecPart(context).Children);
            return new ParseNode(SlangParser.TypeArraySpec, "TypeArraySpec", children.ToArray(), line, column, position);
        }
        context.Error("Expecting lbracket at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// TypeArraySpec= "[" { ArraySpecRank } "]"
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// TypeArraySpec -> lbracket TypeArraySpecPart
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseTypeArraySpec(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseTypeArraySpec(context);
    }
    private static ParseNode ParseTypeArraySpecPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeArraySpecPart -> ArraySpecRankList rbracket
        if ((SlangParser.ArraySpecRank == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.AddRange(SlangParser.ParseArraySpecRankList(context).Children);
            if ((false 
                        == (SlangParser.rbracket == context.SymbolId))) {
                context.Error("Expecting rbracket at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.rbracket, "rbracket", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            return new ParseNode(SlangParser.TypeArraySpecPart, "TypeArraySpecPart", children.ToArray(), line, column, position);
        }
        // TypeArraySpecPart -> rbracket
        if ((SlangParser.rbracket == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.rbracket == context.SymbolId))) {
                context.Error("Expecting rbracket at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.rbracket, "rbracket", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.TypeArraySpecPart, "TypeArraySpecPart", children, line, column, position);
        }
        context.Error("Expecting ArraySpecRank or rbracket at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTermListRightAssoc2(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TermListRightAssoc2 -> sub Factor TermListRightAssoc2
        if ((SlangParser.sub == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.sub == context.SymbolId))) {
                context.Error("Expecting sub at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.sub, "sub", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseFactor(context));
            children.AddRange(SlangParser.ParseTermListRightAssoc2(context).Children);
            return new ParseNode(SlangParser.TermListRightAssoc2, "TermListRightAssoc2", children.ToArray(), line, column, position);
        }
        // TermListRightAssoc2 ->
        if (((((SlangParser.EosSymbol == context.SymbolId) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.rbracket == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.TermListRightAssoc2, "TermListRightAssoc2", children, line, column, position);
        }
        context.Error("Expecting sub, #EOS, comma, rparen, or rbracket at line {0}, column {1}, position" +
                " {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseFactorListRightAssoc3(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // FactorListRightAssoc3 -> div MemberRef FactorListRightAssoc3
        if ((SlangParser.div == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.div == context.SymbolId))) {
                context.Error("Expecting div at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.div, "div", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.Add(SlangParser.ParseMemberRef(context));
            children.AddRange(SlangParser.ParseFactorListRightAssoc3(context).Children);
            return new ParseNode(SlangParser.FactorListRightAssoc3, "FactorListRightAssoc3", children.ToArray(), line, column, position);
        }
        // FactorListRightAssoc3 ->
        if (((((((SlangParser.add == context.SymbolId) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.EosSymbol == context.SymbolId)) 
                    || (SlangParser.comma == context.SymbolId)) 
                    || (SlangParser.rparen == context.SymbolId)) 
                    || (SlangParser.rbracket == context.SymbolId))) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(SlangParser.FactorListRightAssoc3, "FactorListRightAssoc3", children, line, column, position);
        }
        context.Error("Expecting div, add, sub, #EOS, comma, rparen, or rbracket at line {0}, column {1}" +
                ", position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseMemberInvokeRef(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberInvokeRef -> lparen MemberInvokeRefPart2
        if ((SlangParser.lparen == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.lparen == context.SymbolId))) {
                context.Error("Expecting lparen at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.lparen, "lparen", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.AddRange(SlangParser.ParseMemberInvokeRefPart2(context).Children);
            return new ParseNode(SlangParser.MemberInvokeRef, "MemberInvokeRef", children.ToArray(), line, column, position);
        }
        context.Error("Expecting lparen at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// MemberInvokeRef= "(" [ MethodArg { "," MethodArg } ] ")"
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// MemberInvokeRef -> lparen MemberInvokeRefPart2
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseMemberInvokeRef(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseMemberInvokeRef(context);
    }
    private static ParseNode ParseMemberInvokeRefPart2(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // MemberInvokeRefPart2 -> rparen
        if ((SlangParser.rparen == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.rparen == context.SymbolId))) {
                context.Error("Expecting rparen at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.rparen, "rparen", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.MemberInvokeRefPart2, "MemberInvokeRefPart2", children, line, column, position);
        }
        // MemberInvokeRefPart2 -> MethodArg MemberInvokeRefPart
        if ((((((((((((SlangParser.outKeyword == context.SymbolId) 
                    || (SlangParser.refKeyword == context.SymbolId)) 
                    || (SlangParser.add == context.SymbolId)) 
                    || (SlangParser.sub == context.SymbolId)) 
                    || (SlangParser.lparen == context.SymbolId)) 
                    || (SlangParser.verbatimIdentifier == context.SymbolId)) 
                    || (SlangParser.identifier2 == context.SymbolId)) 
                    || (SlangParser.verbatimStringLiteral == context.SymbolId)) 
                    || (SlangParser.integerLiteral == context.SymbolId)) 
                    || (SlangParser.floatLiteral == context.SymbolId)) 
                    || (SlangParser.stringLiteral == context.SymbolId))) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(SlangParser.ParseMethodArg(context));
            children.AddRange(SlangParser.ParseMemberInvokeRefPart(context).Children);
            return new ParseNode(SlangParser.MemberInvokeRefPart2, "MemberInvokeRefPart2", children.ToArray(), line, column, position);
        }
        context.Error("Expecting rparen, outKeyword, refKeyword, add, sub, lparen, verbatimIdentifier, i" +
                "dentifier, verbatimStringLiteral, integerLiteral, floatLiteral, or stringLiteral" +
                " at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    private static ParseNode ParseTypeGenericPart(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeGenericPart -> lt TypeGenericPartPart2
        if ((SlangParser.lt == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            if ((false 
                        == (SlangParser.lt == context.SymbolId))) {
                context.Error("Expecting lt at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children.Add(new ParseNode(SlangParser.lt, "lt", context.Value, context.Line, context.Column, context.Position));
            context.Advance();
            children.AddRange(SlangParser.ParseTypeGenericPartPart2(context).Children);
            return new ParseNode(SlangParser.TypeGenericPart, "TypeGenericPart", children.ToArray(), line, column, position);
        }
        context.Error("Expecting lt at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// TypeGenericPart= "<" [ Type { "," Type } ] ">"
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// TypeGenericPart -> lt TypeGenericPartPart2
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseTypeGenericPart(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return SlangParser.ParseTypeGenericPart(context);
    }
    private static ParseNode ParseTypeGenericPartPart2(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // TypeGenericPartPart2 -> gt
        if ((SlangParser.gt == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            if ((false 
                        == (SlangParser.gt == context.SymbolId))) {
                context.Error("Expecting gt at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
            }
            children[0] = new ParseNode(SlangParser.gt, "gt", context.Value, context.Line, context.Column, context.Position);
            context.Advance();
            return new ParseNode(SlangParser.TypeGenericPartPart2, "TypeGenericPartPart2", children, line, column, position);
        }
        // TypeGenericPartPart2 -> Type TypeGenericPartPart
        if ((SlangParser.identifier2 == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(SlangParser.ParseType(context));
            children.AddRange(SlangParser.ParseTypeGenericPartPart(context).Children);
            return new ParseNode(SlangParser.TypeGenericPartPart2, "TypeGenericPartPart2", children.ToArray(), line, column, position);
        }
        context.Error("Expecting gt or identifier at line {0}, column {1}, position {2}", line, column, position);
        return null;
    }
}
/// <summary>
/// 
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
internal class SyntaxException : Exception {
    private int _line;
    private int _column;
    private long _position;
    /// <summary>
    /// Creates a syntax exception with the specified arguments
    /// </summary>
    /// <param name="message">The error message</param>
    /// <param name="line">The line where the error occurred</param>
    /// <param name="column">The column where the error occured</param>
    /// <param name="position">The position where the error occured</param>
    public SyntaxException(string message, int line, int column, long position) : 
            base(SyntaxException._GetMessage(message, line, column, position)) {
        this._line = line;
        this._column = column;
        this._position = position;
    }
    /// <summary>
    /// The line where the error occurred
    /// </summary>
    public int Line {
        get {
            return this._line;
        }
    }
    /// <summary>
    /// The column where the error occurred
    /// </summary>
    public int Column {
        get {
            return this._column;
        }
    }
    /// <summary>
    /// The position where the error occurred
    /// </summary>
    public long Position {
        get {
            return this._position;
        }
    }
    static string _GetMessage(string message, int line, int column, long position) {
        return string.Format("{0} at line {1}, column {2}, position {3}", message, line, column, position);
    }
}
[System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
internal partial class ParseNode {
    private int _symbolId;
    private string _symbol;
    private string _value;
    private int _line;
    private int _column;
    private long _position;
    private ParseNode[] _children;
    public ParseNode(int symbolId, string symbol, ParseNode[] children, int line, int column, long position) {
        this._symbolId = symbolId;
        this._symbol = symbol;
        this._value = null;
        this._children = children;
        this._line = line;
        this._column = column;
        this._position = position;
    }
    public ParseNode(int symbolId, string symbol, string value, int line, int column, long position) {
        this._symbolId = symbolId;
        this._symbol = symbol;
        this._value = value;
        this._children = null;
        this._line = line;
        this._column = column;
        this._position = position;
    }
    public bool IsNonTerminal {
        get {
            return (null != this._children);
        }
    }
    public ParseNode[] Children {
        get {
            return this._children;
        }
    }
    public int SymbolId {
        get {
            return this._symbolId;
        }
    }
    public string Symbol {
        get {
            return this._symbol;
        }
    }
    public string Value {
        get {
            return this._value;
        }
    }
    public int Line {
        get {
            return this._line;
        }
    }
    public int Column {
        get {
            return this._column;
        }
    }
    public long Position {
        get {
            return this._position;
        }
    }
}
[System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
internal partial class ParserContext : Object, IDisposable {
    private int _state;
    private IEnumerator<Token> _e;
    private LookAheadEnumerator<Token> _el;
    private Token _t;
    private int _advanceCount;
    public ParserContext(IEnumerable<Token> tokenizer) : 
            this(tokenizer.GetEnumerator(), true) {
    }
    private ParserContext(IEnumerator<Token> enumerator, bool wrap) {
        this._e = enumerator;
        if (wrap) {
            this._el = new LookAheadEnumerator<Token>(enumerator);
            this._e = this._el;
            // we need both pointers to point to the lookahead
        }
        this._state = -1;
        this._t.SymbolId = -1;
        this._advanceCount = 0;
    }
    public void EnsureStarted() {
        if ((-1 == this._state)) {
            this.Advance();
        }
    }
    public ParserContext GetLookAhead() {
        if ((null == this._el)) {
            throw new NotSupportedException("This parser context does not support lookahead.");
        }
        return new ParserContext(this._el.LookAhead.GetEnumerator(), true);
    }
    public ParserContext GetLookAhead(bool start) {
        ParserContext result = this.GetLookAhead();
        if (start) {
            result.EnsureStarted();
        }
        return result;
    }
    public int AdvanceCount {
        get {
            return this._advanceCount;
        }
    }
    public void ResetAdvanceCount() {
        this._advanceCount = 0;
    }
    public int SymbolId {
        get {
            return this._t.SymbolId;
        }
    }
    public string Value {
        get {
            return this._t.Value;
        }
    }
    public int Line {
        get {
            return this._t.Line;
        }
    }
    public int Column {
        get {
            return this._t.Column;
        }
    }
    public long Position {
        get {
            return this._t.Position;
        }
    }
    public bool IsEnded {
        get {
            return (-2 == this._state);
        }
    }
    public bool Advance() {
        if ((false == this._e.MoveNext())) {
            this._t.SymbolId = -2;
            this._state = -2;
        }
        else {
            // sanity check. should never happen
            if ((int.MaxValue == this._advanceCount)) {
                this._advanceCount = -1;
            }
            this._advanceCount = (this._advanceCount + 1);
            this._state = 0;
            this._t = this._e.Current;
            return true;
        }
        return false;
    }
    public void Error(string message, object arg1, object arg2, object arg3) {
        throw new SyntaxException(string.Format(message, arg1, arg2, arg3), this.Line, this.Column, this.Position);
    }
    public void Error(string message, object arg1, object arg2) {
        throw new SyntaxException(string.Format(message, arg1, arg2), this.Line, this.Column, this.Position);
    }
    public void Error(string message, object arg) {
        throw new SyntaxException(string.Format(message, arg), this.Line, this.Column, this.Position);
    }
    public void Error(string message) {
        throw new SyntaxException(message, this.Line, this.Column, this.Position);
    }
    public void Dispose() {
        this._e.Dispose();
        this._state = -3;
    }
}
/// <summary>
/// An enumerator that provides lookahead without advancing the cursor
/// </summary>
/// <typeparam name="T">The type to enumerate</typeparam>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
internal class LookAheadEnumerator<T> : object, IEnumerator<T>
 {
    private const int _Enumerating = 0;
    private const int _NotStarted = -2;
    private const int _Ended = -1;
    private const int _Disposed = -3;
    private IEnumerator<T> _inner;
    private int _state;
    // for the lookahead queue
    private const int _DefaultCapacity = 16;
    private const float _GrowthFactor = 0.9F;
    private T[] _queue;
    private int _queueHead;
    private int _queueCount;
    /// <summary>
    /// Creates a new instance. Once this is created, the inner/wrapped enumerator must not be touched.
    /// </summary>
    /// <param name="inner"></param>
    public LookAheadEnumerator(IEnumerator<T> inner) {
        this._inner = inner;
        this._state = LookAheadEnumerator<T>._NotStarted;
        this._queue = new T[LookAheadEnumerator<T>._DefaultCapacity];
        this._queueHead = 0;
        this._queueCount = 0;
    }
    /// <summary>
    /// Discards the lookahead and advances the cursor to the physical position.
    /// </summary>
    public void DiscardLookAhead() {
        for (
        ; (1 < this._queueCount); 
        ) {
            this._Dequeue();
        }
    }
    /// <summary>
    /// Retrieves the value under the cursor
    /// </summary>
    public T Current {
        get {
            if ((0 > this._state)) {
                if ((LookAheadEnumerator<T>._NotStarted == this._state)) {
                    throw new InvalidOperationException("The cursor is before the start of the enumeration.");
                }
                if ((LookAheadEnumerator<T>._Ended == this._state)) {
                    throw new InvalidOperationException("The cursor is after the end of the enumeration.");
                }
                throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
            }
            return this._queue[this._queueHead];
        }
    }
    // legacy enum support (required)
    object System.Collections.IEnumerator.Current {
        get {
            return this.Current;
        }
    }
    internal int QueueCount {
        get {
            return this._queueCount;
        }
    }
    /// <summary>
    /// Attempts to peek the specified number of positions from the current position without advancing
    /// </summary>
    /// <param name="lookahead">The offset from the current position to peek at</param>
    /// <param name="value">The value returned</param>
    /// <returns>True if the peek could be satisfied, otherwise false</returns>
    public bool TryPeek(int lookahead, out T value) {
        if ((LookAheadEnumerator<T>._Disposed == this._state)) {
            throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
        }
        if ((0 > lookahead)) {
            throw new ArgumentOutOfRangeException("lookahead");
        }
        if ((LookAheadEnumerator<T>._Ended == this._state)) {
            value = default(T);
            return false;
        }
        if ((LookAheadEnumerator<T>._NotStarted == this._state)) {
            if ((0 == lookahead)) {
                value = default(T);
                return false;
            }
        }
        if ((lookahead < this._queueCount)) {
            value = this._queue[((lookahead + this._queueHead) 
                        % this._queue.Length)];
            return true;
        }
        lookahead = (lookahead - this._queueCount);
        value = default(T);
        for (
        ; ((0 <= lookahead) 
                    && this._inner.MoveNext()); 
        ) {
            value = this._inner.Current;
            this._Enqueue(value);
            lookahead = (lookahead - 1);
        }
        return (-1 == lookahead);
    }
    /// <summary>
    /// Peek the specified number of positions from the current position without advancing
    /// </summary>
    /// <param name="lookahead">The offset from the current position to peek at</param>
    /// <returns>The value at the specified position</returns>
    public T Peek(int lookahead) {
        T value;
        if ((false == this.TryPeek(lookahead, out value))) {
            throw new InvalidOperationException("There were not enough values in the enumeration to satisfy the request");
        }
        return value;
    }
    internal bool IsEnumerating {
        get {
            return (-1 < this._state);
        }
    }
    internal bool IsEnded {
        get {
            return (LookAheadEnumerator<T>._Ended == this._state);
        }
    }
    /// <summary>
    /// Retrieves a lookahead cursor from the current cursor that can be navigated without moving the main cursor
    /// </summary>
    public IEnumerable<T> LookAhead {
        get {
            if ((0 > this._state)) {
                if ((this._state == LookAheadEnumerator<T>._NotStarted)) {
                    throw new InvalidOperationException("The cursor is before the start of the enumeration.");
                }
                if ((this._state == LookAheadEnumerator<T>._Ended)) {
                    throw new InvalidOperationException("The cursor is after the end of the enumeration.");
                }
                throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
            }
            return new LookAheadEnumeratorEnumerable<T>(this);
        }
    }
    /// <summary>
    /// Advances the cursor
    /// </summary>
    /// <returns>True if more input was read, otherwise false</returns>
    bool System.Collections.IEnumerator.MoveNext() {
        if ((0 > this._state)) {
            if ((LookAheadEnumerator<T>._Disposed == this._state)) {
                throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
            }
            if ((LookAheadEnumerator<T>._Ended == this._state)) {
                return false;
            }
            if ((LookAheadEnumerator<T>._NotStarted == this._state)) {
                if ((0 < this._queueCount)) {
                    this._state = LookAheadEnumerator<T>._Enumerating;
                    return true;
                }
                if ((false == this._inner.MoveNext())) {
                    this._state = LookAheadEnumerator<T>._Ended;
                    return false;
                }
                this._Enqueue(this._inner.Current);
                this._state = LookAheadEnumerator<T>._Enumerating;
                return true;
            }
        }
        this._Dequeue();
        if ((0 == this._queueCount)) {
            if ((false == this._inner.MoveNext())) {
                this._state = LookAheadEnumerator<T>._Ended;
                return false;
            }
            this._Enqueue(this._inner.Current);
        }
        return true;
    }
    /// <summary>
    /// Resets the cursor, and clears the queue.
    /// </summary>
    void System.Collections.IEnumerator.Reset() {
        this._inner.Reset();
        if (((0 < this._queueCount) 
                    && (null == default(T)))) {
            System.Array.Clear(this._queue, this._queueHead, (this._queue.Length - this._queueHead));
            if (((this._queueHead + this._queueCount) 
                        >= this._queue.Length)) {
                System.Array.Clear(this._queue, 0, (this._queueHead 
                                + (this._queueCount % this._queue.Length)));
            }
        }
        this._queueHead = 0;
        this._queueCount = 0;
        this._state = LookAheadEnumerator<T>._NotStarted;
    }
    #region IDisposable Support
    /// <summary>
    /// Disposes of this instance
    /// </summary>
    void System.IDisposable.Dispose() {
        if ((false 
                    == (LookAheadEnumerator<T>._Disposed == this._state))) {
            this._inner.Dispose();
            this._state = LookAheadEnumerator<T>._Disposed;
        }
    }
    void _Enqueue(T item) {
        if ((this._queueCount == this._queue.Length)) {
            T[] arr = new T[((int)((this._queue.Length 
                        * (1 + LookAheadEnumerator<T>._GrowthFactor))))];
            if (((this._queueHead + this._queueCount) 
                        <= this._queue.Length)) {
                System.Array.Copy(this._queue, arr, this._queueCount);
                this._queueHead = 0;
                arr[this._queueCount] = item;
                this._queueCount = (this._queueCount + 1);
                this._queue = arr;
            }
            else {
                System.Array.Copy(this._queue, this._queueHead, arr, 0, (this._queue.Length - this._queueHead));
                System.Array.Copy(this._queue, 0, arr, (this._queue.Length - this._queueHead), this._queueHead);
                this._queueHead = 0;
                arr[this._queueCount] = item;
                this._queueCount = (this._queueCount + 1);
                this._queue = arr;
            }
        }
        else {
            this._queue[((this._queueHead + this._queueCount) 
                        % this._queue.Length)] = item;
            this._queueCount = (this._queueCount + 1);
        }
    }
    T _Dequeue() {
        if ((0 == this._queueCount)) {
            throw new InvalidOperationException("The queue is empty");
        }
        T result = this._queue[this._queueHead];
        this._queue[this._queueHead] = default(T);
        this._queueHead = (this._queueHead + 1);
        this._queueHead = (this._queueHead % this._queue.Length);
        this._queueCount = (this._queueCount - 1);
        return result;
    }
    #endregion
}
[System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
internal class LookAheadEnumeratorEnumerable<T> : object, IEnumerable<T>
 {
    private LookAheadEnumerator<T> _outer;
    public LookAheadEnumeratorEnumerable(LookAheadEnumerator<T> outer) {
        this._outer = outer;
    }
    public IEnumerator<T> GetEnumerator() {
        // for some reason VB was resolving new as AddressOf, so use this.
        LookAheadEnumeratorEnumerator<T> result = ((LookAheadEnumeratorEnumerator<T>)(System.Activator.CreateInstance(typeof(LookAheadEnumeratorEnumerator<T>), this._outer)));
        return result;
    }
    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
        return this.GetEnumerator();
    }
}
[System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
internal class LookAheadEnumeratorEnumerator<T> : object, IEnumerator<T>
 {
    private const int _NotStarted = -2;
    private const int _Ended = -1;
    private const int _Disposed = -3;
    private LookAheadEnumerator<T> _outer;
    private int _index;
    private T _current;
    public LookAheadEnumeratorEnumerator(LookAheadEnumerator<T> outer) {
        this._outer = outer;
        if (this._outer.IsEnumerating) {
            this._current = this._outer.Current;
        }
        this._index = LookAheadEnumeratorEnumerator<T>._NotStarted;
    }
    public T Current {
        get {
            if ((0 > this._index)) {
                if ((this._index == LookAheadEnumeratorEnumerator<T>._NotStarted)) {
                    throw new InvalidOperationException("The cursor is before the start of the enumeration.");
                }
                if ((this._index == LookAheadEnumeratorEnumerator<T>._Ended)) {
                    throw new InvalidOperationException("The cursor is after the end of the enumeration.");
                }
                throw new ObjectDisposedException(typeof(LookAheadEnumeratorEnumerator<T>).Name);
            }
            return this._current;
        }
    }
    object System.Collections.IEnumerator.Current {
        get {
            return this.Current;
        }
    }
    void System.IDisposable.Dispose() {
        this._index = LookAheadEnumeratorEnumerator<T>._Disposed;
    }
    bool System.Collections.IEnumerator.MoveNext() {
        T value;
        if ((0 > this._index)) {
            if ((this._index == LookAheadEnumeratorEnumerator<T>._Disposed)) {
                throw new ObjectDisposedException(typeof(LookAheadEnumeratorEnumerator<T>).Name);
            }
            if ((this._index == LookAheadEnumeratorEnumerator<T>._Ended)) {
                return false;
            }
            this._index = -1;
        }
        this._index = (this._index + 1);
        if ((false == this._outer.TryPeek(this._index, out value))) {
            this._index = LookAheadEnumeratorEnumerator<T>._Ended;
            return false;
        }
        this._current = value;
        return true;
    }
    void System.Collections.IEnumerator.Reset() {
        this._index = LookAheadEnumeratorEnumerator<T>._NotStarted;
    }
}
