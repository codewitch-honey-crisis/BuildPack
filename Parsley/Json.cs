//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;


/// <summary>Parses the following grammar:
/// Json= Object | Array;
/// Object= "{" [ Field { "," Field } ] "}";
/// Field= string ":" Value;
/// Array= "[" [ Value { "," Value } ] "]";
/// {Value}= string | number | Object | Array | Boolean | null;
/// Boolean= true | false;
/// number= '\-?(0|[1-9][0-9]*)(\.[0-9]+)?([Ee][\+\-]?[0-9]+)?';
/// string= '"([^\n"\\]|\\([btrnf"\\/]|(u[A-Fa-f]{4})))*"';
/// true= "true";
/// false= "false";
/// null= "null";
/// {lbracket}= "[";
/// {rbracket}= "]";
/// {lbrace}= "{";
/// {rbrace}= "}";
/// {colon}= ":";
/// {comma}= ",";
/// (whitespace)= '[\n\r\t ]+';
/// </summary>
/// <remarks>The rules for the factored grammar are as follows:
/// Json -> Object
/// Json -> Array
/// Object -> lbrace Field ObjectList rbrace
/// Object -> lbrace Field rbrace
/// Object -> lbrace rbrace
/// Field -> string colon Value
/// Array -> lbracket Value ArrayList rbracket
/// Array -> lbracket Value rbracket
/// Array -> lbracket rbracket
/// Value -> string
/// Value -> number
/// Value -> Object
/// Value -> Array
/// Value -> Boolean
/// Value -> null
/// Boolean -> true
/// Boolean -> false
/// ObjectList -> comma Field ObjectListRightAssoc
/// ArrayList -> comma Value ArrayListRightAssoc
/// ObjectListRightAssoc -> comma Field ObjectListRightAssoc
/// ObjectListRightAssoc ->
/// ArrayListRightAssoc -> comma Value ArrayListRightAssoc
/// ArrayListRightAssoc ->
/// </remarks>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
internal partial class Json {
    internal const int ErrorSymbol = -1;
    internal const int EosSymbol = -2;
    public const int Json = 0;
    public const int Object = 1;
    public const int Field = 2;
    public const int Array = 3;
    public const int Value = 4;
    public const int Boolean = 5;
    public const int ObjectList = 6;
    public const int ArrayList = 7;
    public const int ObjectListRightAssoc = 8;
    public const int ArrayListRightAssoc = 9;
    public const int lbrace = 10;
    public const int rbrace = 11;
    public const int @string = 12;
    public const int colon = 13;
    public const int lbracket = 14;
    public const int rbracket = 15;
    public const int number = 16;
    public const int @null = 17;
    public const int @true = 18;
    public const int @false = 19;
    public const int comma = 20;
    public const int whitespace = 21;
    private static ParseNode _ParseJson(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Json -> Object
        if ((Json.lbrace == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = Json._ParseObject(context);
            return new ParseNode(Json.Json, "Json", children, line, column, position);
        }
        // Json -> Array
        if ((Json.lbracket == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = Json._ParseArray(context);
            return new ParseNode(Json.Json, "Json", children, line, column, position);
        }
        context.Error("Expecting lbrace or lbracket");
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Json= Object | Array
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Json -> Object
    /// Json -> Array
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseJson(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return Json._ParseJson(context);
    }
    /// <summary>
    /// Parses a production of the form:
    /// Json= Object | Array
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Json -> Object
    /// Json -> Array
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode Parse(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return Json._ParseJson(context);
    }
    private static ParseNode _ParseObject(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Object -> lbrace Field ObjectList rbrace
        // Object -> lbrace Field rbrace
        // Object -> lbrace rbrace
        if ((Json.lbrace == context.SymbolId)) {
            ParserContext pc2;
            System.Exception lastExcept = null;
            pc2 = context.GetLookAhead();
            pc2.EnsureStarted();
            // Object -> lbrace Field ObjectList rbrace
            try {
                if ((Json.lbrace == pc2.SymbolId)) {
                    System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                    pc2.Advance();
                    children.Add(Json._ParseField(pc2));
                    children.AddRange(Json._ParseObjectList(pc2).Children);
                    if ((Json.rbrace == pc2.SymbolId)) {
                        pc2.Advance();
                    }
                    int adv = 0;
                    for (
                    ; (adv < pc2.AdvanceCount); 
                    ) {
                        context.Advance();
                        adv = (adv + 1);
                    }
                    return new ParseNode(Json.Object, "Object", children.ToArray(), line, column, position);
                }
                context.Error("Expecting lbrace");
            }
            catch (SyntaxException ex) {
                if ((lastExcept == null)) {
                    lastExcept = ex;
                }
            }
            finally {

            }
            pc2 = context.GetLookAhead();
            pc2.EnsureStarted();
            // Object -> lbrace Field rbrace
            try {
                if ((Json.lbrace == pc2.SymbolId)) {
                    System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                    pc2.Advance();
                    children.Add(Json._ParseField(pc2));
                    if ((Json.rbrace == pc2.SymbolId)) {
                        pc2.Advance();
                    }
                    int adv = 0;
                    for (
                    ; (adv < pc2.AdvanceCount); 
                    ) {
                        context.Advance();
                        adv = (adv + 1);
                    }
                    return new ParseNode(Json.Object, "Object", children.ToArray(), line, column, position);
                }
                context.Error("Expecting lbrace");
            }
            catch (SyntaxException ex) {
                if ((lastExcept == null)) {
                    lastExcept = ex;
                }
            }
            finally {

            }
            pc2 = context.GetLookAhead();
            pc2.EnsureStarted();
            // Object -> lbrace rbrace
            try {
                if ((Json.lbrace == pc2.SymbolId)) {
                    System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                    pc2.Advance();
                    if ((Json.rbrace == pc2.SymbolId)) {
                        pc2.Advance();
                    }
                    int adv = 0;
                    for (
                    ; (adv < pc2.AdvanceCount); 
                    ) {
                        context.Advance();
                        adv = (adv + 1);
                    }
                    return new ParseNode(Json.Object, "Object", children.ToArray(), line, column, position);
                }
                context.Error("Expecting lbrace");
            }
            catch (SyntaxException ex) {
                if ((lastExcept == null)) {
                    lastExcept = ex;
                }
            }
            finally {

            }
            throw lastExcept;
        }
        context.Error("Expecting lbrace");
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Object= "{" [ Field { "," Field } ] "}"
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Object -> lbrace Field ObjectList rbrace
    /// Object -> lbrace Field rbrace
    /// Object -> lbrace rbrace
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseObject(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return Json._ParseObject(context);
    }
    private static ParseNode _ParseField(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Field -> string colon Value
        if ((Json.@string == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            children.Add(new ParseNode(Json.@string, "string", context.Value, line, column, position));
            context.Advance();
            if ((Json.colon == context.SymbolId)) {
                context.Advance();
            }
            children.AddRange(Json._ParseValue(context).Children);
            return new ParseNode(Json.Field, "Field", children.ToArray(), line, column, position);
        }
        context.Error("Expecting string");
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Field= string ":" Value
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Field -> string colon Value
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseField(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return Json._ParseField(context);
    }
    private static ParseNode _ParseArray(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Array -> lbracket Value ArrayList rbracket
        // Array -> lbracket Value rbracket
        // Array -> lbracket rbracket
        if ((Json.lbracket == context.SymbolId)) {
            ParserContext pc2;
            System.Exception lastExcept = null;
            pc2 = context.GetLookAhead();
            pc2.EnsureStarted();
            // Array -> lbracket Value ArrayList rbracket
            try {
                if ((Json.lbracket == pc2.SymbolId)) {
                    System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                    pc2.Advance();
                    children.AddRange(Json._ParseValue(pc2).Children);
                    children.AddRange(Json._ParseArrayList(pc2).Children);
                    if ((Json.rbracket == pc2.SymbolId)) {
                        pc2.Advance();
                    }
                    int adv = 0;
                    for (
                    ; (adv < pc2.AdvanceCount); 
                    ) {
                        context.Advance();
                        adv = (adv + 1);
                    }
                    return new ParseNode(Json.Array, "Array", children.ToArray(), line, column, position);
                }
                context.Error("Expecting lbracket");
            }
            catch (SyntaxException ex) {
                if ((lastExcept == null)) {
                    lastExcept = ex;
                }
            }
            finally {

            }
            pc2 = context.GetLookAhead();
            pc2.EnsureStarted();
            // Array -> lbracket Value rbracket
            try {
                if ((Json.lbracket == pc2.SymbolId)) {
                    System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                    pc2.Advance();
                    children.AddRange(Json._ParseValue(pc2).Children);
                    if ((Json.rbracket == pc2.SymbolId)) {
                        pc2.Advance();
                    }
                    int adv = 0;
                    for (
                    ; (adv < pc2.AdvanceCount); 
                    ) {
                        context.Advance();
                        adv = (adv + 1);
                    }
                    return new ParseNode(Json.Array, "Array", children.ToArray(), line, column, position);
                }
                context.Error("Expecting lbracket");
            }
            catch (SyntaxException ex) {
                if ((lastExcept == null)) {
                    lastExcept = ex;
                }
            }
            finally {

            }
            pc2 = context.GetLookAhead();
            pc2.EnsureStarted();
            // Array -> lbracket rbracket
            try {
                if ((Json.lbracket == pc2.SymbolId)) {
                    System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                    pc2.Advance();
                    if ((Json.rbracket == pc2.SymbolId)) {
                        pc2.Advance();
                    }
                    int adv = 0;
                    for (
                    ; (adv < pc2.AdvanceCount); 
                    ) {
                        context.Advance();
                        adv = (adv + 1);
                    }
                    return new ParseNode(Json.Array, "Array", children.ToArray(), line, column, position);
                }
                context.Error("Expecting lbracket");
            }
            catch (SyntaxException ex) {
                if ((lastExcept == null)) {
                    lastExcept = ex;
                }
            }
            finally {

            }
            throw lastExcept;
        }
        context.Error("Expecting lbracket");
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Array= "[" [ Value { "," Value } ] "]"
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Array -> lbracket Value ArrayList rbracket
    /// Array -> lbracket Value rbracket
    /// Array -> lbracket rbracket
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseArray(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return Json._ParseArray(context);
    }
    private static ParseNode _ParseValue(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Value -> string
        if ((Json.@string == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = new ParseNode(Json.@string, "string", context.Value, line, column, position);
            context.Advance();
            return new ParseNode(Json.Value, "Value", children, line, column, position);
        }
        // Value -> number
        if ((Json.number == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = new ParseNode(Json.number, "number", context.Value, line, column, position);
            context.Advance();
            return new ParseNode(Json.Value, "Value", children, line, column, position);
        }
        // Value -> Object
        if ((Json.lbrace == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = Json._ParseObject(context);
            return new ParseNode(Json.Value, "Value", children, line, column, position);
        }
        // Value -> Array
        if ((Json.lbracket == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = Json._ParseArray(context);
            return new ParseNode(Json.Value, "Value", children, line, column, position);
        }
        // Value -> Boolean
        if (((Json.@true == context.SymbolId) 
                    || (Json.@false == context.SymbolId))) {
            ParseNode[] children = new ParseNode[1];
            children[0] = Json._ParseBoolean(context);
            return new ParseNode(Json.Value, "Value", children, line, column, position);
        }
        // Value -> null
        if ((Json.@null == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = new ParseNode(Json.@null, "null", context.Value, line, column, position);
            context.Advance();
            return new ParseNode(Json.Value, "Value", children, line, column, position);
        }
        context.Error("Expecting string, number, lbrace, lbracket, true, false, or null");
        return null;
    }
    private static ParseNode _ParseBoolean(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // Boolean -> true
        if ((Json.@true == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = new ParseNode(Json.@true, "true", context.Value, line, column, position);
            context.Advance();
            return new ParseNode(Json.Boolean, "Boolean", children, line, column, position);
        }
        // Boolean -> false
        if ((Json.@false == context.SymbolId)) {
            ParseNode[] children = new ParseNode[1];
            children[0] = new ParseNode(Json.@false, "false", context.Value, line, column, position);
            context.Advance();
            return new ParseNode(Json.Boolean, "Boolean", children, line, column, position);
        }
        context.Error("Expecting true or false");
        return null;
    }
    /// <summary>
    /// Parses a production of the form:
    /// Boolean= true | false
    /// </summary>
    /// <remarks>
    /// The production rules are:
    /// Boolean -> true
    /// Boolean -> false
    /// </remarks>
    /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
    public static ParseNode ParseBoolean(System.Collections.Generic.IEnumerable<Token> tokenizer) {
        ParserContext context = new ParserContext(tokenizer);
        context.EnsureStarted();
        return Json._ParseBoolean(context);
    }
    private static ParseNode _ParseObjectList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // ObjectList -> comma Field ObjectListRightAssoc
        if ((Json.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            context.Advance();
            children.Add(Json._ParseField(context));
            children.AddRange(Json._ParseObjectListRightAssoc(context).Children);
            return new ParseNode(Json.ObjectList, "ObjectList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting comma");
        return null;
    }
    private static ParseNode _ParseArrayList(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // ArrayList -> comma Value ArrayListRightAssoc
        if ((Json.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            context.Advance();
            children.AddRange(Json._ParseValue(context).Children);
            children.AddRange(Json._ParseArrayListRightAssoc(context).Children);
            return new ParseNode(Json.ArrayList, "ArrayList", children.ToArray(), line, column, position);
        }
        context.Error("Expecting comma");
        return null;
    }
    private static ParseNode _ParseObjectListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // ObjectListRightAssoc -> comma Field ObjectListRightAssoc
        if ((Json.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            context.Advance();
            children.Add(Json._ParseField(context));
            children.AddRange(Json._ParseObjectListRightAssoc(context).Children);
            return new ParseNode(Json.ObjectListRightAssoc, "ObjectListRightAssoc", children.ToArray(), line, column, position);
        }
        // ObjectListRightAssoc ->
        if ((Json.rbrace == context.SymbolId)) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(Json.ObjectListRightAssoc, "ObjectListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting comma or rbrace");
        return null;
    }
    private static ParseNode _ParseArrayListRightAssoc(ParserContext context) {
        int line = context.Line;
        int column = context.Column;
        long position = context.Position;
        // ArrayListRightAssoc -> comma Value ArrayListRightAssoc
        if ((Json.comma == context.SymbolId)) {
            System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
            context.Advance();
            children.AddRange(Json._ParseValue(context).Children);
            children.AddRange(Json._ParseArrayListRightAssoc(context).Children);
            return new ParseNode(Json.ArrayListRightAssoc, "ArrayListRightAssoc", children.ToArray(), line, column, position);
        }
        // ArrayListRightAssoc ->
        if ((Json.rbracket == context.SymbolId)) {
            ParseNode[] children = new ParseNode[0];
            return new ParseNode(Json.ArrayListRightAssoc, "ArrayListRightAssoc", children, line, column, position);
        }
        context.Error("Expecting comma or rbracket");
        return null;
    }
}
