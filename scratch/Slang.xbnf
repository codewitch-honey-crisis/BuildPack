// Slang.xbnf
// This is the XBNF spec for Slang (gplex version - unicode enabled)
// TODO: honestly not sure if left vs right associativity matters here, so we're ignoring it
// it has worked thus far in the past so I have no reason to change it but I'm leaving this
// to do here in case something eventually happens to blow up.
Expression<start>=AssignExpression;
RelationalExpression = TermExpression { ("<"|"<="|">"|">=") TermExpression };
EqualityExpression = RelationalExpression { ("=="|"!=") RelationalExpression };
BitwiseAndExpression = EqualityExpression { "&" EqualityExpression };
BitwiseOrExpression = BitwiseAndExpression { "|" BitwiseAndExpression };
AndExpression= BitwiseOrExpression { "&&" BitwiseOrExpression };
OrExpression= AndExpression { "||" AndExpression };
AssignExpression= OrExpression { ("="|"+="|"-="|"*="|"/="|"%="|"&="|"|=") OrExpression };
TermExpression= FactorExpression { ("+"|"-") FactorExpression };
FactorExpression= UnaryExpression { ("*"|"/"|"%") UnaryExpression };
MemberFieldRef = "." Identifier;
MemberInvokeRef = "(" [ MethodArg { "," MethodArg } ] ")";
MemberIndexerRef = "[" Expression { "," Expression } "]";
MemberAnyRef<collapsed> = MemberFieldRef | MemberInvokeRef | MemberIndexerRef;
MethodArg = [ outKeyword | refKeyword ] Expression;
TypeRef = Type;
IntrinsicType=	boolType	|
				charType	|
				stringType	|
				floatType	|
				doubleType	|
				decimalType	|
				sbyteType	|
				byteType	|
				shortType	|
				ushortType	|
				intType		|
				uintType	|
				longType	|
				ulongType	|
				objectType	;
TypeBase = (identifier { "."  identifier }) | IntrinsicType;
Type=TypeElement { TypeArraySpec };
TypeElement = TypeBase [ TypeGenericPart ];
TypeGenericPart= "<" [ Type { "," Type } ] ">";
TypeArraySpec= "[" { ArraySpecRank } "]";
TypeArraySpecRank = comma;
CastExpression<virtual,firsts="lparen"> { 
	return _ParseCastExpression(context);
}
// much easier to code this as a virtual
ArraySpec<virtual,firsts="lbracket"> {
	return _ParseArraySpec(context);
}
NewExpression= newObj TypeElement ( NewObjectPart | NewArrayPart );
NewObjectPart<collapsed>= "(" [ Expression { "," Expression } ] ")";
NewArrayPart<collapsed>= ArraySpec;

// this is necessary so we can get Parsley to generate a 
// method called ParseTypeCastExpressionPart() which we use
// when resolving casts
TypeCastExpressionPart<include,collapsed>= Type ")"; 
ArraySpecExpressionList<include,collapsed>= Expression { "," Expression } "]";
ArrayInitializer<include>= "=" "{" [ Expression { "," Expression } ] "}";
SubExpression<collapsed> = "(" Expression ")" : where { return !_IsCastExpression(context);}
// use the where clause to override first first conflict:
UnaryExpression= ("+"|"-"|"!") UnaryExpression | ("++"|"--") PrimaryExpression | SubExpression | PrimaryExpression : where { return true;}
PrimaryExpression=	
		( Identifier | IntrinsicType )	{ MemberAnyRef }	|
		verbatimStringLiteral { MemberAnyRef}				|
		characterLiteral { MemberAnyRef }					|
		integerLiteral { MemberAnyRef}						| 
		floatLiteral { MemberAnyRef}						|
		stringLiteral  { MemberAnyRef}						|
		boolLiteral { MemberAnyRef}							|
		nullLiteral											|
		CastExpression										|
		typeOf "(" Type ")"	{ MemberAnyRef }				|
		nameOf "(" Identifier ")" { MemberAnyRef }			|
		defaultOf "(" Type ")" { MemberAnyRef }				|
		NewExpression { MemberAnyRef }						|
		thisRef { MemberAnyRef }							|
		baseRef { MemberAnyRef }							;

		
// Identifier exists as a non-terminal solely to attach a semantic constraint to identifiers.
// we collapse it because we don't need it in the final parse tree but in the grammar 
// we have to refer to "Identifier" instead of identifier or verbatimIdentifer.
Identifier<collapsed> = verbatimIdentifier | identifier : where { return !Keywords.Contains(context.Value); }

// be careful about the order of the terminals.
// remember they have priorities in the final lexer

verbatimIdentifier='@(_|[[:IsLetter:]])(_|[[:IsLetterOrDigit:]])*';
// begin keywords
outKeyword="out";
refKeyword="ref";
typeOf="typeof";
nameOf="nameOf";
defaultOf="default";
newObj="new";
stringType="string";
boolType="bool";
charType="char";
floatType="float";
doubleType="double";
decimalType="decimal";
sbyteType="sbyte";
byteType="byte";
shortType="short";
ushortType="ushort";
intType="int";
uintType="uint";
longType="long";
ulongType="ulong";
objectType="object";
boolLiteral = "true|false";
nullLiteral = "null";
thisRef = "this";
baseRef = "base";
verbatimStringLiteral='@"([^"|""])*"';
identifier='(_|[[:IsLetter:]])(_|[[:IsLetterOrDigit:]])*';
stringLiteral='"([^\\"\'\a\b\f\n\r\t\v\0]|\\[^\r\n]|\\[0-7]{3}|\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}|\\U[0-9A-Fa-f]{8})*"';
characterLiteral='[\u0027]([^\\"\'\a\b\f\n\r\t\v\0]|\\[^\r\n]|\\[0-7]{3}|\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}|\\U[0-9A-Fa-f]{8})[\u0027]';
lte="<=";
lt="<";
gte=">=";
gt=">";
eqEq="==";
notEq="!=";
eq="=";
inc="++";
addAssign="+=";
add="+";
dec="--";
subAssign="-=";
sub="-";
mulAssign="*=";
mul="*";
divAssign="/=";
div="/";
modAssign="%=";
mod="%";
and="&&";
bitwiseAndAssign="&=";
bitwiseAnd="&";
or="||";
bitwiseOrAssign="|=";
bitwiseOr="|";
not="!";
lbracket="[";
rbracket="]";
lparen="(";
rparen=")";
lbrace="{";
rbrace="}";
comma=",";
colonColon="::";
colon=":";
semi=";";
dot=".";
integerLiteral = '(0x[0-9A-Fa-f]{1,16}|([0-9]+))([Uu][Ll]?|[Ll][Uu]?)?';
floatLiteral= '(([0-9]+)(\.[0-9]+)?([Ee][\+\-]?[0-9]+)?[DdMmFf]?)|((\.[0-9]+)([Ee][\+\-]?[0-9]+)?[DdMmFf]?)';
directive<blockEnd="\n">='#[ \t]*[a-z]+';
lineComment<hidden>='\/\/[^\n]*';
blockComment<hidden,blockEnd="*/">="/*";
whitespace<hidden>='[ \t\r\n\v\f]+';
// helpers
{
	static HashSet<string> Keywords=_BuildKeywords();
	static HashSet<string> _BuildKeywords() 
	{
		var result = new HashSet<string>();
		string[] sa = "abstract|as|ascending|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|descending|do|double|dynamic|else|enum|equals|explicit|extern|event|false|finally|fixed|float|for|foreach|get|global|goto|if|implicit|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|partial|private|protected|public|readonly|ref|return|sbyte|sealed|set|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|var|virtual|void|volatile|while|yield".Split(new char[] {'|'});
		
		for(var i = 0;i<sa.Length;++i) 
			result.Add(sa[i]);
		
		return result;
	}
	static ParseNode _ParseCastExpression(ParserContext context) {
		int line = context.Line;
		int column = context.Column;
		long position = context.Position;

		if("("!=context.Value)
			context.Error("Expecting ( as start of expression or cast");
		ParseNode lp = new ParseNode(SlangParser.lparen, "lparen", context.Value, context.Line, context.Column, context.Position);
		context.Advance();
		ParseNode type = ParseTypeCastExpressionPart(context);
		ParseNode expr = ParseExpression(context);
		return new ParseNode(SlangParser.CastExpression, "CastExpression", new ParseNode[] {type,expr}, line, column, position);
	}
	static ParseNode _ParseArraySpec(ParserContext context) 
	{
		int line = context.Line;
        int column = context.Column;
        long position = context.Position;
		if("["!=context.Value)
			context.Error("Expecting start of array spec");
		ParseNode lb = null;
		ParseNode expr = null;
		ParseNode init = null;
		ParserContext pc = context.GetLookAhead(true);
		pc.Advance();
		if("]"!=pc.Value) 
		{
			lb = new ParseNode(SlangParser.lbracket, "lbracket", context.Value, context.Line, context.Column, context.Position);
			context.Advance();
			expr = ParseArraySpecExpressionList(context);
			return new ParseNode(SlangParser.ArraySpec,"ArraySpec", new ParseNode[] {expr },line,column,position);
		} else {
			expr=ParseTypeArraySpec(context);
			init=ParseArrayInitializer(context);
			return new ParseNode(SlangParser.ArraySpec,"ArraySpec", new ParseNode[] {expr ,init},line,column,position);
		}
	}
	static bool _IsCastExpression(ParserContext context) {
		context = context.GetLookAhead(true);
		try 
		{
			if("("!=context.Value)
				return false;
			context.Advance();
			ParseNode type = ParseTypeCastExpressionPart(context);
			ParseNode expr = ParseExpression(context);
			return true;
		}
		catch(Exception ex) {
		
		}
		return false;
	}
}