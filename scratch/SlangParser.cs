//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace CD {
    using System;
    using System.Collections.Generic;
    
    /// <summary>Parses the following grammar:
    /// Term= Factor { ( "+" | "-" ) Factor };
    /// Factor= Unary { ( "*" | "/" ) Unary };
    /// Unary= ( "+" | "-" ) Unary | Leaf;
    /// Leaf= Identifier | verbatimStringLiteral | integerLiteral | floatLiteral | stringLiteral | "(" Term ")";
    /// Identifier= verbatimIdentifier | identifier;
    /// verbatimIdentifier= '@(_|[[:IsLetter:]])(_|[[:IsLetterOrDigit:]])*';
    /// verbatimStringLiteral= '@"([^"|""])*"';
    /// keyword= 'abstract|as|ascending|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|descending|do|double|dynamic|else|enum|equals|explicit|extern|event|false|finally|fixed|float|for|foreach|get|global|goto|if|implicit|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|partial|private|protected|public|readonly|ref|return|sbyte|sealed|set|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|var|virtual|void|volatile|while|yield';
    /// identifier= '(_|[[:IsLetter:]])(_|[[:IsLetterOrDigit:]])*';
    /// stringLiteral= '"([^\\"\'\a\b\f\n\r\t\v\0]|\\[^\r\n]|\\[0-7]{3}|\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}|\\U[0-9A-Fa-f]{8})*"';
    /// (lineComment)= '\/\/[^\n]*';
    /// (blockComment)= "/*";
    /// characterLiteral= '[\u0027]([^\\"\'\a\b\f\n\r\t\v\0]|\\[^\r\n]|\\[0-7]{3}|\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}|\\U[0-9A-Fa-f]{8})[\u0027]';
    /// (whitespace)= '[ \t\r\n\v\f]+';
    /// lte= "<=";
    /// lt= "<";
    /// gte= ">=";
    /// gt= ">";
    /// eqEq= "==";
    /// notEq= "!=";
    /// eq= "=";
    /// inc= "++";
    /// addAssign= "+=";
    /// add= "+";
    /// dec= "--";
    /// subAssign= "-=";
    /// sub= "-";
    /// mulAssign= "*=";
    /// mul= "*";
    /// divAssign= "/=";
    /// div= "/";
    /// modAssign= "%=";
    /// mod= "%";
    /// and= "&&";
    /// bitwiseAndAssign= "&=";
    /// bitwiseAnd= "&";
    /// or= "||";
    /// bitwiseOrAssign= "|=";
    /// bitwiseOr= "|";
    /// not= "!";
    /// lbracket= "[";
    /// rbracket= "]";
    /// lparen= "(";
    /// rparen= ")";
    /// lbrace= "{";
    /// rbrace= "}";
    /// comma= ",";
    /// colonColon= "::";
    /// colon= ":";
    /// semi= ";";
    /// dot= ".";
    /// integerLiteral= '(0x[0-9A-Fa-f]{1,16}|(0|[1-9][0-9]*))([Uu][Ll]?|[Ll][Uu]?)?';
    /// floatLiteral= '((0|[1-9][0-9]*)(\.[0-9]+)?([Ee][\+\-]?[0-9]+)?[DdMmFf]?)|((\.[0-9]+)([Ee][\+\-]?[0-9]+)?[DdMmFf]?)';
    /// directive= '#[ \t]*[a-z]+[ \t]*';
    /// </summary>
    /// <remarks>The rules for the factored grammar are as follows:
    /// Unary -> add Unary
    /// Unary -> sub Unary
    /// Unary -> Leaf
    /// Leaf -> Identifier
    /// Leaf -> verbatimStringLiteral
    /// Leaf -> integerLiteral
    /// Leaf -> floatLiteral
    /// Leaf -> stringLiteral
    /// Leaf -> lparen Term rparen
    /// Identifier -> verbatimIdentifier
    /// Identifier -> identifier
    /// TermList -> add Factor TermListRightAssoc TermListRightAssoc2
    /// TermList -> sub Factor TermListRightAssoc TermListRightAssoc2
    /// FactorList -> mul Unary FactorListRightAssoc FactorListRightAssoc2
    /// FactorList -> div Unary FactorListRightAssoc FactorListRightAssoc2
    /// TermListRightAssoc -> add Factor TermListRightAssoc
    /// TermListRightAssoc ->
    /// FactorListRightAssoc -> mul Unary FactorListRightAssoc
    /// FactorListRightAssoc ->
    /// Term -> Factor TermPart
    /// TermPart -> TermList
    /// TermPart ->
    /// Factor -> Unary FactorPart
    /// FactorPart -> FactorList
    /// FactorPart ->
    /// TermListRightAssoc2 -> sub Factor TermListRightAssoc2
    /// TermListRightAssoc2 ->
    /// FactorListRightAssoc2 -> div Unary FactorListRightAssoc2
    /// FactorListRightAssoc2 ->
    /// </remarks>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
    internal partial class SlangParser {
        internal const int ErrorSymbol = -1;
        internal const int EosSymbol = -2;
        public const int Unary = 0;
        public const int Leaf = 1;
        public const int Identifier = 2;
        public const int TermList = 3;
        public const int FactorList = 4;
        public const int TermListRightAssoc = 5;
        public const int FactorListRightAssoc = 6;
        public const int Term = 7;
        public const int TermPart = 8;
        public const int Factor = 9;
        public const int FactorPart = 10;
        public const int TermListRightAssoc2 = 11;
        public const int FactorListRightAssoc2 = 12;
        public const int add = 13;
        public const int sub = 14;
        public const int verbatimStringLiteral = 15;
        public const int integerLiteral = 16;
        public const int floatLiteral = 17;
        public const int stringLiteral = 18;
        public const int lparen = 19;
        public const int rparen = 20;
        public const int verbatimIdentifier = 21;
        public const int identifier2 = 22;
        public const int mul = 23;
        public const int div = 24;
        public const int lineComment = 25;
        public const int blockComment = 26;
        public const int whitespace = 27;
        public const int directive = 28;
        static HashSet<string> Keywords = CD.SlangParser._BuildKeywords();
        static HashSet<string> _BuildKeywords() {
            HashSet<string> result = new HashSet<string>();
            string[] sa = @"abstract|as|ascending|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|descending|do|double|dynamic|else|enum|equals|explicit|extern|event|false|finally|fixed|float|for|foreach|get|global|goto|if|implicit|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|partial|private|protected|public|readonly|ref|return|sbyte|sealed|set|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|var|virtual|void|volatile|while|yield".Split(new char[] {
                        '|'});
            for (int i = 0; (i < sa.Length); i = (i + 1)) {
                result.Add(sa[i]);
            }
            return result;
        }
        private static ParseNode _ParseUnary(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // Unary -> add Unary
            if ((SlangParser.add == context.SymbolId)) {
                ParseNode[] children = new ParseNode[2];
                children[0] = new ParseNode(SlangParser.add, "add", context.Value, line, column, position);
                context.Advance();
                children[1] = SlangParser._ParseUnary(context);
                return new ParseNode(SlangParser.Unary, "Unary", children, line, column, position);
            }
            // Unary -> sub Unary
            if ((SlangParser.sub == context.SymbolId)) {
                ParseNode[] children = new ParseNode[2];
                children[0] = new ParseNode(SlangParser.sub, "sub", context.Value, line, column, position);
                context.Advance();
                children[1] = SlangParser._ParseUnary(context);
                return new ParseNode(SlangParser.Unary, "Unary", children, line, column, position);
            }
            // Unary -> Leaf
            if ((((((((SlangParser.verbatimIdentifier == context.SymbolId) 
                        || (SlangParser.identifier2 == context.SymbolId)) 
                        || (SlangParser.verbatimStringLiteral == context.SymbolId)) 
                        || (SlangParser.integerLiteral == context.SymbolId)) 
                        || (SlangParser.floatLiteral == context.SymbolId)) 
                        || (SlangParser.stringLiteral == context.SymbolId)) 
                        || (SlangParser.lparen == context.SymbolId))) {
                ParseNode[] children = new ParseNode[1];
                children[0] = SlangParser._ParseLeaf(context);
                return new ParseNode(SlangParser.Unary, "Unary", children, line, column, position);
            }
            context.Error("Expecting add, sub, verbatimIdentifier, identifier, verbatimStringLiteral, intege" +
                    "rLiteral, floatLiteral, stringLiteral, or lparen");
            return null;
        }
        /// <summary>
        /// Parses a production of the form:
        /// Unary= ( "+" | "-" ) Unary | Leaf
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Unary -> add Unary
        /// Unary -> sub Unary
        /// Unary -> Leaf
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseUnary(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return SlangParser._ParseUnary(context);
        }
        private static ParseNode _ParseLeaf(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // Leaf -> Identifier
            if (((SlangParser.verbatimIdentifier == context.SymbolId) 
                        || (SlangParser.identifier2 == context.SymbolId))) {
                ParseNode[] children = new ParseNode[1];
                children[0] = SlangParser._ParseIdentifier(context);
                return new ParseNode(SlangParser.Leaf, "Leaf", children, line, column, position);
            }
            // Leaf -> verbatimStringLiteral
            if ((SlangParser.verbatimStringLiteral == context.SymbolId)) {
                ParseNode[] children = new ParseNode[1];
                children[0] = new ParseNode(SlangParser.verbatimStringLiteral, "verbatimStringLiteral", context.Value, line, column, position);
                context.Advance();
                return new ParseNode(SlangParser.Leaf, "Leaf", children, line, column, position);
            }
            // Leaf -> integerLiteral
            if ((SlangParser.integerLiteral == context.SymbolId)) {
                ParseNode[] children = new ParseNode[1];
                children[0] = new ParseNode(SlangParser.integerLiteral, "integerLiteral", context.Value, line, column, position);
                context.Advance();
                return new ParseNode(SlangParser.Leaf, "Leaf", children, line, column, position);
            }
            // Leaf -> floatLiteral
            if ((SlangParser.floatLiteral == context.SymbolId)) {
                ParseNode[] children = new ParseNode[1];
                children[0] = new ParseNode(SlangParser.floatLiteral, "floatLiteral", context.Value, line, column, position);
                context.Advance();
                return new ParseNode(SlangParser.Leaf, "Leaf", children, line, column, position);
            }
            // Leaf -> stringLiteral
            if ((SlangParser.stringLiteral == context.SymbolId)) {
                ParseNode[] children = new ParseNode[1];
                children[0] = new ParseNode(SlangParser.stringLiteral, "stringLiteral", context.Value, line, column, position);
                context.Advance();
                return new ParseNode(SlangParser.Leaf, "Leaf", children, line, column, position);
            }
            // Leaf -> lparen Term rparen
            if ((SlangParser.lparen == context.SymbolId)) {
                ParseNode[] children = new ParseNode[3];
                children[0] = new ParseNode(SlangParser.lparen, "lparen", context.Value, line, column, position);
                context.Advance();
                children[1] = SlangParser._ParseTerm(context);
                if ((SlangParser.rparen == context.SymbolId)) {
                    children[2] = new ParseNode(SlangParser.rparen, "rparen", context.Value, line, column, position);
                    context.Advance();
                }
                return new ParseNode(SlangParser.Leaf, "Leaf", children, line, column, position);
            }
            context.Error("Expecting verbatimIdentifier, identifier, verbatimStringLiteral, integerLiteral, " +
                    "floatLiteral, stringLiteral, or lparen");
            return null;
        }
        /// <summary>
        /// Parses a production of the form:
        /// Leaf= Identifier | verbatimStringLiteral | integerLiteral | floatLiteral | stringLiteral | "(" Term ")"
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Leaf -> Identifier
        /// Leaf -> verbatimStringLiteral
        /// Leaf -> integerLiteral
        /// Leaf -> floatLiteral
        /// Leaf -> stringLiteral
        /// Leaf -> lparen Term rparen
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseLeaf(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return SlangParser._ParseLeaf(context);
        }
        private static ParseNode _ParseIdentifier(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // Identifier -> verbatimIdentifier
            if (((SlangParser.verbatimIdentifier == context.SymbolId) 
                        && SlangParser._WhereIdentifier(context.GetLookAhead(true)))) {
                ParseNode[] children = new ParseNode[1];
                children[0] = new ParseNode(SlangParser.verbatimIdentifier, "verbatimIdentifier", context.Value, line, column, position);
                context.Advance();
                return new ParseNode(SlangParser.Identifier, "Identifier", children, line, column, position);
            }
            // Identifier -> identifier
            if (((SlangParser.identifier2 == context.SymbolId) 
                        && SlangParser._WhereIdentifier(context.GetLookAhead(true)))) {
                ParseNode[] children = new ParseNode[1];
                children[0] = new ParseNode(SlangParser.identifier2, "identifier", context.Value, line, column, position);
                context.Advance();
                return new ParseNode(SlangParser.Identifier, "Identifier", children, line, column, position);
            }
            context.Error("Expecting verbatimIdentifier or identifier");
            return null;
        }
        private static bool _WhereIdentifier(ParserContext context) {
            return (false == CD.SlangParser.Keywords.Contains(context.Value));
        }
        /// <summary>
        /// Parses a production of the form:
        /// Identifier= verbatimIdentifier | identifier
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Identifier -> verbatimIdentifier
        /// Identifier -> identifier
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseIdentifier(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return SlangParser._ParseIdentifier(context);
        }
        private static ParseNode _ParseTermList(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // TermList -> add Factor TermListRightAssoc TermListRightAssoc2
            if ((SlangParser.add == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(SlangParser.add, "add", context.Value, line, column, position));
                context.Advance();
                children.Add(SlangParser._ParseFactor(context));
                children.AddRange(SlangParser._ParseTermListRightAssoc(context).Children);
                children.AddRange(SlangParser._ParseTermListRightAssoc2(context).Children);
                return new ParseNode(SlangParser.TermList, "TermList", children.ToArray(), line, column, position);
            }
            // TermList -> sub Factor TermListRightAssoc TermListRightAssoc2
            if ((SlangParser.sub == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(SlangParser.sub, "sub", context.Value, line, column, position));
                context.Advance();
                children.Add(SlangParser._ParseFactor(context));
                children.AddRange(SlangParser._ParseTermListRightAssoc(context).Children);
                children.AddRange(SlangParser._ParseTermListRightAssoc2(context).Children);
                return new ParseNode(SlangParser.TermList, "TermList", children.ToArray(), line, column, position);
            }
            context.Error("Expecting add or sub");
            return null;
        }
        private static ParseNode _ParseFactorList(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // FactorList -> mul Unary FactorListRightAssoc FactorListRightAssoc2
            if ((SlangParser.mul == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(SlangParser.mul, "mul", context.Value, line, column, position));
                context.Advance();
                children.Add(SlangParser._ParseUnary(context));
                children.AddRange(SlangParser._ParseFactorListRightAssoc(context).Children);
                children.AddRange(SlangParser._ParseFactorListRightAssoc2(context).Children);
                return new ParseNode(SlangParser.FactorList, "FactorList", children.ToArray(), line, column, position);
            }
            // FactorList -> div Unary FactorListRightAssoc FactorListRightAssoc2
            if ((SlangParser.div == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(SlangParser.div, "div", context.Value, line, column, position));
                context.Advance();
                children.Add(SlangParser._ParseUnary(context));
                children.AddRange(SlangParser._ParseFactorListRightAssoc(context).Children);
                children.AddRange(SlangParser._ParseFactorListRightAssoc2(context).Children);
                return new ParseNode(SlangParser.FactorList, "FactorList", children.ToArray(), line, column, position);
            }
            context.Error("Expecting mul or div");
            return null;
        }
        private static ParseNode _ParseTermListRightAssoc(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // TermListRightAssoc -> add Factor TermListRightAssoc
            if ((SlangParser.add == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(SlangParser.add, "add", context.Value, line, column, position));
                context.Advance();
                children.Add(SlangParser._ParseFactor(context));
                children.AddRange(SlangParser._ParseTermListRightAssoc(context).Children);
                return new ParseNode(SlangParser.TermListRightAssoc, "TermListRightAssoc", children.ToArray(), line, column, position);
            }
            // TermListRightAssoc ->
            if ((((SlangParser.sub == context.SymbolId) 
                        || (SlangParser.EosSymbol == context.SymbolId)) 
                        || (SlangParser.rparen == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(SlangParser.TermListRightAssoc, "TermListRightAssoc", children, line, column, position);
            }
            context.Error("Expecting add, sub, #EOS, or rparen");
            return null;
        }
        private static ParseNode _ParseFactorListRightAssoc(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // FactorListRightAssoc -> mul Unary FactorListRightAssoc
            if ((SlangParser.mul == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(SlangParser.mul, "mul", context.Value, line, column, position));
                context.Advance();
                children.Add(SlangParser._ParseUnary(context));
                children.AddRange(SlangParser._ParseFactorListRightAssoc(context).Children);
                return new ParseNode(SlangParser.FactorListRightAssoc, "FactorListRightAssoc", children.ToArray(), line, column, position);
            }
            // FactorListRightAssoc ->
            if ((((((SlangParser.div == context.SymbolId) 
                        || (SlangParser.add == context.SymbolId)) 
                        || (SlangParser.sub == context.SymbolId)) 
                        || (SlangParser.EosSymbol == context.SymbolId)) 
                        || (SlangParser.rparen == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(SlangParser.FactorListRightAssoc, "FactorListRightAssoc", children, line, column, position);
            }
            context.Error("Expecting mul, div, add, sub, #EOS, or rparen");
            return null;
        }
        private static ParseNode _ParseTerm(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // Term -> Factor TermPart
            if ((((((((((SlangParser.add == context.SymbolId) 
                        || (SlangParser.sub == context.SymbolId)) 
                        || (SlangParser.verbatimIdentifier == context.SymbolId)) 
                        || (SlangParser.identifier2 == context.SymbolId)) 
                        || (SlangParser.verbatimStringLiteral == context.SymbolId)) 
                        || (SlangParser.integerLiteral == context.SymbolId)) 
                        || (SlangParser.floatLiteral == context.SymbolId)) 
                        || (SlangParser.stringLiteral == context.SymbolId)) 
                        || (SlangParser.lparen == context.SymbolId))) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(SlangParser._ParseFactor(context));
                children.AddRange(SlangParser._ParseTermPart(context).Children);
                return new ParseNode(SlangParser.Term, "Term", children.ToArray(), line, column, position);
            }
            context.Error("Expecting add, sub, verbatimIdentifier, identifier, verbatimStringLiteral, intege" +
                    "rLiteral, floatLiteral, stringLiteral, or lparen");
            return null;
        }
        /// <summary>
        /// Parses a production of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseTerm(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return SlangParser._ParseTerm(context);
        }
        /// <summary>
        /// Parses a production of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode Parse(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return SlangParser._ParseTerm(context);
        }
        private static ParseNode _ParseTermPart(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // TermPart -> TermList
            if (((SlangParser.add == context.SymbolId) 
                        || (SlangParser.sub == context.SymbolId))) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.AddRange(SlangParser._ParseTermList(context).Children);
                return new ParseNode(SlangParser.TermPart, "TermPart", children.ToArray(), line, column, position);
            }
            // TermPart ->
            if (((SlangParser.EosSymbol == context.SymbolId) 
                        || (SlangParser.rparen == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(SlangParser.TermPart, "TermPart", children, line, column, position);
            }
            context.Error("Expecting add, sub, #EOS, or rparen");
            return null;
        }
        private static ParseNode _ParseFactor(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // Factor -> Unary FactorPart
            if ((((((((((SlangParser.add == context.SymbolId) 
                        || (SlangParser.sub == context.SymbolId)) 
                        || (SlangParser.verbatimIdentifier == context.SymbolId)) 
                        || (SlangParser.identifier2 == context.SymbolId)) 
                        || (SlangParser.verbatimStringLiteral == context.SymbolId)) 
                        || (SlangParser.integerLiteral == context.SymbolId)) 
                        || (SlangParser.floatLiteral == context.SymbolId)) 
                        || (SlangParser.stringLiteral == context.SymbolId)) 
                        || (SlangParser.lparen == context.SymbolId))) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(SlangParser._ParseUnary(context));
                children.AddRange(SlangParser._ParseFactorPart(context).Children);
                return new ParseNode(SlangParser.Factor, "Factor", children.ToArray(), line, column, position);
            }
            context.Error("Expecting add, sub, verbatimIdentifier, identifier, verbatimStringLiteral, intege" +
                    "rLiteral, floatLiteral, stringLiteral, or lparen");
            return null;
        }
        /// <summary>
        /// Parses a production of the form:
        /// Factor= Unary { ( "*" | "/" ) Unary }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Factor -> Unary FactorPart
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseFactor(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return SlangParser._ParseFactor(context);
        }
        private static ParseNode _ParseFactorPart(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // FactorPart -> FactorList
            if (((SlangParser.mul == context.SymbolId) 
                        || (SlangParser.div == context.SymbolId))) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.AddRange(SlangParser._ParseFactorList(context).Children);
                return new ParseNode(SlangParser.FactorPart, "FactorPart", children.ToArray(), line, column, position);
            }
            // FactorPart ->
            if (((((SlangParser.add == context.SymbolId) 
                        || (SlangParser.sub == context.SymbolId)) 
                        || (SlangParser.EosSymbol == context.SymbolId)) 
                        || (SlangParser.rparen == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(SlangParser.FactorPart, "FactorPart", children, line, column, position);
            }
            context.Error("Expecting mul, div, add, sub, #EOS, or rparen");
            return null;
        }
        private static ParseNode _ParseTermListRightAssoc2(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // TermListRightAssoc2 -> sub Factor TermListRightAssoc2
            if ((SlangParser.sub == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(SlangParser.sub, "sub", context.Value, line, column, position));
                context.Advance();
                children.Add(SlangParser._ParseFactor(context));
                children.AddRange(SlangParser._ParseTermListRightAssoc2(context).Children);
                return new ParseNode(SlangParser.TermListRightAssoc2, "TermListRightAssoc2", children.ToArray(), line, column, position);
            }
            // TermListRightAssoc2 ->
            if (((SlangParser.EosSymbol == context.SymbolId) 
                        || (SlangParser.rparen == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(SlangParser.TermListRightAssoc2, "TermListRightAssoc2", children, line, column, position);
            }
            context.Error("Expecting sub, #EOS, or rparen");
            return null;
        }
        private static ParseNode _ParseFactorListRightAssoc2(ParserContext context) {
            int line = context.Line;
            int column = context.Column;
            long position = context.Position;
            // FactorListRightAssoc2 -> div Unary FactorListRightAssoc2
            if ((SlangParser.div == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(new ParseNode(SlangParser.div, "div", context.Value, line, column, position));
                context.Advance();
                children.Add(SlangParser._ParseUnary(context));
                children.AddRange(SlangParser._ParseFactorListRightAssoc2(context).Children);
                return new ParseNode(SlangParser.FactorListRightAssoc2, "FactorListRightAssoc2", children.ToArray(), line, column, position);
            }
            // FactorListRightAssoc2 ->
            if (((((SlangParser.add == context.SymbolId) 
                        || (SlangParser.sub == context.SymbolId)) 
                        || (SlangParser.EosSymbol == context.SymbolId)) 
                        || (SlangParser.rparen == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(SlangParser.FactorListRightAssoc2, "FactorListRightAssoc2", children, line, column, position);
            }
            context.Error("Expecting div, add, sub, #EOS, or rparen");
            return null;
        }
    }
    /// <summary>
    /// 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
    internal class SyntaxException : Exception {
        private int _line;
        private int _column;
        private long _position;
        /// <summary>
        /// Creates a syntax exception with the specified arguments
        /// </summary>
        /// <param name="message">The error message</param>
        /// <param name="line">The line where the error occurred</param>
        /// <param name="column">The column where the error occured</param>
        /// <param name="position">The position where the error occured</param>
        public SyntaxException(string message, int line, int column, long position) : 
                base(SyntaxException._GetMessage(message, line, column, position)) {
            this._line = line;
            this._column = column;
            this._position = position;
        }
        /// <summary>
        /// The line where the error occurred
        /// </summary>
        public int Line {
            get {
                return this._line;
            }
        }
        /// <summary>
        /// The column where the error occurred
        /// </summary>
        public int Column {
            get {
                return this._column;
            }
        }
        /// <summary>
        /// The position where the error occurred
        /// </summary>
        public long Position {
            get {
                return this._position;
            }
        }
        static string _GetMessage(string message, int line, int column, long position) {
            return string.Format("{0} at line {1}, column {2}, position {3}", message, line, column, position);
        }
    }
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
    internal partial class ParseNode {
        private int _symbolId;
        private string _symbol;
        private string _value;
        private int _line;
        private int _column;
        private long _position;
        private ParseNode[] _children;
        public ParseNode(int symbolId, string symbol, ParseNode[] children, int line, int column, long position) {
            this._symbolId = symbolId;
            this._symbol = symbol;
            this._value = null;
            this._children = children;
            this._line = line;
            this._column = column;
            this._position = position;
        }
        public ParseNode(int symbolId, string symbol, string value, int line, int column, long position) {
            this._symbolId = symbolId;
            this._symbol = symbol;
            this._value = value;
            this._children = null;
            this._line = line;
            this._column = column;
            this._position = position;
        }
        public bool IsNonTerminal {
            get {
                return (null != this._children);
            }
        }
        public ParseNode[] Children {
            get {
                return this._children;
            }
        }
        public int SymbolId {
            get {
                return this._symbolId;
            }
        }
        public string Symbol {
            get {
                return this._symbol;
            }
        }
        public string Value {
            get {
                return this._value;
            }
        }
        public int Line {
            get {
                return this._line;
            }
        }
        public int Column {
            get {
                return this._column;
            }
        }
        public long Position {
            get {
                return this._position;
            }
        }
    }
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
    internal partial class ParserContext : Object, IDisposable {
        private int _state;
        private IEnumerator<Token> _e;
        private LookAheadEnumerator<Token> _el;
        private Token _t;
        private int _advanceCount;
        public ParserContext(IEnumerable<Token> tokenizer) : 
                this(tokenizer.GetEnumerator(), true) {
        }
        private ParserContext(IEnumerator<Token> enumerator, bool wrap) {
            this._e = enumerator;
            if (wrap) {
                this._el = new LookAheadEnumerator<Token>(enumerator);
                this._e = this._el;
                // we need both pointers to point to the lookahead
            }
            this._state = -1;
            this._t.SymbolId = -1;
            this._advanceCount = 0;
        }
        public void EnsureStarted() {
            if ((-1 == this._state)) {
                this.Advance();
            }
        }
        public ParserContext GetLookAhead() {
            if ((null == this._el)) {
                throw new NotSupportedException("This parser context does not support lookahead.");
            }
            return new ParserContext(this._el.LookAhead.GetEnumerator(), true);
        }
        public ParserContext GetLookAhead(bool start) {
            ParserContext result = this.GetLookAhead();
            if (start) {
                result.EnsureStarted();
            }
            return result;
        }
        public int AdvanceCount {
            get {
                return this._advanceCount;
            }
        }
        public void ResetAdvanceCount() {
            this._advanceCount = 0;
        }
        public int SymbolId {
            get {
                return this._t.SymbolId;
            }
        }
        public string Value {
            get {
                return this._t.Value;
            }
        }
        public int Line {
            get {
                return this._t.Line;
            }
        }
        public int Column {
            get {
                return this._t.Column;
            }
        }
        public long Position {
            get {
                return this._t.Position;
            }
        }
        public bool IsEnded {
            get {
                return (-2 == this._state);
            }
        }
        public bool Advance() {
            if ((false == this._e.MoveNext())) {
                this._t.SymbolId = -2;
                this._state = -2;
            }
            else {
                // sanity check. should never happen
                if ((int.MaxValue == this._advanceCount)) {
                    this._advanceCount = -1;
                }
                this._advanceCount = (this._advanceCount + 1);
                this._state = 0;
                this._t = this._e.Current;
                return true;
            }
            return false;
        }
        public void Error(string message, object arg1, object arg2, object arg3) {
            throw new SyntaxException(string.Format(message, arg1, arg2, arg3), this.Line, this.Column, this.Position);
        }
        public void Error(string message, object arg1, object arg2) {
            throw new SyntaxException(string.Format(message, arg1, arg2), this.Line, this.Column, this.Position);
        }
        public void Error(string message, object arg) {
            throw new SyntaxException(string.Format(message, arg), this.Line, this.Column, this.Position);
        }
        public void Error(string message) {
            throw new SyntaxException(message, this.Line, this.Column, this.Position);
        }
        public void Dispose() {
            this._e.Dispose();
            this._state = -3;
        }
    }
    /// <summary>
    /// An enumerator that provides lookahead without advancing the cursor
    /// </summary>
    /// <typeparam name="T">The type to enumerate</typeparam>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
    internal class LookAheadEnumerator<T> : IEnumerator<T>
     {
        const int _Enumerating = 0;
        const int _NotStarted = -2;
        const int _Ended = -1;
        const int _Disposed = -3;
        IEnumerator<T> _inner;
        int _state;
        // for the lookahead queue
        const int _DefaultCapacity = 16;
        const float _GrowthFactor = 0.9F;
        T[] _queue;
        int _queueHead;
        int _queueCount;
        /// <summary>
        /// Creates a new instance. Once this is created, the inner/wrapped enumerator must not be touched.
        /// </summary>
        /// <param name="inner"></param>
        public LookAheadEnumerator(IEnumerator<T> inner) {
            this._inner = inner;
            this._state = LookAheadEnumerator<T>._NotStarted;
            this._queue = new T[LookAheadEnumerator<T>._DefaultCapacity];
            this._queueHead = 0;
            this._queueCount = 0;
        }
        /// <summary>
        /// Discards the lookahead and advances the cursor to the physical position.
        /// </summary>
        public void DiscardLookAhead() {
            for (
            ; (1 < this._queueCount); 
            ) {
                this._Dequeue();
            }
        }
        /// <summary>
        /// Retrieves the value under the cursor
        /// </summary>
        public T Current {
            get {
                if ((0 > this._state)) {
                    if ((LookAheadEnumerator<T>._NotStarted == this._state)) {
                        throw new InvalidOperationException("The cursor is before the start of the enumeration.");
                    }
                    if ((LookAheadEnumerator<T>._Ended == this._state)) {
                        throw new InvalidOperationException("The cursor is after the end of the enumeration.");
                    }
                    throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
                }
                return this._queue[this._queueHead];
            }
        }
        // legacy enum support (required)
        object System.Collections.IEnumerator.Current {
            get {
                return this.Current;
            }
        }
        internal int QueueCount {
            get {
                return this._queueCount;
            }
        }
        /// <summary>
        /// Attempts to peek the specified number of positions from the current position without advancing
        /// </summary>
        /// <param name="lookahead">The offset from the current position to peek at</param>
        /// <param name="value">The value returned</param>
        /// <returns>True if the peek could be satisfied, otherwise false</returns>
        public bool TryPeek(int lookahead, out T value) {
            if ((LookAheadEnumerator<T>._Disposed == this._state)) {
                throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
            }
            if ((0 > lookahead)) {
                throw new ArgumentOutOfRangeException("lookahead");
            }
            if ((LookAheadEnumerator<T>._Ended == this._state)) {
                value = default(T);
                return false;
            }
            if ((LookAheadEnumerator<T>._NotStarted == this._state)) {
                if ((0 == lookahead)) {
                    value = default(T);
                    return false;
                }
            }
            if ((lookahead < this._queueCount)) {
                value = this._queue[((lookahead + this._queueHead) 
                            % this._queue.Length)];
                return true;
            }
            lookahead = (lookahead - this._queueCount);
            value = default(T);
            for (
            ; ((0 <= lookahead) 
                        && this._inner.MoveNext()); 
            ) {
                value = this._inner.Current;
                this._Enqueue(value);
                lookahead = (lookahead - 1);
            }
            return (-1 == lookahead);
        }
        /// <summary>
        /// Peek the specified number of positions from the current position without advancing
        /// </summary>
        /// <param name="lookahead">The offset from the current position to peek at</param>
        /// <returns>The value at the specified position</returns>
        public T Peek(int lookahead) {
            T value;
            if ((false == this.TryPeek(lookahead, out value))) {
                throw new InvalidOperationException("There were not enough values in the enumeration to satisfy the request");
            }
            return value;
        }
        internal bool IsEnumerating {
            get {
                return (-1 < this._state);
            }
        }
        internal bool IsEnded {
            get {
                return (LookAheadEnumerator<T>._Ended == this._state);
            }
        }
        /// <summary>
        /// Retrieves a lookahead cursor from the current cursor that can be navigated without moving the main cursor
        /// </summary>
        public IEnumerable<T> LookAhead {
            get {
                if ((0 > this._state)) {
                    if ((this._state == LookAheadEnumerator<T>._NotStarted)) {
                        throw new InvalidOperationException("The cursor is before the start of the enumeration.");
                    }
                    if ((this._state == LookAheadEnumerator<T>._Ended)) {
                        throw new InvalidOperationException("The cursor is after the end of the enumeration.");
                    }
                    throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
                }
                return new LookAheadEnumeratorEnumerable<T>(this);
            }
        }
        /// <summary>
        /// Advances the cursor
        /// </summary>
        /// <returns>True if more input was read, otherwise false</returns>
        public bool MoveNext() {
            if ((0 > this._state)) {
                if ((LookAheadEnumerator<T>._Disposed == this._state)) {
                    throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
                }
                if ((LookAheadEnumerator<T>._Ended == this._state)) {
                    return false;
                }
                if ((LookAheadEnumerator<T>._NotStarted == this._state)) {
                    if ((0 < this._queueCount)) {
                        this._state = LookAheadEnumerator<T>._Enumerating;
                        return true;
                    }
                    if ((false == this._inner.MoveNext())) {
                        this._state = LookAheadEnumerator<T>._Ended;
                        return false;
                    }
                    this._Enqueue(this._inner.Current);
                    this._state = LookAheadEnumerator<T>._Enumerating;
                    return true;
                }
            }
            this._Dequeue();
            if ((0 == this._queueCount)) {
                if ((false == this._inner.MoveNext())) {
                    this._state = LookAheadEnumerator<T>._Ended;
                    return false;
                }
                this._Enqueue(this._inner.Current);
            }
            return true;
        }
        /// <summary>
        /// Resets the cursor, and clears the queue.
        /// </summary>
        public void Reset() {
            this._inner.Reset();
            if (((0 < this._queueCount) 
                        && (null == default(T)))) {
                System.Array.Clear(this._queue, this._queueHead, (this._queue.Length - this._queueHead));
                if (((this._queueHead + this._queueCount) 
                            >= this._queue.Length)) {
                    System.Array.Clear(this._queue, 0, (this._queueHead 
                                    + (this._queueCount % this._queue.Length)));
                }
            }
            this._queueHead = 0;
            this._queueCount = 0;
            this._state = LookAheadEnumerator<T>._NotStarted;
        }
        #region IDisposable Support
        /// <summary>
        /// Disposes of this instance
        /// </summary>
        public void Dispose() {
            if ((false 
                        == (LookAheadEnumerator<T>._Disposed == this._state))) {
                this._inner.Dispose();
                this._state = LookAheadEnumerator<T>._Disposed;
            }
        }
        void _Enqueue(T item) {
            if ((this._queueCount == this._queue.Length)) {
                T[] arr = new T[((int)((this._queue.Length 
                            * (1 + LookAheadEnumerator<T>._GrowthFactor))))];
                if (((this._queueHead + this._queueCount) 
                            <= this._queue.Length)) {
                    System.Array.Copy(this._queue, arr, this._queueCount);
                    this._queueHead = 0;
                    arr[this._queueCount] = item;
                    this._queueCount = (this._queueCount + 1);
                    this._queue = arr;
                }
                else {
                    System.Array.Copy(this._queue, this._queueHead, arr, 0, (this._queue.Length - this._queueHead));
                    System.Array.Copy(this._queue, 0, arr, (this._queue.Length - this._queueHead), this._queueHead);
                    this._queueHead = 0;
                    arr[this._queueCount] = item;
                    this._queueCount = (this._queueCount + 1);
                    this._queue = arr;
                }
            }
            else {
                this._queue[((this._queueHead + this._queueCount) 
                            % this._queue.Length)] = item;
                this._queueCount = (this._queueCount + 1);
            }
        }
        T _Dequeue() {
            if ((0 == this._queueCount)) {
                throw new InvalidOperationException("The queue is empty");
            }
            T result = this._queue[this._queueHead];
            this._queue[this._queueHead] = default(T);
            this._queueHead = (this._queueHead + 1);
            this._queueHead = (this._queueHead % this._queue.Length);
            this._queueCount = (this._queueCount - 1);
            return result;
        }
        #endregion
    }
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
    internal class LookAheadEnumeratorEnumerable<T> : IEnumerable<T>
     {
        LookAheadEnumerator<T> _outer;
        public LookAheadEnumeratorEnumerable(LookAheadEnumerator<T> outer) {
            this._outer = outer;
        }
        public IEnumerator<T> GetEnumerator() {
            return new LookAheadEnumeratorEnumerator<T>(this._outer);
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
            return this.GetEnumerator();
        }
    }
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.0.0")]
    internal class LookAheadEnumeratorEnumerator<T> : IEnumerator<T>
     {
        const int _NotStarted = -2;
        const int _Ended = -1;
        const int _Disposed = -3;
        LookAheadEnumerator<T> _outer;
        int _index;
        T _current;
        public LookAheadEnumeratorEnumerator(LookAheadEnumerator<T> outer) {
            this._outer = outer;
            if (this._outer.IsEnumerating) {
                this._current = this._outer.Current;
            }
            this._index = LookAheadEnumeratorEnumerator<T>._NotStarted;
        }
        public T Current {
            get {
                if ((0 > this._index)) {
                    if ((this._index == LookAheadEnumeratorEnumerator<T>._NotStarted)) {
                        throw new InvalidOperationException("The cursor is before the start of the enumeration.");
                    }
                    if ((this._index == LookAheadEnumeratorEnumerator<T>._Ended)) {
                        throw new InvalidOperationException("The cursor is after the end of the enumeration.");
                    }
                    throw new ObjectDisposedException(typeof(LookAheadEnumeratorEnumerator<T>).Name);
                }
                return this._current;
            }
        }
        object System.Collections.IEnumerator.Current {
            get {
                return this.Current;
            }
        }
        public void Dispose() {
            this._index = LookAheadEnumeratorEnumerator<T>._Disposed;
        }
        public bool MoveNext() {
            T value;
            if ((0 > this._index)) {
                if ((this._index == LookAheadEnumeratorEnumerator<T>._Disposed)) {
                    throw new ObjectDisposedException(typeof(LookAheadEnumeratorEnumerator<T>).Name);
                }
                if ((this._index == LookAheadEnumeratorEnumerator<T>._Ended)) {
                    return false;
                }
                this._index = -1;
            }
            this._index = (this._index + 1);
            if ((false == this._outer.TryPeek(this._index, out value))) {
                this._index = LookAheadEnumeratorEnumerator<T>._Ended;
                return false;
            }
            this._current = value;
            return true;
        }
        public void Reset() {
            this._index = LookAheadEnumeratorEnumerator<T>._NotStarted;
        }
    }
}
