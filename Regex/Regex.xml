<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Regex</name>
    </assembly>
    <members>
        <member name="T:RE.RegexBinaryExpression">
            <summary>
            Represents a binary expression
            </summary>
        </member>
        <member name="P:RE.RegexBinaryExpression.Left">
            <summary>
            Indicates the left hand expression
            </summary>
        </member>
        <member name="P:RE.RegexBinaryExpression.Right">
            <summary>
            Indicates the right hand expression
            </summary>
        </member>
        <member name="T:RE.RegexCharsetEntry">
            <summary>
            Represents the base class for regex charset entries
            </summary>
        </member>
        <member name="M:RE.RegexCharsetEntry.#ctor">
            <summary>
            Initializes the charset entry
            </summary>
        </member>
        <member name="M:RE.RegexCharsetEntry.CloneImpl">
            <summary>
            Implements the clone method
            </summary>
            <returns>A copy of the charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetEntry.System#ICloneable#Clone">
            <summary>
            Creates a copy of the charset entry
            </summary>
            <returns>A new copy of the charset entry</returns>
        </member>
        <member name="T:RE.RegexCharsetClassEntry">
            <summary>
            Represents a character class charset entry
            </summary>
        </member>
        <member name="M:RE.RegexCharsetClassEntry.#ctor(System.String)">
            <summary>
            Initializes a class entry with the specified character class
            </summary>
            <param name="name">The name of the character class</param>
        </member>
        <member name="M:RE.RegexCharsetClassEntry.#ctor">
            <summary>
            Initializes a default instance of the charset entry
            </summary>
        </member>
        <member name="P:RE.RegexCharsetClassEntry.Name">
            <summary>
            Indicates the name of the character class
            </summary>
        </member>
        <member name="M:RE.RegexCharsetClassEntry.ToString">
            <summary>
            Gets a string representation of this instance
            </summary>
            <returns>The string representation of this character class</returns>
        </member>
        <member name="M:RE.RegexCharsetClassEntry.CloneImpl">
            <summary>
            Clones the object
            </summary>
            <returns>A new copy of the charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetClassEntry.Clone">
            <summary>
            Clones the object
            </summary>
            <returns>A new copy of the charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetClassEntry.Equals(RE.RegexCharsetClassEntry)">
            <summary>
            Indicates whether this charset entry is the same as the right hand charset entry
            </summary>
            <param name="rhs">The charset entry to compare</param>
            <returns>True if the charset entries are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetClassEntry.Equals(System.Object)">
            <summary>
            Indicates whether this charset entry is the same as the right hand charset entry
            </summary>
            <param name="rhs">The charset entry to compare</param>
            <returns>True if the charset entries are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetClassEntry.GetHashCode">
            <summary>
            Computes a hash code for this charset entry
            </summary>
            <returns>A hash code for this charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetClassEntry.op_Equality(RE.RegexCharsetClassEntry,RE.RegexCharsetClassEntry)">
            <summary>
            Indicates whether or not two charset entries are the same
            </summary>
            <param name="lhs">The left hand charset entry to compare</param>
            <param name="rhs">The right hand charset entry to compare</param>
            <returns>True if the charset entries are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetClassEntry.op_Inequality(RE.RegexCharsetClassEntry,RE.RegexCharsetClassEntry)">
            <summary>
            Indicates whether or not two charset entries are different
            </summary>
            <param name="lhs">The left hand charset entry to compare</param>
            <param name="rhs">The right hand charset entry to compare</param>
            <returns>True if the charset entries are different, otherwise false</returns>
        </member>
        <member name="T:RE.RegexCharsetCharEntry">
            <summary>
            Represents a single character charset entry
            </summary>
        </member>
        <member name="M:RE.RegexCharsetCharEntry.#ctor(System.Char)">
            <summary>
            Initializes the entry with a character
            </summary>
            <param name="value">The character to use</param>
        </member>
        <member name="M:RE.RegexCharsetCharEntry.#ctor">
            <summary>
            Initializes a default instance of the charset entry
            </summary>
        </member>
        <member name="P:RE.RegexCharsetCharEntry.Value">
            <summary>
            Indicates the character the charset entry represents
            </summary>
        </member>
        <member name="M:RE.RegexCharsetCharEntry.ToString">
            <summary>
            Gets a string representation of the charset entry
            </summary>
            <returns>The string representation of this charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetCharEntry.CloneImpl">
            <summary>
            Clones the object
            </summary>
            <returns>A new copy of the charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetCharEntry.Clone">
            <summary>
            Clones the object
            </summary>
            <returns>A new copy of the charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetCharEntry.Equals(RE.RegexCharsetCharEntry)">
            <summary>
            Indicates whether this charset entry is the same as the right hand charset entry
            </summary>
            <param name="rhs">The charset entry to compare</param>
            <returns>True if the charset entries are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetCharEntry.Equals(System.Object)">
            <summary>
            Indicates whether this charset entry is the same as the right hand charset entry
            </summary>
            <param name="rhs">The charset entry to compare</param>
            <returns>True if the charset entries are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetCharEntry.GetHashCode">
            <summary>
            Computes a hash code for this charset entry
            </summary>
            <returns>A hash code for this charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetCharEntry.op_Equality(RE.RegexCharsetCharEntry,RE.RegexCharsetCharEntry)">
            <summary>
            Indicates whether or not two charset entries are the same
            </summary>
            <param name="lhs">The left hand charset entry to compare</param>
            <param name="rhs">The right hand charset entry to compare</param>
            <returns>True if the charset entries are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetCharEntry.op_Inequality(RE.RegexCharsetCharEntry,RE.RegexCharsetCharEntry)">
            <summary>
            Indicates whether or not two charset entries are different
            </summary>
            <param name="lhs">The left hand charset entry to compare</param>
            <param name="rhs">The right hand charset entry to compare</param>
            <returns>True if the charset entries are different, otherwise false</returns>
        </member>
        <member name="T:RE.RegexCharsetRangeEntry">
            <summary>
            Represents a character set range entry
            </summary>
        </member>
        <member name="M:RE.RegexCharsetRangeEntry.#ctor(System.Char,System.Char)">
            <summary>
            Creates a new range entry with the specified first and last characters
            </summary>
            <param name="first">The first character in the range</param>
            <param name="last">The last character in the range</param>
        </member>
        <member name="M:RE.RegexCharsetRangeEntry.#ctor">
            <summary>
            Creates a default instance of the range entry
            </summary>
        </member>
        <member name="P:RE.RegexCharsetRangeEntry.First">
            <summary>
            Indicates the first character in the range
            </summary>
        </member>
        <member name="P:RE.RegexCharsetRangeEntry.Last">
            <summary>
            Indicates the last character in the range
            </summary>
        </member>
        <member name="M:RE.RegexCharsetRangeEntry.CloneImpl">
            <summary>
            Clones the object
            </summary>
            <returns>A new copy of the charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetRangeEntry.Clone">
            <summary>
            Clones the object
            </summary>
            <returns>A new copy of the charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetRangeEntry.ToString">
            <summary>
            Gets a string representation of the charset entry
            </summary>
            <returns>The string representation of this charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetRangeEntry.Equals(RE.RegexCharsetRangeEntry)">
            <summary>
            Indicates whether this charset entry is the same as the right hand charset entry
            </summary>
            <param name="rhs">The charset entry to compare</param>
            <returns>True if the charset entries are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetRangeEntry.Equals(System.Object)">
            <summary>
            Indicates whether this charset entry is the same as the right hand charset entry
            </summary>
            <param name="rhs">The charset entry to compare</param>
            <returns>True if the charset entries are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetRangeEntry.GetHashCode">
            <summary>
            Computes a hash code for this charset entry
            </summary>
            <returns>A hash code for this charset entry</returns>
        </member>
        <member name="M:RE.RegexCharsetRangeEntry.op_Equality(RE.RegexCharsetRangeEntry,RE.RegexCharsetRangeEntry)">
            <summary>
            Indicates whether or not two charset entries are the same
            </summary>
            <param name="lhs">The left hand charset entry to compare</param>
            <param name="rhs">The right hand charset entry to compare</param>
            <returns>True if the charset entries are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetRangeEntry.op_Inequality(RE.RegexCharsetRangeEntry,RE.RegexCharsetRangeEntry)">
            <summary>
            Indicates whether or not two charset entries are different
            </summary>
            <param name="lhs">The left hand charset entry to compare</param>
            <param name="rhs">The right hand charset entry to compare</param>
            <returns>True if the charset entries are different, otherwise false</returns>
        </member>
        <member name="T:RE.RegexCharsetExpression">
            <summary>
            Indicates a charset expression
            </summary>
            <remarks>Represented by [] in regular expression syntax</remarks>
        </member>
        <member name="P:RE.RegexCharsetExpression.Entries">
            <summary>
            Indicates the <see cref="T:RE.RegexCharsetEntry"/> entries in the character set
            </summary>
        </member>
        <member name="M:RE.RegexCharsetExpression.#ctor(System.Collections.Generic.IEnumerable{RE.RegexCharsetEntry},System.Boolean)">
            <summary>
            Creates a new charset expression with the specified entries and optionally negated
            </summary>
            <param name="entries">The entries to initialize the charset with</param>
            <param name="hasNegatedRanges">True if the range is a "not range" like [^], otherwise false</param>
        </member>
        <member name="M:RE.RegexCharsetExpression.#ctor">
            <summary>
            Creates a default instance of the expression
            </summary>
        </member>
        <member name="M:RE.RegexCharsetExpression.ToFA``1(``0)">
            <summary>
            Creates a state machine representing this expression
            </summary>
            <typeparam name="TAccept">The type of accept symbol to use for this expression</typeparam>
            <param name="accept">The accept symbol to use for this expression</param>
            <returns>A new <see cref="T:RE.CharFA`1"/> finite state machine representing this expression</returns>
        </member>
        <member name="P:RE.RegexCharsetExpression.HasNegatedRanges">
            <summary>
            Indicates whether the range is a "not range"
            </summary>
            <remarks>This is represented by the [^] regular expression syntax</remarks>
        </member>
        <member name="P:RE.RegexCharsetExpression.IsSingleElement">
            <summary>
            Indicates whether or not this statement is a single element or not
            </summary>
            <remarks>If false, this statement will be wrapped in parentheses if necessary</remarks>
        </member>
        <member name="M:RE.RegexCharsetExpression.AppendTo(System.Text.StringBuilder)">
            <summary>
            Appends the textual representation to a <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="sb">The string builder to use</param>
            <remarks>Used by ToString()</remarks>
        </member>
        <member name="M:RE.RegexCharsetExpression.CloneImpl">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexCharsetExpression.Clone">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexCharsetExpression.Equals(RE.RegexCharsetExpression)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetExpression.Equals(System.Object)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetExpression.GetHashCode">
            <summary>
            Computes a hash code for this expression
            </summary>
            <returns>A hash code for this expression</returns>
        </member>
        <member name="M:RE.RegexCharsetExpression.op_Equality(RE.RegexCharsetExpression,RE.RegexCharsetExpression)">
            <summary>
            Indicates whether or not two expression are the same
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexCharsetExpression.op_Inequality(RE.RegexCharsetExpression,RE.RegexCharsetExpression)">
            <summary>
            Indicates whether or not two expression are different
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are different, otherwise false</returns>
        </member>
        <member name="T:RE.RegexConcatExpression">
            <summary>
            Represents a concatenation between two expression. This has no operator as it is implicit.
            </summary>
        </member>
        <member name="P:RE.RegexConcatExpression.IsSingleElement">
            <summary>
            Indicates whether or not this statement is a single element or not
            </summary>
            <remarks>If false, this statement will be wrapped in parentheses if necessary</remarks>
        </member>
        <member name="M:RE.RegexConcatExpression.#ctor(RE.RegexExpression,RE.RegexExpression[])">
            <summary>
            Creates a new expression with the specified left and right hand sides
            </summary>
            <param name="left">The left expression</param>
            <param name="right">The right expressions</param>
        </member>
        <member name="M:RE.RegexConcatExpression.#ctor">
            <summary>
            Creates a default instance of the expression
            </summary>
        </member>
        <member name="M:RE.RegexConcatExpression.ToFA``1(``0)">
            <summary>
            Creates a state machine representing this expression
            </summary>
            <typeparam name="TAccept">The type of accept symbol to use for this expression</typeparam>
            <param name="accept">The accept symbol to use for this expression</param>
            <returns>A new <see cref="T:RE.CharFA`1"/> finite state machine representing this expression</returns>
        </member>
        <member name="M:RE.RegexConcatExpression.CloneImpl">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexConcatExpression.Clone">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexConcatExpression.Equals(RE.RegexConcatExpression)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexConcatExpression.Equals(System.Object)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexConcatExpression.GetHashCode">
            <summary>
            Computes a hash code for this expression
            </summary>
            <returns>A hash code for this expression</returns>
        </member>
        <member name="M:RE.RegexConcatExpression.op_Equality(RE.RegexConcatExpression,RE.RegexConcatExpression)">
            <summary>
            Indicates whether or not two expression are the same
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexConcatExpression.op_Inequality(RE.RegexConcatExpression,RE.RegexConcatExpression)">
            <summary>
            Indicates whether or not two expression are different
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are different, otherwise false</returns>
        </member>
        <member name="M:RE.RegexConcatExpression.AppendTo(System.Text.StringBuilder)">
            <summary>
            Appends the textual representation to a <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="sb">The string builder to use</param>
            <remarks>Used by ToString()</remarks>
        </member>
        <member name="T:RE.RegexExpression">
            <summary>
            Represents the common functionality of all regular expression elements
            </summary>
        </member>
        <member name="P:RE.RegexExpression.Line">
            <summary>
            Indicates the 1 based line on which the regular expression was found
            </summary>
        </member>
        <member name="P:RE.RegexExpression.Column">
            <summary>
            Indicates the 1 based column on which the regular expression was found
            </summary>
        </member>
        <member name="P:RE.RegexExpression.Position">
            <summary>
            Indicates the 0 based position on which the regular expression was found
            </summary>
        </member>
        <member name="P:RE.RegexExpression.IsSingleElement">
            <summary>
            Indicates whether or not this statement is a single element or not
            </summary>
            <remarks>If false, this statement will be wrapped in parentheses if necessary</remarks>
        </member>
        <member name="M:RE.RegexExpression.SetLocation(System.Int32,System.Int32,System.Int64)">
            <summary>
            Sets the location information for the expression
            </summary>
            <param name="line">The 1 based line where the expression appears</param>
            <param name="column">The 1 based column where the expression appears</param>
            <param name="position">The 0 based position where the expression appears</param>
        </member>
        <member name="M:RE.RegexExpression.CloneImpl">
            <summary>
            Creates a copy of the expression
            </summary>
            <returns>A copy of the expression</returns>
        </member>
        <member name="M:RE.RegexExpression.ToFA``1">
            <summary>
            Creates a state machine representing this expression
            </summary>
            <typeparam name="TAccept">The type of accept symbol to use for this expression</typeparam>
            <returns>A new <see cref="T:RE.CharFA`1"/> finite state machine representing this expression</returns>
        </member>
        <member name="M:RE.RegexExpression.ToFA``1(``0)">
            <summary>
            Creates a state machine representing this expression
            </summary>
            <typeparam name="TAccept">The type of accept symbol to use for this expression</typeparam>
            <param name="accept">The accept symbol to use for this expression</param>
            <returns>A new <see cref="T:RE.CharFA`1"/> finite state machine representing this expression</returns>
        </member>
        <member name="M:RE.RegexExpression.FromFA``1(RE.CharFA{``0},System.IProgress{RE.CharFAProgress})">
            <summary>
            EXPERIMENTAL, INCOMPLETE
            Builds an abstract syntax tree/DOM from the specified state machine
            </summary>
            <typeparam name="TAccept">The type of accept symbol</typeparam>
            <param name="fa">The state machine to analyze</param>
            <param name="progress">An optional <see cref="T:System.IProgress`1"/> instance used to report the progress of the task</param>
            <returns>A regular expression syntax tree representing <paramref name="fa"/></returns>
        </member>
        <member name="M:RE.RegexExpression.AppendTo(System.Text.StringBuilder)">
            <summary>
            Appends the textual representation to a <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="sb">The string builder to use</param>
            <remarks>Used by ToString()</remarks>
        </member>
        <member name="M:RE.RegexExpression.ToString">
            <summary>
            Gets a textual representation of the expression
            </summary>
            <returns>A string representing the expression</returns>
        </member>
        <member name="M:RE.RegexExpression.Parse(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Parses a regular expresion from the specified string
            </summary>
            <param name="string">The string</param>
            <returns>A new abstract syntax tree representing the expression</returns>
        </member>
        <member name="M:RE.RegexExpression.ReadFrom(System.IO.TextReader)">
            <summary>
            Parses a regular expresion from the specified <see cref="T:System.IO.TextReader"/>
            </summary>
            <param name="reader">The text reader</param>
            <returns>A new abstract syntax tree representing the expression</returns>
        </member>
        <member name="M:RE.RegexExpression.Parse(RE.ParseContext)">
            <summary>
            Parses a regular expression from the specified <see cref="T:RE.ParseContext"/>
            </summary>
            <param name="pc">The parse context to use</param>
            <returns>A new abstract syntax tree representing the expression</returns>
        </member>
        <member name="M:RE.RegexExpression.AppendEscapedChar(System.Char,System.Text.StringBuilder)">
            <summary>
            Appends a character escape to the specified <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="ch">The character to escape</param>
            <param name="builder">The string builder to append to</param>
        </member>
        <member name="M:RE.RegexExpression.EscapeChar(System.Char)">
            <summary>
            Escapes the specified character
            </summary>
            <param name="ch">The character to escape</param>
            <returns>A string representing the escaped character</returns>
        </member>
        <member name="M:RE.RegexExpression.AppendEscapedRangeChar(System.Char,System.Text.StringBuilder)">
            <summary>
            Appends an escaped range character to the specified <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="rangeChar">The range character to escape</param>
            <param name="builder">The string builder to append to</param>
        </member>
        <member name="M:RE.RegexExpression.EscapeRangeChar(System.Char)">
            <summary>
            Escapes a range character
            </summary>
            <param name="ch">The character to escape</param>
            <returns>A string containing the escaped character</returns>
        </member>
        <member name="T:RE.RegexLiteralExpression">
            <summary>
            Represents a single character literal
            </summary>
        </member>
        <member name="P:RE.RegexLiteralExpression.IsSingleElement">
            <summary>
            Indicates whether or not this statement is a single element or not
            </summary>
            <remarks>If false, this statement will be wrapped in parentheses if necessary</remarks>
        </member>
        <member name="P:RE.RegexLiteralExpression.Value">
            <summary>
            Indicates the character literal of this expression
            </summary>
        </member>
        <member name="M:RE.RegexLiteralExpression.CreateString(System.String)">
            <summary>
            Creates a series of concatenated literals representing the specified string
            </summary>
            <param name="value">The string to use</param>
            <returns>An expression representing <paramref name="value"/></returns>
        </member>
        <member name="M:RE.RegexLiteralExpression.#ctor(System.Char)">
            <summary>
            Creates a literal expression with the specified character
            </summary>
            <param name="value">The character to represent</param>
        </member>
        <member name="M:RE.RegexLiteralExpression.#ctor">
            <summary>
            Creates a default instance of the expression
            </summary>
        </member>
        <member name="M:RE.RegexLiteralExpression.ToFA``1(``0)">
            <summary>
            Creates a state machine representing this expression
            </summary>
            <typeparam name="TAccept">The type of accept symbol to use for this expression</typeparam>
            <param name="accept">The accept symbol to use for this expression</param>
            <returns>A new <see cref="T:RE.CharFA`1"/> finite state machine representing this expression</returns>
        </member>
        <member name="M:RE.RegexLiteralExpression.AppendTo(System.Text.StringBuilder)">
            <summary>
            Appends the textual representation to a <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="sb">The string builder to use</param>
            <remarks>Used by ToString()</remarks>
        </member>
        <member name="M:RE.RegexLiteralExpression.CloneImpl">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexLiteralExpression.Clone">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexLiteralExpression.Equals(RE.RegexLiteralExpression)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexLiteralExpression.Equals(System.Object)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexLiteralExpression.GetHashCode">
            <summary>
            Computes a hash code for this expression
            </summary>
            <returns>A hash code for this expression</returns>
        </member>
        <member name="M:RE.RegexLiteralExpression.op_Equality(RE.RegexLiteralExpression,RE.RegexLiteralExpression)">
            <summary>
            Indicates whether or not two expression are the same
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexLiteralExpression.op_Inequality(RE.RegexLiteralExpression,RE.RegexLiteralExpression)">
            <summary>
            Indicates whether or not two expression are different
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are different, otherwise false</returns>
        </member>
        <member name="T:RE.RegexOptionalExpression">
            <summary>
            Represents an optional expression, as indicated by ?
            </summary>
        </member>
        <member name="P:RE.RegexOptionalExpression.IsSingleElement">
            <summary>
            Indicates whether or not this statement is a single element or not
            </summary>
            <remarks>If false, this statement will be wrapped in parentheses if necessary</remarks>
        </member>
        <member name="M:RE.RegexOptionalExpression.#ctor(RE.RegexExpression)">
            <summary>
            Creates an optional expression using the specified target expression
            </summary>
            <param name="expression">The target expression to make optional</param>
        </member>
        <member name="M:RE.RegexOptionalExpression.#ctor">
            <summary>
            Creates a default instance of the expression
            </summary>
        </member>
        <member name="M:RE.RegexOptionalExpression.ToFA``1(``0)">
            <summary>
            Creates a state machine representing this expression
            </summary>
            <typeparam name="TAccept">The type of accept symbol to use for this expression</typeparam>
            <param name="accept">The accept symbol to use for this expression</param>
            <returns>A new <see cref="T:RE.CharFA`1"/> finite state machine representing this expression</returns>
        </member>
        <member name="M:RE.RegexOptionalExpression.AppendTo(System.Text.StringBuilder)">
            <summary>
            Appends the textual representation to a <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="sb">The string builder to use</param>
            <remarks>Used by ToString()</remarks>
        </member>
        <member name="M:RE.RegexOptionalExpression.CloneImpl">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexOptionalExpression.Clone">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexOptionalExpression.Equals(RE.RegexOptionalExpression)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexOptionalExpression.Equals(System.Object)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexOptionalExpression.GetHashCode">
            <summary>
            Computes a hash code for this expression
            </summary>
            <returns>A hash code for this expression</returns>
        </member>
        <member name="M:RE.RegexOptionalExpression.op_Equality(RE.RegexOptionalExpression,RE.RegexOptionalExpression)">
            <summary>
            Indicates whether or not two expression are the same
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexOptionalExpression.op_Inequality(RE.RegexOptionalExpression,RE.RegexOptionalExpression)">
            <summary>
            Indicates whether or not two expression are different
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are different, otherwise false</returns>
        </member>
        <member name="T:RE.RegexOrExpression">
            <summary>
            Represents an "or" regular expression as indicated by |
            </summary>
        </member>
        <member name="P:RE.RegexOrExpression.IsSingleElement">
            <summary>
            Indicates whether or not this statement is a single element or not
            </summary>
            <remarks>If false, this statement will be wrapped in parentheses if necessary</remarks>
        </member>
        <member name="M:RE.RegexOrExpression.#ctor(RE.RegexExpression,RE.RegexExpression[])">
            <summary>
            Creates a new expression with the specified left and right hand sides
            </summary>
            <param name="left">The left expression</param>
            <param name="right">The right expressions</param>
        </member>
        <member name="M:RE.RegexOrExpression.#ctor">
            <summary>
            Creates a default instance of the expression
            </summary>
        </member>
        <member name="M:RE.RegexOrExpression.ToFA``1(``0)">
            <summary>
            Creates a state machine representing this expression
            </summary>
            <typeparam name="TAccept">The type of accept symbol to use for this expression</typeparam>
            <param name="accept">The accept symbol to use for this expression</param>
            <returns>A new <see cref="T:RE.CharFA`1"/> finite state machine representing this expression</returns>
        </member>
        <member name="M:RE.RegexOrExpression.AppendTo(System.Text.StringBuilder)">
            <summary>
            Appends the textual representation to a <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="sb">The string builder to use</param>
            <remarks>Used by ToString()</remarks>
        </member>
        <member name="M:RE.RegexOrExpression.CloneImpl">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexOrExpression.Clone">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexOrExpression.Equals(RE.RegexOrExpression)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexOrExpression.Equals(System.Object)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexOrExpression.GetHashCode">
            <summary>
            Computes a hash code for this expression
            </summary>
            <returns>A hash code for this expression</returns>
        </member>
        <member name="M:RE.RegexOrExpression.op_Equality(RE.RegexOrExpression,RE.RegexOrExpression)">
            <summary>
            Indicates whether or not two expression are the same
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexOrExpression.op_Inequality(RE.RegexOrExpression,RE.RegexOrExpression)">
            <summary>
            Indicates whether or not two expression are different
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are different, otherwise false</returns>
        </member>
        <member name="T:RE.RegexRepeatExpression">
            <summary>
            Represents a repeat regular expression as indicated by *, +, or {min,max}
            </summary>
        </member>
        <member name="P:RE.RegexRepeatExpression.IsSingleElement">
            <summary>
            Indicates whether or not this statement is a single element or not
            </summary>
            <remarks>If false, this statement will be wrapped in parentheses if necessary</remarks>
        </member>
        <member name="M:RE.RegexRepeatExpression.#ctor(RE.RegexExpression,System.Int32,System.Int32)">
            <summary>
            Creates a repeat expression with the specifed target expression, and minimum and maximum occurances
            </summary>
            <param name="expression">The target expression</param>
            <param name="minOccurs">The minimum number of times the target expression can occur or -1</param>
            <param name="maxOccurs">The maximum number of times the target expression can occur or -1</param>
        </member>
        <member name="M:RE.RegexRepeatExpression.#ctor">
            <summary>
            Creates a default instance of the expression
            </summary>
        </member>
        <member name="P:RE.RegexRepeatExpression.MinOccurs">
            <summary>
            Indicates the minimum number of times the target expression can occur, or 0 or -1 for no minimum
            </summary>
        </member>
        <member name="P:RE.RegexRepeatExpression.MaxOccurs">
            <summary>
            Indicates the maximum number of times the target expression can occur, or 0 or -1 for no maximum
            </summary>
        </member>
        <member name="M:RE.RegexRepeatExpression.ToFA``1(``0)">
            <summary>
            Creates a state machine representing this expression
            </summary>
            <typeparam name="TAccept">The type of accept symbol to use for this expression</typeparam>
            <param name="accept">The accept symbol to use for this expression</param>
            <returns>A new <see cref="T:RE.CharFA`1"/> finite state machine representing this expression</returns>		
        </member>
        <member name="M:RE.RegexRepeatExpression.AppendTo(System.Text.StringBuilder)">
            <summary>
            Appends the textual representation to a <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="sb">The string builder to use</param>
            <remarks>Used by ToString()</remarks>
        </member>
        <member name="M:RE.RegexRepeatExpression.CloneImpl">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexRepeatExpression.Clone">
            <summary>
            Creates a new copy of this expression
            </summary>
            <returns>A new copy of this expression</returns>
        </member>
        <member name="M:RE.RegexRepeatExpression.Equals(RE.RegexRepeatExpression)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexRepeatExpression.Equals(System.Object)">
            <summary>
            Indicates whether this expression is the same as the right hand expression
            </summary>
            <param name="rhs">The expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexRepeatExpression.GetHashCode">
            <summary>
            Computes a hash code for this expression
            </summary>
            <returns>A hash code for this expression</returns>
        </member>
        <member name="M:RE.RegexRepeatExpression.op_Equality(RE.RegexRepeatExpression,RE.RegexRepeatExpression)">
            <summary>
            Indicates whether or not two expression are the same
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are the same, otherwise false</returns>
        </member>
        <member name="M:RE.RegexRepeatExpression.op_Inequality(RE.RegexRepeatExpression,RE.RegexRepeatExpression)">
            <summary>
            Indicates whether or not two expression are different
            </summary>
            <param name="lhs">The left hand expression to compare</param>
            <param name="rhs">The right hand expression to compare</param>
            <returns>True if the expressions are different, otherwise false</returns>
        </member>
        <member name="T:RE.RegexUnaryExpression">
            <summary>
            Represents an expression with a single target expression
            </summary>
        </member>
        <member name="P:RE.RegexUnaryExpression.Expression">
            <summary>
            Indicates the target expression
            </summary>
        </member>
        <member name="T:RE.CharRange">
            <summary>
            Represents an ascending range of characters.
            </summary>
        </member>
        <member name="M:RE.CharRange.#ctor(System.Char,System.Char)">
            <summary>
            Initializes the character range with the specified first and last characters
            </summary>
            <param name="first">The first character</param>
            <param name="last">The last character</param>
        </member>
        <member name="P:RE.CharRange.System#Collections#Generic#IList{System#Char}#Item(System.Int32)">
            <summary>
            Gets a character at the specified index
            </summary>
            <param name="index">The index within the range</param>
            <returns>The character at the specified index</returns>
        </member>
        <member name="P:RE.CharRange.Item(System.Int32)">
            <summary>
            Gets a character at the specified index
            </summary>
            <param name="index">The index within the range</param>
            <returns>The character at the specified index</returns>
        </member>
        <member name="P:RE.CharRange.Length">
            <summary>
            Gets the length of the range
            </summary>
        </member>
        <member name="P:RE.CharRange.First">
            <summary>
            Gets the first character in the range
            </summary>
        </member>
        <member name="P:RE.CharRange.Last">
            <summary>
            Gets the last character in the range
            </summary>
        </member>
        <member name="M:RE.CharRange.GetRanges(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Gets ranges for a series of characters.
            </summary>
            <param name="sortedString">The sorted characters</param>
            <returns>A series of ranges representing the specified characters</returns>
        </member>
        <member name="M:RE.CharRange.ToPackedChars(System.Collections.Generic.IEnumerable{RE.CharRange})">
            <summary>
            Returns an array of character pairs representing the ranges
            </summary>
            <param name="ranges">The ranges to pack</param>
            <returns>A packed array of ranges</returns>
        </member>
        <member name="M:RE.CharRange.ToPackedInts(System.Collections.Generic.IEnumerable{RE.CharRange})">
            <summary>
            Returns an array of int pairs representing the ranges
            </summary>
            <param name="ranges">The ranges to pack</param>
            <returns>A packed array of ranges</returns>
        </member>
        <member name="M:RE.CharRange.ToPackedString(System.Collections.Generic.IEnumerable{RE.CharRange})">
            <summary>
            Returns a packed string of character pairs representing the ranges
            </summary>
            <param name="ranges">The ranges to pack</param>
            <returns>A string containing the packed ranges</returns>
        </member>
        <member name="M:RE.CharRange.ExpandRanges(System.Collections.Generic.IEnumerable{RE.CharRange})">
            <summary>
            Expands the ranges into a collection of characters
            </summary>
            <param name="ranges">The ranges to expand</param>
            <returns>A collection of characters representing the ranges</returns>
        </member>
        <member name="M:RE.CharRange.NotRanges(System.Collections.Generic.IEnumerable{RE.CharRange})">
            <summary>
            Negates the character ranges
            </summary>
            <param name="ranges">The ranges to negate</param>
            <returns>The inverse set of ranges. Every character not in <paramref name="ranges"/> becomes part of a range.</returns>
        </member>
        <member name="M:RE.CharRange.NormalizeRangeList(System.Collections.Generic.List{RE.CharRange})">
            <summary>
            Takes a list of ranges and ensures each range's First character is less than or equal to its Last character
            </summary>
            <param name="ranges">The ranges to normalize</param>
        </member>
        <member name="P:RE.CharRange.System#Collections#Generic#ICollection{System#Char}#Count">
            <summary>
            Returns the count of characters in the range
            </summary>
        </member>
        <member name="P:RE.CharRange.System#Collections#Generic#ICollection{System#Char}#IsReadOnly">
            <summary>
            Indicates that the range is read only
            </summary>
        </member>
        <member name="M:RE.CharRange.Equals(RE.CharRange)">
            <summary>
            Indicates whether this range equals another range
            </summary>
            <param name="rhs">The range to compare</param>
            <returns>True if the ranges are equal, otherwise false</returns>
        </member>
        <member name="M:RE.CharRange.Equals(System.Object)">
            <summary>
            Indicates whether this range equals another range
            </summary>
            <param name="obj">The range to compare</param>
            <returns>True if the ranges are equal, otherwise false</returns>
        </member>
        <member name="M:RE.CharRange.GetHashCode">
            <summary>
            Gets the hash code for the range
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:RE.CharRange.ToString">
            <summary>
            Returns a string representation of a range
            </summary>
            <returns>A string representing the range</returns>
        </member>
        <member name="M:RE.CharRange.op_Equality(RE.CharRange,RE.CharRange)">
            <summary>
            Indicates whether or not two character ranges are the same
            </summary>
            <param name="lhs">The left hand range to compare</param>
            <param name="rhs">The right hand range to compare</param>
            <returns>True if the ranges are the same, otherwise false</returns>
        </member>
        <member name="M:RE.CharRange.op_Inequality(RE.CharRange,RE.CharRange)">
            <summary>
            Indicates whether or not two character ranges are different
            </summary>
            <param name="lhs">The left hand range to compare</param>
            <param name="rhs">The right hand range to compare</param>
            <returns>True if the ranges are different, otherwise false</returns>
        </member>
        <member name="T:RE.CharDfaEntryConverter">
            <summary>
            This is an internal class that helps the code serializer know how to serialize DFA entries
            </summary>
        </member>
        <member name="T:RE.CharDfaEntry">
            <summary>
            Represents an entry in a DFA state table
            </summary>
        </member>
        <member name="M:RE.CharDfaEntry.#ctor(System.Int32,RE.CharDfaTransitionEntry[])">
            <summary>
            Constructs a new instance of the DFA state table with the specified parameters
            </summary>
            <param name="acceptSymbolId">The symbolId to accept or -1 for non-accepting</param>
            <param name="transitions">The transition entries</param>
        </member>
        <member name="F:RE.CharDfaEntry.AcceptSymbolId">
            <summary>
            Indicates the accept symbol's id or -1 for non-accepting
            </summary>
        </member>
        <member name="F:RE.CharDfaEntry.Transitions">
            <summary>
            Indicates the transition entries
            </summary>
        </member>
        <member name="T:RE.CharDfaTransitionEntryConverter">
            <summary>
            This is an internal class that helps the code serializer serialize a DfaTransitionEntry
            </summary>
        </member>
        <member name="T:RE.CharDfaTransitionEntry">
            <summary>
            Indicates a transition entry in the DFA state table
            </summary>
        </member>
        <member name="M:RE.CharDfaTransitionEntry.#ctor(System.Char[],System.Int32)">
            <summary>
            Constructs a DFA transition entry with the specified parameters
            </summary>
            <param name="transitions">Packed character range pairs as a flat array</param>
            <param name="destination">The destination state id</param>
        </member>
        <member name="F:RE.CharDfaTransitionEntry.PackedRanges">
            <summary>
            Indicates the packed range characters. Each range is specified by two array entries, first and last in that order.
            </summary>
        </member>
        <member name="F:RE.CharDfaTransitionEntry.Destination">
            <summary>
            Indicates the destination state id
            </summary>
        </member>
        <member name="T:RE.CharFA`1">
            <summary>
            Represents a single state in a character based finite state machine.
            </summary>
            <typeparam name="TAccept">The type of the accepting symbols</typeparam>
        </member>
        <member name="M:RE.CharFA`1.FillAcceptingStates(System.Collections.Generic.IList{RE.CharFA{`0}})">
            <summary>
            Retrieves all the states reachable from this state that are accepting.
            </summary>
            <param name="result">The list of accepting states. Will be filled after the call.</param>
            <returns>The resulting list of accepting states. This is the same value as the result parameter, if specified.</returns>
        </member>
        <member name="M:RE.CharFA`1.FillAcceptSymbols(System.Collections.Generic.IList{`0})">
            <summary>
            Retrieves all the accept symbols from this state machine.
            </summary>
            <param name="result">The list of accept symbols. Will be filled after the call.</param>
            <returns>The resulting list of accept symbols. This is the same value as the result parameter, if specified.</returns>
        </member>
        <member name="M:RE.CharFA`1.FillAcceptingStates(System.Collections.Generic.IList{RE.CharFA{`0}},System.Collections.Generic.IList{RE.CharFA{`0}})">
            <summary>
            Retrieves all the states in this closure that are accepting
            </summary>
            <param name="closure">The closure to examine</param>
            <param name="result">The list of accepting states. Will be filled after the call.</param>
            <returns>The resulting list of accepting states. This is the same value as the result parameter, if specified.</returns>
        </member>
        <member name="M:RE.CharFA`1.FillAcceptSymbols(System.Collections.Generic.IList{RE.CharFA{`0}},System.Collections.Generic.IList{`0})">
            <summary>
            Retrieves all the accept symbols states in this closure
            </summary>
            <param name="closure">The closure to examine</param>
            <param name="result">The list of accept symbols. Will be filled after the call.</param>
            <returns>The resulting list of accept symbols. This is the same value as the result parameter, if specified.</returns>
        </member>
        <member name="P:RE.CharFA`1.FirstAcceptingState">
            <summary>
            Returns the first state that accepts from a given FA, or null if none do.
            </summary>
        </member>
        <member name="P:RE.CharFA`1.FirstAcceptSymbol">
            <summary>
            Returns the first accept symbol from a given FA, or the default value if none.
            </summary>
        </member>
        <member name="M:RE.CharFA`1.IsAnyAccepting(System.Collections.Generic.IEnumerable{RE.CharFA{`0}})">
            <summary>
            Indicates whether any of the states in the specified collection are accepting
            </summary>
            <param name="states">The state collection to examine</param>
            <returns>True if one or more of the states is accepting, otherwise false.</returns>
        </member>
        <member name="M:RE.CharFA`1.TryGetAnyAcceptSymbol(System.Collections.Generic.IEnumerable{RE.CharFA{`0}},`0@)">
            <summary>
            Retrieves the first accept symbol from the collection of states
            </summary>
            <param name="states">The states to examine</param>
            <param name="result">The accept symbol, if the method returned true</param>
            <returns>True if an accept symbol was found, otherwise false</returns>
        </member>
        <member name="P:RE.CharFA`1.IsLoop">
            <summary>
            Indicates whether the state machine is a loop or not
            </summary>
        </member>
        <member name="P:RE.CharFA`1.CharacterClasses">
            <summary>
            Retrieves a dictionary indicating the character classes supported by this library
            </summary>
        </member>
        <member name="M:RE.CharFA`1.Clone">
            <summary>
            Deep copies the finite state machine to a new state machine
            </summary>
            <returns>The new machine</returns>
        </member>
        <member name="M:RE.CharFA`1.ClonePathTo(RE.CharFA{`0})">
            <summary>
            Returns a duplicate state machine, except one that only goes from this state to the state specified in <paramref name="to"/>. Any state that does not lead to that state is eliminated from the resulting graph.
            </summary>
            <param name="to">The state to track the path to</param>
            <returns>A new state machine that only goes from this state to the state indicated by <paramref name="to"/></returns>
        </member>
        <member name="M:RE.CharFA`1.ClonePathToAny(System.Collections.Generic.IEnumerable{RE.CharFA{`0}})">
            <summary>
            Returns a duplicate state machine, except one that only goes from this state to any state specified in <paramref name="to"/>. Any state that does not lead to one of those states is eliminated from the resulting graph.
            </summary>
            <param name="to">The collection of destination states</param>
            <returns>A new state machine that only goes from this state to the states indicated by <paramref name="to"/></returns>
        </member>
        <member name="M:RE.CharFA`1.GenerateSymbolTableInitializer(`0[])">
            <summary>
            Generates a <see cref="T:System.CodeDom.CodeExpression"/> that can be used to initialize a symbol table
            </summary>
            <param name="symbols">The symbols to generate the symbol table code for</param>
            <returns>The expression used to initialize the symbol table array of element type indicated by TAccept</returns>
        </member>
        <member name="M:RE.CharFA`1.GenerateDfaStateTableInitializer(RE.CharDfaEntry[])">
            <summary>
            Generates a <see cref="T:System.CodeDom.CodeExpression"/> that can be used to initialize a DFA state table
            </summary>
            <param name="dfaTable">The DFA state table to generate the code for</param>
            <returns>The expression used to initialize the DFA state table array of element type <see cref="T:RE.CharDfaEntry"/></returns>
        </member>
        <member name="M:RE.CharFA`1.GenerateLexMethod(RE.CharDfaEntry[],System.Int32)">
            <summary>
            Generates a <see cref="T:System.CodeDom.CodeMemberMethod"/> that can be compiled and used to lex input
            </summary>
            <param name="dfaTable">The DFA table to use</param>
            <param name="errorSymbol">Indicates the error symbol id to use</param>
            <returns>A <see cref="T:System.CodeDom.CodeMemberMethod"/> representing the lexing procedure</returns>
        </member>
        <member name="M:RE.CharFA`1.GenerateMatchMethod(RE.CharDfaEntry[])">
            <summary>
            Generates a <see cref="T:System.CodeDom.CodeMemberMethod"/> that can be compiled and used to match input
            </summary>
            <param name="dfaTable">The DFA table to use</param>
            <returns>A <see cref="T:System.CodeDom.CodeMemberMethod"/> representing the matching procedure</returns>
        </member>
        <member name="M:RE.CharFA`1.FillClosure(System.Collections.Generic.IList{RE.CharFA{`0}})">
            <summary>
            Retrieves all states reachable from this state
            </summary>
            <param name="result">The collection to hold the result, or null to create one.</param>
            <returns>A collection containing the closure of items</returns>
        </member>
        <member name="P:RE.CharFA`1.Closure">
            <summary>
            Retrieves an enumeration that indicates the closure of the state
            </summary>
            <remarks>This uses lazy evaluation.</remarks>
        </member>
        <member name="M:RE.CharFA`1.FillEpsilonClosure(System.Collections.Generic.IList{RE.CharFA{`0}})">
            <summary>
            Retrieves all states reachable from this state on no input.
            </summary>
            <param name="result">A collection to hold the result or null to create one</param>
            <returns>A collection containing the epsilon closure of this state</returns>
        </member>
        <member name="P:RE.CharFA`1.EpsilonClosure">
            <summary>
            Retrieves an enumeration that indicates the epsilon closure of this state
            </summary>
            <remarks>This uses lazy evaluation.</remarks>
        </member>
        <member name="M:RE.CharFA`1.FillEpsilonClosure(System.Collections.Generic.IEnumerable{RE.CharFA{`0}},System.Collections.Generic.IList{RE.CharFA{`0}})">
            <summary>
            Takes a set of states and computes the total epsilon closure as a set of states
            </summary>
            <param name="states">The states to examine</param>
            <param name="result">The result to be filled</param>
            <returns>The epsilon closure of <paramref name="states"/></returns>
        </member>
        <member name="M:RE.CharFA`1.FillDescendants(System.Collections.Generic.IList{RE.CharFA{`0}})">
            <summary>
            Retrieves all states that are descendants of this state
            </summary>
            <param name="result">A collection to hold the result or null to create one</param>
            <returns>A collection containing the descendants of this state</returns>
        </member>
        <member name="P:RE.CharFA`1.Descendants">
            <summary>
            Retrieves an enumeration that indicates the descendants of the state
            </summary>
            <remarks>This uses lazy evaluation.</remarks>
        </member>
        <member name="M:RE.CharFA`1.FillMove(System.Collections.Generic.IEnumerable{RE.CharFA{`0}},System.Char,System.Collections.Generic.IList{RE.CharFA{`0}})">
            <summary>
            Fills a collection with the result of moving each of the specified <paramref name="states"/> by the specified input.
            </summary>
            <param name="states">The states to examine</param>
            <param name="input">The input to use</param>
            <param name="result">The states that are now entered as a result of the move</param>
            <returns><paramref name="result"/> or a new collection if it wasn't specified.</returns>
        </member>
        <member name="M:RE.CharFA`1.MoveDfa(System.Char)">
            <summary>
            Moves from the specified state to a destination state in a DFA by moving along the specified input.
            </summary>
            <param name="input">The input to move on</param>
            <returns>The state which the machine moved to or null if no state could be found.</returns>
        </member>
        <member name="M:RE.CharFA`1.MoveDfa(RE.CharDfaEntry[],System.Int32,System.Char)">
            <summary>
            Moves from the specified state to a destination state in a DFA by moving along the specified input.
            </summary>
            <param name="dfaTable">The DFA state table to use</param>
            <param name="state">The current state id</param>
            <param name="input">The input to move on</param>
            <returns>The state id which the machine moved to or -1 if no state could be found.</returns>
        </member>
        <member name="M:RE.CharFA`1.FillInputTransitionRangesGroupedByState(System.Collections.Generic.IDictionary{RE.CharFA{`0},System.Collections.Generic.IList{RE.CharRange}})">
            <summary>
            Returns a dictionary keyed by state, that contains all of the outgoing local input transitions, expressed as a series of ranges
            </summary>
            <param name="result">The dictionary to fill, or null to create one.</param>
            <returns>A dictionary containing the result of the query</returns>
        </member>
        <member name="P:RE.CharFA`1.InputTransitions">
            <summary>
            Indicates the input transitions. These are the states that will be transitioned to on the specified input key.
            </summary>
        </member>
        <member name="P:RE.CharFA`1.EpsilonTransitions">
            <summary>
            Indicates the epsilon transitions. These are the states that are transitioned to without consuming input.
            </summary>
        </member>
        <member name="P:RE.CharFA`1.IsAccepting">
            <summary>
            Indicates whether or not this is an accepting state. When an accepting state is landed on, this indicates a potential match.
            </summary>
        </member>
        <member name="P:RE.CharFA`1.AcceptSymbol">
            <summary>
            The symbol to associate with this accepting state. Upon accepting a match, the specified symbol is returned which can identify it.
            </summary>
        </member>
        <member name="P:RE.CharFA`1.Tag">
            <summary>
            Indicates a user-defined value to associate with this state
            </summary>
        </member>
        <member name="M:RE.CharFA`1.#ctor(System.Boolean,`0)">
            <summary>
            Constructs a new instance with the specified accepting value and accept symbol.
            </summary>
            <param name="isAccepting">Indicates whether or not the state is accepting</param>
            <param name="acceptSymbol">Indicates the associated symbol to be used when accepting.</param>
        </member>
        <member name="M:RE.CharFA`1.#ctor">
            <summary>
            Constructs a new non-accepting state
            </summary>
        </member>
        <member name="M:RE.CharFA`1.ToDfaStateTable(System.Collections.Generic.IList{`0},System.IProgress{RE.CharFAProgress})">
            <summary>
            Returns a DFA table that can be used to lex or match
            </summary>
            <param name="symbolTable">The symbol table to use, or null to just implicitly tag symbols with integer ids</param>
            <param name="progress">The progress object used to report the progress of the task</param>
            <returns>A DFA table that can be used to efficiently match or lex input</returns>
        </member>
        <member name="M:RE.CharFA`1.IsDuplicate(RE.CharFA{`0})">
            <summary>
            Indicates whether this state is a duplicate of another state.
            </summary>
            <param name="rhs">The state to compare with</param>
            <returns>True if the states are duplicates (one can be removed without changing the language of the machine)</returns>
        </member>
        <member name="M:RE.CharFA`1.FillDuplicatesGroupedByState(System.Collections.Generic.IDictionary{RE.CharFA{`0},System.Collections.Generic.ICollection{RE.CharFA{`0}}})">
            <summary>
            Fills a dictionary of duplicates by state for any duplicates found in the state graph
            </summary>
            <param name="result">The resulting dictionary to be filled.</param>
            <returns>The resulting dictionary of duplicates</returns>
        </member>
        <member name="M:RE.CharFA`1.FillDuplicatesGroupedByState(System.Collections.Generic.IList{RE.CharFA{`0}},System.Collections.Generic.IDictionary{RE.CharFA{`0},System.Collections.Generic.ICollection{RE.CharFA{`0}}})">
            <summary>
            Fills a dictionary of duplicates by state for any duplicates found in the state graph
            </summary>
            <param name="closure">The closure to examine</param>
            <param name="result">The resulting dictionary to be filled.</param>
            <returns>The resulting dictionary of duplicates</returns>
        </member>
        <member name="M:RE.CharFA`1.TrimDuplicates(System.IProgress{RE.CharFAProgress})">
            <summary>
            Trims duplicate states from the graph.
            </summary>
        </member>
        <member name="M:RE.CharFA`1.TrimDuplicates(System.Collections.Generic.IList{RE.CharFA{`0}},System.IProgress{RE.CharFAProgress})">
            <summary>
            Trims duplicate states from the graph
            </summary>
            <param name="closure">The closure to alter.</param>
            <param name="progress">The progress object used to report the progress of the task</param>
        </member>
        <member name="P:RE.CharFA`1.IsFinal">
            <summary>
            Indicates whether or not the state has any outgoing transitions
            </summary>
        </member>
        <member name="M:RE.CharFA`1.FillFinalStates(System.Collections.Generic.IList{RE.CharFA{`0}})">
            <summary>
            Retrieves all the states reachable from this state that are final.
            </summary>
            <param name="result">The list of final states. Will be filled after the call.</param>
            <returns>The resulting list of final states. This is the same value as the result parameter, if specified.</returns>
        </member>
        <member name="M:RE.CharFA`1.FillFinalStates(System.Collections.Generic.IList{RE.CharFA{`0}},System.Collections.Generic.IList{RE.CharFA{`0}})">
            <summary>
            Retrieves all the states in this closure that are final
            </summary>
            <param name="closure">The closure to examine</param>
            <param name="result">The list of final states. Will be filled after the call.</param>
            <returns>The resulting list of final states. This is the same value as the result parameter, if specified.</returns>
        </member>
        <member name="M:RE.CharFA`1.Finalize(`0)">
            <summary>
            Makes all accepting states transition to a new accepting final state, and sets them as non-accepting
            </summary>
            <param name="accept">The symbol to accept</param>
        </member>
        <member name="T:RE.CharFA`1.DotGraphOptions">
            <summary>
            Represents optional rendering parameters for a dot graph.
            </summary>
        </member>
        <member name="P:RE.CharFA`1.DotGraphOptions.Dpi">
            <summary>
            The resolution, in dots-per-inch to render at
            </summary>
        </member>
        <member name="P:RE.CharFA`1.DotGraphOptions.StatePrefix">
            <summary>
            The prefix used for state labels
            </summary>
        </member>
        <member name="P:RE.CharFA`1.DotGraphOptions.DebugString">
            <summary>
            If non-null, specifies a debug render using the specified input string.
            </summary>
            <remarks>The debug render is useful for tracking the transitions in a state machine</remarks>
        </member>
        <member name="P:RE.CharFA`1.DotGraphOptions.DebugSourceNfa">
            <summary>
            If non-null, specifies the source NFA from which this DFA was derived - used for debug view
            </summary>
        </member>
        <member name="M:RE.CharFA`1.WriteDotTo(System.IO.TextWriter,RE.CharFA{`0}.DotGraphOptions)">
            <summary>
            Writes a Graphviz dot specification to the specified <see cref="T:System.IO.TextWriter"/>
            </summary>
            <param name="writer">The writer</param>
            <param name="options">A <see cref="T:RE.CharFA`1.DotGraphOptions"/> instance with any options, or null to use the defaults</param>
        </member>
        <member name="M:RE.CharFA`1._WriteDotTo(System.Collections.Generic.IList{RE.CharFA{`0}},System.IO.TextWriter,RE.CharFA{`0}.DotGraphOptions)">
            <summary>
            Writes a Graphviz dot specification of the specified closure to the specified <see cref="T:System.IO.TextWriter"/>
            </summary>
            <param name="closure">The closure of all states</param>
            <param name="writer">The writer</param>
            <param name="options">A <see cref="T:RE.CharFA`1.DotGraphOptions"/> instance with any options, or null to use the defaults</param>
        </member>
        <member name="M:RE.CharFA`1.RenderToFile(System.String,RE.CharFA{`0}.DotGraphOptions)">
            <summary>
            Renders Graphviz output for this machine to the specified file
            </summary>
            <param name="filename">The output filename. The format to render is indicated by the file extension.</param>
            <param name="options">A <see cref="T:RE.CharFA`1.DotGraphOptions"/> instance with any options, or null to use the defaults</param>
        </member>
        <member name="M:RE.CharFA`1.RenderToStream(System.String,System.Boolean,RE.CharFA{`0}.DotGraphOptions)">
            <summary>
            Renders Graphviz output for this machine to a stream
            </summary>
            <param name="format">The output format. The format to render can be any supported dot output format. See dot command line documation for details.</param>
            <param name="copy">True to copy the stream, otherwise false</param>
            <param name="options">A <see cref="T:RE.CharFA`1.DotGraphOptions"/> instance with any options, or null to use the defaults</param>
            <returns>A stream containing the output. The caller is expected to close the stream when finished.</returns>
        </member>
        <member name="T:RE.CharFA`1._InputTransitionDictionary">
            <summary>
            This is a specialized transition container that can return its transitions in 3 different ways:
            1. a dictionary where each transition state is keyed by an individual input character (default)
            2. a dictionary where each collection of inputs is keyed by the transition state (used mostly by optimizations)
            3. an indexable list of pairs where the key is the transition state and the value is the collection of inputs
            use casts to get at the appropriate interface for your operation.
            </summary>
        </member>
        <member name="M:RE.CharFA`1.ToLexer(RE.CharFA{`0}[])">
            <summary>
            Creates a lexer out of the specified FSM "expressions"
            </summary>
            <param name="exprs">The expressions to compose the lexer with</param>
            <returns>An FSM representing the lexer.</returns>
        </member>
        <member name="M:RE.CharFA`1.Lex(RE.ParseContext,`0)">
            <summary>
            Lexes the next input from the parse context.
            </summary>
            <param name="context">The <see cref="T:RE.ParseContext"/> to use.</param>
            <param name="errorSymbol">The symbol to report in the case of an error</param>
            <returns>The next symbol matched - <paramref name="context"/> contains the capture and line information</returns>
        </member>
        <member name="M:RE.CharFA`1.LexDfa(RE.ParseContext,`0)">
            <summary>
            Lexes the next input from the parse context.
            </summary>
            <param name="context">The <see cref="T:RE.ParseContext"/> to use.</param>
            <param name="errorSymbol">The symbol to report in the case of an error</param>
            <returns>The next symbol matched - <paramref name="context"/> contains the capture and line information</returns>
            <remarks>This method will not work properly on an NFA but will not error in that case, so take care to only use this with a DFA</remarks>
        </member>
        <member name="M:RE.CharFA`1.LexDfa(RE.CharDfaEntry[],RE.ParseContext,System.Int32)">
            <summary>
            Lexes the next input from the parse context.
            </summary>
            <param name="dfaTable">The DFA state table to use</param>
            <param name="context">The <see cref="T:RE.ParseContext"/> to use.</param>
            <param name="errorSymbol">The symbol id to report in the case of an error</param>
            <returns>The next symbol id matched - <paramref name="context"/> contains the capture and line information</returns>
        </member>
        <member name="M:RE.CharFA`1.Match(RE.ParseContext)">
            <summary>
            Pattern matches through a string of text
            </summary>
            <param name="context">The parse context to search</param>
            <returns>A <see cref="T:RE.CharFAMatch"/> that contains the match information, or null if the match is not found.</returns>
        </member>
        <member name="M:RE.CharFA`1.MatchDfa(RE.ParseContext)">
            <summary>
            Pattern matches through a string of text using a DFA
            </summary>
            <param name="context">The parse context to search</param>
            <returns>A <see cref="T:RE.CharFAMatch"/> that contains the match information, or null if the match is not found.</returns>
            <remarks>An NFA will not work with this method, but for performance reasons we cannot verify that the state machine is a DFA before running. Be sure to only use DFAs with this method.</remarks>
        </member>
        <member name="M:RE.CharFA`1.MatchDfa(RE.CharDfaEntry[],RE.ParseContext)">
            <summary>
            Pattern matches through a string of text using a DFA
            </summary>
            <param name="dfaTable">The DFA state table to use</param>
            <param name="context">The parse context to search</param>
            <returns>A <see cref="T:RE.CharFAMatch"/> that contains the match information, or null if the match is not found.</returns>
        </member>
        <member name="P:RE.CharFA`1.IsNeutral">
            <summary>
            Indicates whether or not the state is neutral
            </summary>
        </member>
        <member name="M:RE.CharFA`1.FillNeutralStates(System.Collections.Generic.IList{RE.CharFA{`0}})">
            <summary>
            Retrieves all the states reachable from this state that are neutral.
            </summary>
            <param name="result">The list of neutral states. Will be filled after the call.</param>
            <returns>The resulting list of neutral states. This is the same value as the result parameter, if specified.</returns>
        </member>
        <member name="M:RE.CharFA`1.FillNeutralStates(System.Collections.Generic.IList{RE.CharFA{`0}},System.Collections.Generic.IList{RE.CharFA{`0}})">
            <summary>
            Retrieves all the states in this closure that are neutral
            </summary>
            <param name="closure">The closure to examine</param>
            <param name="result">The list of neutral states. Will be filled after the call.</param>
            <returns>The resulting list of neutral states. This is the same value as the result parameter, if specified.</returns>
        </member>
        <member name="M:RE.CharFA`1.TrimNeutrals">
            <summary>
            Trims the neutral states from this machine
            </summary>
        </member>
        <member name="M:RE.CharFA`1.TrimNeutrals(System.Collections.Generic.IEnumerable{RE.CharFA{`0}})">
            <summary>
            Trims the neutral states from the specified closure
            </summary>
            <param name="closure">The set of all states</param>
        </member>
        <member name="M:RE.CharFA`1.ToDfa(System.IProgress{RE.CharFAProgress})">
            <summary>
            Transforms an NFA to a DFA
            </summary>
            <param name="progress">The optional progress object used to report the progress of the operation</param>
            <returns>A new finite state machine equivilent to this state machine but with no epsilon transitions</returns>
        </member>
        <member name="P:RE.CharFA`1.IsDfa">
            <summary>
            Indicates whether or not this state machine is a DFA
            </summary>
        </member>
        <member name="M:RE.CharFA`1.Reduce(System.IProgress{RE.CharFAProgress})">
            <summary>
            Reduces the complexity of the graph, and returns the result as a new graph
            </summary>
            <returns>A new graph with a complexity of 1</returns>
        </member>
        <member name="M:RE.CharFA`1.Literal(System.Collections.Generic.IEnumerable{System.Char},`0)">
            <summary>
            Creates an FA that matches a literal string
            </summary>
            <param name="string">The string to match</param>
            <param name="accept">The symbol to accept</param>
            <returns>A new FA machine that will match this literal</returns>
        </member>
        <member name="M:RE.CharFA`1.Set(System.Collections.Generic.IEnumerable{System.Char},`0)">
            <summary>
            Creates an FA that will match any one of a set of a characters
            </summary>
            <param name="set">The set of characters that will be matched</param>
            <param name="accept">The symbol to accept</param>
            <returns>An FA that will match the specified set</returns>
        </member>
        <member name="M:RE.CharFA`1.Concat(System.Collections.Generic.IEnumerable{RE.CharFA{`0}},`0)">
            <summary>
            Creates a new FA that is a concatenation of two other FA expressions
            </summary>
            <param name="exprs">The FAs to concatenate</param>
            <param name="accept">The symbol to accept</param>
            <returns>A new FA that is the concatenation of the specified FAs</returns>
        </member>
        <member name="M:RE.CharFA`1.Set(System.Collections.Generic.IEnumerable{RE.CharRange},`0)">
            <summary>
            Creates an FA that will match any one of a set of a characters
            </summary>
            <param name="ranges">The set ranges of characters that will be matched</param>
            <param name="accept">The symbol to accept</param>
            <returns>An FA that will match the specified set</returns>
        </member>
        <member name="M:RE.CharFA`1.Or(System.Collections.Generic.IEnumerable{RE.CharFA{`0}},`0)">
            <summary>
            Creates a new FA that matches any one of the FA expressions passed
            </summary>
            <param name="exprs">The expressions to match</param>
            <param name="accept">The symbol to accept</param>
            <returns>A new FA that will match the union of the FA expressions passed</returns>
        </member>
        <member name="M:RE.CharFA`1.Repeat(RE.CharFA{`0},System.Int32,System.Int32,`0)">
            <summary>
            Creates a new FA that will match a repetition of the specified FA expression
            </summary>
            <param name="expr">The expression to repeat</param>
            <param name="minOccurs">The minimum number of times to repeat or -1 for unspecified (0)</param>
            <param name="maxOccurs">The maximum number of times to repeat or -1 for unspecified (unbounded)</param>
            <param name="accept">The symbol to accept</param>
            <returns>A new FA that matches the specified FA one or more times</returns>
        </member>
        <member name="M:RE.CharFA`1.Optional(RE.CharFA{`0},`0)">
            <summary>
            Creates a new FA that matches the specified FA expression or empty
            </summary>
            <param name="expr">The expression to make optional</param>
            <param name="accept">The symbol to accept</param>
            <returns>A new FA that will match the specified expression or empty</returns>
        </member>
        <member name="M:RE.CharFA`1.CaseInsensitive(RE.CharFA{`0},`0)">
            <summary>
            Makes the specified expression case insensitive
            </summary>
            <param name="expr">The target expression</param>
            <param name="accept">The accept symbol</param>
            <returns>A new expression that is the case insensitive equivelent of <paramref name="expr"/></returns>
        </member>
        <member name="T:RE.CharFAMatch">
            <summary>
            Represents a regular expression match
            </summary>
            <remarks>Returned from the Match() and MatchDfa() methods</remarks>
        </member>
        <member name="P:RE.CharFAMatch.Line">
            <summary>
            Indicates the 1 based line where the match was found
            </summary>
        </member>
        <member name="P:RE.CharFAMatch.Column">
            <summary>
            Indicates the 1 based column where the match was found
            </summary>
        </member>
        <member name="P:RE.CharFAMatch.Position">
            <summary>
            Indicates the 0 based position where the match was found
            </summary>
        </member>
        <member name="P:RE.CharFAMatch.Value">
            <summary>
            Indicates the value of the match
            </summary>
        </member>
        <member name="M:RE.CharFAMatch.#ctor(System.Int32,System.Int32,System.Int64,System.String)">
            <summary>
            Creates a new instance with the specified values
            </summary>
            <param name="line">The 1 based line where the match occured</param>
            <param name="column">The 1 based columns where the match occured</param>
            <param name="position">The 0 based position where the match occured</param>
            <param name="value">The value of the match</param>
        </member>
        <member name="T:RE.CharFAStatus">
            <summary>
            Represents the current status of the operation
            </summary>
        </member>
        <member name="F:RE.CharFAStatus.Unknown">
            <summary>
            The status is unknown
            </summary>
        </member>
        <member name="F:RE.CharFAStatus.DfaTransform">
            <summary>
            Performing a DFA transform
            </summary>
        </member>
        <member name="F:RE.CharFAStatus.TrimDuplicates">
            <summary>
            Trimming duplicate states
            </summary>
        </member>
        <member name="T:RE.CharFAProgress">
            <summary>
            Represents the progress of the operation
            </summary>
        </member>
        <member name="M:RE.CharFAProgress.#ctor(RE.CharFAStatus,System.Int32)">
            <summary>
            Constructs a new instance of the progress class with the specified status and count
            </summary>
            <param name="status">The status</param>
            <param name="count">The count of values in the progress</param>
        </member>
        <member name="P:RE.CharFAProgress.Status">
            <summary>
            The status
            </summary>
        </member>
        <member name="P:RE.CharFAProgress.Count">
            <summary>
            The count of values in the progress.
            </summary>
        </member>
        <member name="T:RE.ListDictionary`2">
            <summary>
            Represents a dictionary over a <see cref="T:System.Collections.Generic.IList`1"/>. Allows null for a key and is explicitely ordered, but unindexed. All searches are linear time.
            </summary>
            <remarks>Best only to use this for small dictionaries or where indexing by key is infrequent.</remarks>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="T:RE.ParseContext">
            <summary>
            see https://www.codeproject.com/Articles/5162847/ParseContext-2-0-Easier-Hand-Rolled-Parsers
            </summary>
        </member>
        <member name="M:RE.ParseContext.IsHexChar(System.Char)">
            <summary>
            Indicates if the character is hex
            </summary>
            <param name="hex">The character to examine</param>
            <returns>True if the character is a valid hex character, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.FromHexChar(System.Char)">
            <summary>
            Converts a hex character to its byte representation
            </summary>
            <param name="hex">The character to convert</param>
            <returns>The byte that the character represents</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadInteger">
            <summary>
            Attempts to read a generic integer into the capture buffer
            </summary>
            <returns>True if a valid integer was read, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipInteger">
            <summary>
            Attempts to skip a generic integer without capturing
            </summary>
            <returns>True if an integer was found and skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryParseInteger(System.Object@)">
            <summary>
            Attempts to read a C# integer into the capture buffer while parsing it
            </summary>
            <param name="result">The value the literal represents</param>
            <returns>True if the value was a valid literal, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.ParseInteger">
            <summary>
            Reads a C# integer literal into the capture buffer while parsing it
            </summary>
            <returns>The value the literal represents</returns>
            <exception cref="T:RE.ExpectingException">The input was not valid</exception>
        </member>
        <member name="M:RE.ParseContext.TryReadReal">
            <summary>
            Attempts to read a generic floating point number into the capture buffer
            </summary>
            <returns>True if a valid floating point number was read, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipReal">
            <summary>
            Attempts to skip a generic floating point literal without capturing
            </summary>
            <returns>True if a literal was found and skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryParseReal(System.Double@)">
            <summary>
            Attempts to read a floating point literal into the capture buffer while parsing it
            </summary>
            <param name="result">The value the literal represents</param>
            <returns>True if the value was a valid literal, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.ParseReal">
            <summary>
            Reads a floating point literal into the capture buffer while parsing it
            </summary>
            <returns>The value the literal represents</returns>
            <exception cref="T:RE.ExpectingException">The input was not valid</exception>
        </member>
        <member name="M:RE.ParseContext.TryReadLiteral(System.String,System.Boolean)">
            <summary>
            Attempts to read the specified literal from the input, optionally checking if it is terminated
            </summary>
            <param name="literal">The literal to attempt to read</param>
            <param name="checkTerminated">If true, will check the end to make sure it's not a letter or digit</param>
            <returns></returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipLiteral(System.String,System.Boolean)">
            <summary>
            Attempts to skip the specified literal without capturing, optionally checking for termination
            </summary>
            <param name="literal">The literal to skip</param>
            <param name="checkTerminated">True if the literal should be checked for termination by a charcter other than a letter or digit, otherwise false</param>
            <returns>True if the literal was found and skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadCLineComment">
            <summary>
            Attempts to read a C style line comment into the capture buffer
            </summary>
            <returns>True if a valid comment was read, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipCLineComment">
            <summary>
            Attempts to skip the a C style line comment without capturing
            </summary>
            <returns>True if a comment was found and skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadCBlockComment">
            <summary>
            Attempts to read a C style block comment into the capture buffer
            </summary>
            <returns>True if a valid comment was read, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipCBlockComment">
            <summary>
            Attempts to skip the C style block comment without capturing
            </summary>
            <returns>True if a comment was found and skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadCComment">
            <summary>
            Attempts to read a C style comment into the capture buffer
            </summary>
            <returns>True if a valid comment was read, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipCComment">
            <summary>
            Attempts to skip the a C style comment value without capturing
            </summary>
            <returns>True if a comment was found and skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadCCommentsAndWhiteSpace">
            <summary>
            Attempts to read C style comments or whitespace into the capture buffer
            </summary>
            <returns>True if a valid comment or whitespace was read, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipCCommentsAndWhiteSpace">
            <summary>
            Attempts to skip the a C style comment or whitespace value without capturing
            </summary>
            <returns>True if a comment or whitespace was found and skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadCIdentifier">
            <summary>
            Attempts to read a C style identifier into the capture buffer
            </summary>
            <returns>True if a valid identifier was read, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipCIdentifier">
            <summary>
            Attempts to skip the a C style identifier value without capturing
            </summary>
            <returns>True if an identifier was found and skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadCString">
            <summary>
            Attempts to read a C style string into the capture buffer
            </summary>
            <returns>True if a valid string was read, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipCString">
            <summary>
            Attempts to skip a C style string literal without capturing
            </summary>
            <returns>True if a literal was found and skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadWhiteSpace">
            <summary>
            Attempts to read whitespace from the current input, capturing it
            </summary>
            <returns>True if whitespace was read, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipWhiteSpace">
            <summary>
            Attempts to skip whitespace in the current input without capturing it
            </summary>
            <returns>True if whitespace was skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadUntil(System.Int32,System.Boolean)">
            <summary>
            Attempts to read up until the specified character, optionally consuming it
            </summary>
            <param name="character">The character to halt at</param>
            <param name="readCharacter">True if the character should be consumed, otherwise false</param>
            <returns>True if the character was found, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipUntil(System.Int32,System.Boolean)">
            <summary>
            Attempts to skip up until the specified character, optionally consuming it
            </summary>
            <param name="character">The character to halt at</param>
            <param name="skipCharacter">True if the character should be consumed, otherwise false</param>
            <returns>True if the character was found, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadUntil(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Attempts to read up until the specified character, using the specified escape, optionally consuming it
            </summary>
            <param name="character">The character to halt at</param>
            <param name="escapeChar">The escape indicator character to use</param>
            <param name="readCharacter">True if the character should be consumed, otherwise false</param>
            <returns>True if the character was found, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipUntil(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Attempts to skip up until the specified character, using the specified escape, optionally consuming it
            </summary>
            <param name="character">The character to halt at</param>
            <param name="escapeChar">The escape indicator character to use</param>
            <param name="skipCharacter">True if the character should be consumed, otherwise false</param>
            <returns>True if the character was found, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadUntil(System.Boolean,System.Char[])">
            <summary>
            Attempts to read until any of the specified characters, optionally consuming it
            </summary>
            <param name="readCharacter">True if the character should be consumed, otherwise false</param>
            <param name="anyOf">A list of characters that signal the end of the scan</param>
            <returns>True if one of the characters was found, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipUntil(System.Boolean,System.Char[])">
            <summary>
            Attempts to skip until any of the specified characters, optionally consuming it
            </summary>
            <param name="skipCharacter">True if the character should be consumed, otherwise false</param>
            <param name="anyOf">A list of characters that signal the end of the scan</param>
            <returns>True if one of the characters was found, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadUntil(System.String)">
            <summary>
            Reads up to the specified text string, consuming it
            </summary>
            <param name="text">The text to read until</param>
            <returns>True if the text was found, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipUntil(System.String)">
            <summary>
            Skips up to the specified text string, consuming it
            </summary>
            <param name="text">The text to skip until</param>
            <returns>True if the text was found, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadDigits">
            <summary>
            Attempts to read a series of digits, consuming them
            </summary>
            <returns>True if digits were consumed, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipDigits">
            <summary>
            Attempts to skip a series of digits, consuming them
            </summary>
            <returns>True if digits were consumed, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadLetters">
            <summary>
            Attempts to read a series of letters, consuming them
            </summary>
            <returns>True if letters were consumed, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipLetters">
            <summary>
            Attempts to skip a series of letters, consuming them
            </summary>
            <returns>True if letters were consumed, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadLettersOrDigits">
            <summary>
            Attempts to read a series of letters or digits, consuming them
            </summary>
            <returns>True if letters or digits were consumed, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipLettersOrDigits">
            <summary>
            Attempts to skip a series of letters or digits, consuming them
            </summary>
            <returns>True if letters or digits were consumed, otherwise false</returns>
        </member>
        <member name="P:RE.ParseContext.CaptureBuffer">
            <summary>
            Indicates the capture buffer used to hold gathered input
            </summary>
        </member>
        <member name="P:RE.ParseContext.Position">
            <summary>
            Indicates the 0 based position of the parse context
            </summary>
        </member>
        <member name="P:RE.ParseContext.Column">
            <summary>
            Indicates the 1 based column of the parse context
            </summary>
        </member>
        <member name="P:RE.ParseContext.Line">
            <summary>
            Indicates the 1 based line of the parse context
            </summary>
        </member>
        <member name="P:RE.ParseContext.Current">
            <summary>
            Indicates the current status, -1 if end of input (like <see cref="T:System.IO.TextReader"/>) or -2 if before the beginning.
            </summary>
        </member>
        <member name="P:RE.ParseContext.TabWidth">
            <summary>
            Indicates the width of tabs on the output device.
            </summary>
            <remarks>Used for tracking column position</remarks>
        </member>
        <member name="M:RE.ParseContext.EnsureStarted">
            <summary>
            Ensures that the parse context is started and the input cursor is valid
            </summary>
        </member>
        <member name="M:RE.ParseContext.Peek(System.Int32)">
            <summary>
            Peeks the specified number of characters ahead in the input without advancing
            </summary>
            <param name="lookAhead">Indicates the number of characters to look ahead. Zero is the current position.</param>
            <returns>An integer representing the character at the position, or -1 if past the end of the input.</returns>
        </member>
        <member name="M:RE.ParseContext.EnsureLookAhead(System.Int32)">
            <summary>
            Pre-reads the specified amount of lookahead characters
            </summary>
            <param name="lookAhead">The number of lookahead characters to read</param>
            <returns>True if the entire lookahead request could be satisfied, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.Advance">
            <summary>
            Advances the input cursor by one
            </summary>
            <returns>An integer representing the next character</returns>
        </member>
        <member name="M:RE.ParseContext.Dispose">
            <summary>
            Disposes of the parse context and closes any resources used
            </summary>
        </member>
        <member name="M:RE.ParseContext.ClearCapture">
            <summary>
            Clears the capture buffer
            </summary>
        </member>
        <member name="M:RE.ParseContext.CaptureCurrent">
            <summary>
            Captures the current character if available
            </summary>
        </member>
        <member name="M:RE.ParseContext.GetCapture(System.Int32,System.Int32)">
            <summary>
            Gets the capture buffer at the specified start index
            </summary>
            <param name="startIndex">The index to begin copying</param>
            <param name="count">The number of characters to copy</param>
            <returns>A string representing the specified subset of the capture buffer</returns>
        </member>
        <member name="M:RE.ParseContext.GetCapture(System.Int32)">
            <summary>
            Gets the capture buffer at the specified start index
            </summary>
            <param name="startIndex">The index to begin copying</param>
            <returns>A string representing the specified subset of the capture buffer</returns>
        </member>
        <member name="M:RE.ParseContext.SetLocation(System.Int32,System.Int32,System.Int64)">
            <summary>
            Sets the location information for the parse context
            </summary>
            <remarks>This does not move the cursor. It simply updates the position information.</remarks>
            <param name="line">The 1 based current line</param>
            <param name="column">The 1 based current column</param>
            <param name="position">The zero based current position</param>
        </member>
        <member name="M:RE.ParseContext.ThrowExpectingRanges(System.Int32[])">
            <summary>
            Throws a <see cref="T:RE.ExpectingException"/> with a set of packed int ranges where the ints are pairs indicating first and last
            </summary>
            <param name="expecting">The packed ranges</param>
        </member>
        <member name="M:RE.ParseContext.Expecting(System.Int32[])">
            <summary>
            Throws an exception indicating the expected characters if the current character is not one of the specified characters
            </summary>
            <param name="expecting">The characters to check for, or -1 for end of input. If the characters are empty, any character other than the end of input is accepted.</param>
            <exception cref="T:RE.ExpectingException">Raised when the current character doesn't match any of the specified characters</exception>
        </member>
        <member name="M:RE.ParseContext.Create(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Creates a parse context over a string (<see cref="T:System.Collections.Generic.IEnumerable`1"/>)
            </summary>
            <param name="string">The input string to use</param>
            <returns>A parse context over the specified input</returns>
        </member>
        <member name="M:RE.ParseContext.CreateFrom(System.IO.TextReader)">
            <summary>
            Creates a parse context over a <see cref="T:System.IO.TextReader"/>
            </summary>
            <param name="reader">The text reader to use</param>
            <returns>A parse context over the specified input</returns>
        </member>
        <member name="M:RE.ParseContext.CreateFrom(System.String)">
            <summary>
            Creates a parse context over the specified file
            </summary>
            <param name="filename">The filename to use</param>
            <returns>A parse context over the specified file</returns>
        </member>
        <member name="M:RE.ParseContext.CreateFromUrl(System.String)">
            <summary>
            Creates a parse context over the specified url
            </summary>
            <param name="url">The url to use</param>
            <returns>A parse context over the specified file</returns>
        </member>
        <member name="M:RE.ParseContext.TryReadJsonString">
            <summary>
            Attempts to read a JSON string into the capture buffer
            </summary>
            <returns>True if a valid string was read, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipJsonString">
            <summary>
            Attempts to skip a JSON string literal without capturing
            </summary>
            <returns>True if a literal was found and skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryParseJsonString(System.String@)">
            <summary>
            Attempts to read a JSON string literal into the capture buffer while parsing it
            </summary>
            <param name="result">The value the literal represents</param>
            <returns>True if the value was a valid literal, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.ParseJsonString">
            <summary>
            Reads a JSON string literal into the capture buffer while parsing it
            </summary>
            <returns>The value the literal represents</returns>
            <exception cref="T:RE.ExpectingException">The input was not valid</exception>
        </member>
        <member name="M:RE.ParseContext.TryReadJsonValue">
            <summary>
            Attempts to read a JSON value into the capture buffer
            </summary>
            <returns>True if a valid value was read, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TrySkipJsonValue">
            <summary>
            Attempts to skip the a JSON value without capturing
            </summary>
            <returns>True if a value was found and skipped, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.TryParseJsonValue(System.Object@)">
            <summary>
            Attempts to read a JSON value into the capture buffer while parsing it
            </summary>
            <param name="result"><see cref="T:System.Collections.Generic.IDictionary`2"/> for a JSON object, <see cref="T:System.Collections.Generic.IList`1"/> for a JSON array, or the appropriate scalar value</param>
            <returns>True if the value was a valid value, otherwise false</returns>
        </member>
        <member name="M:RE.ParseContext.ParseJsonValue">
            <summary>
            Reads a JSON value into the capture buffer while parsing it
            </summary>
            <returns><see cref="T:System.Collections.Generic.IDictionary`2"/> for a JSON object, <see cref="T:System.Collections.Generic.IList`1"/> for a JSON array, or the appropriate scalar value</returns>
            <exception cref="T:RE.ExpectingException">The input was not valid</exception>
        </member>
        <member name="T:RE.ExpectingException">
            <summary>
            An exception encountered during parsing where the stream contains one thing, but another is expected
            </summary>
        </member>
        <member name="M:RE.ExpectingException.#ctor(System.String)">
            <summary>
            Creates the exception with the specified message.
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="M:RE.ExpectingException.#ctor(System.String,System.Int32,System.Int32,System.Int64,System.String[])">
            <summary>
            Creates the exception with the specified arguments
            </summary>
            <param name="message">The message</param>
            <param name="line">The line</param>
            <param name="column">The column</param>
            <param name="position">The position</param>
            <param name="expecting">What was expected</param>
        </member>
        <member name="P:RE.ExpectingException.Expecting">
            <summary>
            The list of expected strings.
            </summary>
        </member>
        <member name="P:RE.ExpectingException.Position">
            <summary>
            The position when the error was realized.
            </summary>
        </member>
        <member name="P:RE.ExpectingException.Line">
            <summary>
            The line of the error
            </summary>
        </member>
        <member name="P:RE.ExpectingException.Column">
            <summary>
            The column of the error
            </summary>
        </member>
    </members>
</doc>
