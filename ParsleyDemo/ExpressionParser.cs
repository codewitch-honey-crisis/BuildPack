//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ParsleyDemo {
    using System;
    using System.Collections.Generic;
    
    /// <summary>Parses the following grammar:
    /// Term= Factor { ( "+" | "-" ) Factor };
    /// Factor= Unary { ( "*" | "/" ) Unary };
    /// Unary= ( "+" | "-" ) Unary | Leaf;
    /// Leaf= integer | identifier | "(" Term ")";
    /// add= "+";
    /// mul= "*";
    /// integer= '[0-9]+';
    /// identifier= '[A-Z_a-z][0-9A-Z_a-z]*';
    /// (whitespace)= '\s+';
    /// </summary>
    /// <remarks>The rules for the factored grammar are as follows:
    /// Unary -> add Unary
    /// Unary -> Implicit Unary
    /// Unary -> Leaf
    /// Leaf -> integer
    /// Leaf -> identifier
    /// Leaf -> Implicit3 Term Implicit4
    /// TermList -> add Factor TermListRightAssoc TermListRightAssoc2
    /// TermList -> Implicit Factor TermListRightAssoc TermListRightAssoc2
    /// FactorList -> mul Unary FactorListRightAssoc FactorListRightAssoc2
    /// FactorList -> Implicit2 Unary FactorListRightAssoc FactorListRightAssoc2
    /// TermListRightAssoc -> add Factor TermListRightAssoc
    /// TermListRightAssoc ->
    /// FactorListRightAssoc -> mul Unary FactorListRightAssoc
    /// FactorListRightAssoc ->
    /// Term -> Factor TermPart
    /// TermPart -> TermList
    /// TermPart ->
    /// Factor -> Unary FactorPart
    /// FactorPart -> FactorList
    /// FactorPart ->
    /// TermListRightAssoc2 -> Implicit Factor TermListRightAssoc2
    /// TermListRightAssoc2 ->
    /// FactorListRightAssoc2 -> Implicit2 Unary FactorListRightAssoc2
    /// FactorListRightAssoc2 ->
    /// </remarks>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")]
    internal partial class ExpressionParser {
        internal const int ErrorSymbol = -1;
        internal const int EosSymbol = -2;
        public const int Unary = 0;
        public const int Leaf = 1;
        public const int TermList = 2;
        public const int FactorList = 3;
        public const int TermListRightAssoc = 4;
        public const int FactorListRightAssoc = 5;
        public const int Term = 6;
        public const int TermPart = 7;
        public const int Factor = 8;
        public const int FactorPart = 9;
        public const int TermListRightAssoc2 = 10;
        public const int FactorListRightAssoc2 = 11;
        public const int add = 12;
        public const int Implicit = 13;
        public const int integer = 14;
        public const int identifier = 15;
        public const int Implicit3 = 16;
        public const int Implicit4 = 17;
        public const int mul = 18;
        public const int Implicit2 = 19;
        public const int whitespace = 20;
        private static ParseNode ParseUnary(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // Unary -> add Unary
            if ((ExpressionParser.add == context.SymbolId)) {
                ParseNode[] children = new ParseNode[2];
                if ((false 
                            == (ExpressionParser.add == context.SymbolId))) {
                    context.Error("Expecting add at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children[0] = new ParseNode(ExpressionParser.add, "add", context.Value, context.Line, context.Column, context.Position);
                context.Advance();
                children[1] = ExpressionParser.ParseUnary(context);
                return new ParseNode(ExpressionParser.Unary, "Unary", children, line__, column__, position__);
            }
            // Unary -> Implicit Unary
            if ((ExpressionParser.Implicit == context.SymbolId)) {
                ParseNode[] children = new ParseNode[2];
                if ((false 
                            == (ExpressionParser.Implicit == context.SymbolId))) {
                    context.Error("Expecting Implicit at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children[0] = new ParseNode(ExpressionParser.Implicit, "Implicit", context.Value, context.Line, context.Column, context.Position);
                context.Advance();
                children[1] = ExpressionParser.ParseUnary(context);
                return new ParseNode(ExpressionParser.Unary, "Unary", children, line__, column__, position__);
            }
            // Unary -> Leaf
            if ((((ExpressionParser.integer == context.SymbolId) 
                        || (ExpressionParser.identifier == context.SymbolId)) 
                        || (ExpressionParser.Implicit3 == context.SymbolId))) {
                ParseNode[] children = new ParseNode[1];
                children[0] = ExpressionParser.ParseLeaf(context);
                return new ParseNode(ExpressionParser.Unary, "Unary", children, line__, column__, position__);
            }
            context.Error("Expecting add, Implicit, integer, identifier, or Implicit3 at line {0}, column {1" +
                    "}, position {2}", line__, column__, position__);
            return null;
        }
        /// <summary>
        /// Parses a production of the form:
        /// Unary= ( "+" | "-" ) Unary | Leaf
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Unary -> add Unary
        /// Unary -> Implicit Unary
        /// Unary -> Leaf
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseUnary(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return ExpressionParser.ParseUnary(context);
        }
        private static ParseNode ParseLeaf(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // Leaf -> integer
            if ((ExpressionParser.integer == context.SymbolId)) {
                ParseNode[] children = new ParseNode[1];
                if ((false 
                            == (ExpressionParser.integer == context.SymbolId))) {
                    context.Error("Expecting integer at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children[0] = new ParseNode(ExpressionParser.integer, "integer", context.Value, context.Line, context.Column, context.Position);
                context.Advance();
                return new ParseNode(ExpressionParser.Leaf, "Leaf", children, line__, column__, position__);
            }
            // Leaf -> identifier
            if ((ExpressionParser.identifier == context.SymbolId)) {
                ParseNode[] children = new ParseNode[1];
                if ((false 
                            == (ExpressionParser.identifier == context.SymbolId))) {
                    context.Error("Expecting identifier at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children[0] = new ParseNode(ExpressionParser.identifier, "identifier", context.Value, context.Line, context.Column, context.Position);
                context.Advance();
                return new ParseNode(ExpressionParser.Leaf, "Leaf", children, line__, column__, position__);
            }
            // Leaf -> Implicit3 Term Implicit4
            if ((ExpressionParser.Implicit3 == context.SymbolId)) {
                ParseNode[] children = new ParseNode[3];
                if ((false 
                            == (ExpressionParser.Implicit3 == context.SymbolId))) {
                    context.Error("Expecting Implicit3 at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children[0] = new ParseNode(ExpressionParser.Implicit3, "Implicit3", context.Value, context.Line, context.Column, context.Position);
                context.Advance();
                children[1] = ExpressionParser.ParseTerm(context);
                if ((false 
                            == (ExpressionParser.Implicit4 == context.SymbolId))) {
                    context.Error("Expecting Implicit4 at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children[2] = new ParseNode(ExpressionParser.Implicit4, "Implicit4", context.Value, context.Line, context.Column, context.Position);
                context.Advance();
                return new ParseNode(ExpressionParser.Leaf, "Leaf", children, line__, column__, position__);
            }
            context.Error("Expecting integer, identifier, or Implicit3 at line {0}, column {1}, position {2}" +
                    "", line__, column__, position__);
            return null;
        }
        /// <summary>
        /// Parses a production of the form:
        /// Leaf= integer | identifier | "(" Term ")"
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Leaf -> integer
        /// Leaf -> identifier
        /// Leaf -> Implicit3 Term Implicit4
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseLeaf(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return ExpressionParser.ParseLeaf(context);
        }
        private static ParseNode ParseTermList(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // TermList -> add Factor TermListRightAssoc TermListRightAssoc2
            if ((ExpressionParser.add == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                if ((false 
                            == (ExpressionParser.add == context.SymbolId))) {
                    context.Error("Expecting add at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children.Add(new ParseNode(ExpressionParser.add, "add", context.Value, context.Line, context.Column, context.Position));
                context.Advance();
                children.Add(ExpressionParser.ParseFactor(context));
                children.AddRange(ExpressionParser.ParseTermListRightAssoc(context).Children);
                children.AddRange(ExpressionParser.ParseTermListRightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.TermList, "TermList", children.ToArray(), line__, column__, position__);
            }
            // TermList -> Implicit Factor TermListRightAssoc TermListRightAssoc2
            if ((ExpressionParser.Implicit == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                if ((false 
                            == (ExpressionParser.Implicit == context.SymbolId))) {
                    context.Error("Expecting Implicit at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children.Add(new ParseNode(ExpressionParser.Implicit, "Implicit", context.Value, context.Line, context.Column, context.Position));
                context.Advance();
                children.Add(ExpressionParser.ParseFactor(context));
                children.AddRange(ExpressionParser.ParseTermListRightAssoc(context).Children);
                children.AddRange(ExpressionParser.ParseTermListRightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.TermList, "TermList", children.ToArray(), line__, column__, position__);
            }
            context.Error("Expecting add or Implicit at line {0}, column {1}, position {2}", line__, column__, position__);
            return null;
        }
        private static ParseNode ParseFactorList(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // FactorList -> mul Unary FactorListRightAssoc FactorListRightAssoc2
            if ((ExpressionParser.mul == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                if ((false 
                            == (ExpressionParser.mul == context.SymbolId))) {
                    context.Error("Expecting mul at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children.Add(new ParseNode(ExpressionParser.mul, "mul", context.Value, context.Line, context.Column, context.Position));
                context.Advance();
                children.Add(ExpressionParser.ParseUnary(context));
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc(context).Children);
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.FactorList, "FactorList", children.ToArray(), line__, column__, position__);
            }
            // FactorList -> Implicit2 Unary FactorListRightAssoc FactorListRightAssoc2
            if ((ExpressionParser.Implicit2 == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                if ((false 
                            == (ExpressionParser.Implicit2 == context.SymbolId))) {
                    context.Error("Expecting Implicit2 at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children.Add(new ParseNode(ExpressionParser.Implicit2, "Implicit2", context.Value, context.Line, context.Column, context.Position));
                context.Advance();
                children.Add(ExpressionParser.ParseUnary(context));
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc(context).Children);
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.FactorList, "FactorList", children.ToArray(), line__, column__, position__);
            }
            context.Error("Expecting mul or Implicit2 at line {0}, column {1}, position {2}", line__, column__, position__);
            return null;
        }
        private static ParseNode ParseTermListRightAssoc(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // TermListRightAssoc -> add Factor TermListRightAssoc
            if ((ExpressionParser.add == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                if ((false 
                            == (ExpressionParser.add == context.SymbolId))) {
                    context.Error("Expecting add at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children.Add(new ParseNode(ExpressionParser.add, "add", context.Value, context.Line, context.Column, context.Position));
                context.Advance();
                children.Add(ExpressionParser.ParseFactor(context));
                children.AddRange(ExpressionParser.ParseTermListRightAssoc(context).Children);
                return new ParseNode(ExpressionParser.TermListRightAssoc, "TermListRightAssoc", children.ToArray(), line__, column__, position__);
            }
            // TermListRightAssoc ->
            if ((((ExpressionParser.Implicit == context.SymbolId) 
                        || (ExpressionParser.EosSymbol == context.SymbolId)) 
                        || (ExpressionParser.Implicit4 == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.TermListRightAssoc, "TermListRightAssoc", children, line__, column__, position__);
            }
            context.Error("Expecting add, Implicit, #EOS, or Implicit4 at line {0}, column {1}, position {2}" +
                    "", line__, column__, position__);
            return null;
        }
        private static ParseNode ParseFactorListRightAssoc(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // FactorListRightAssoc -> mul Unary FactorListRightAssoc
            if ((ExpressionParser.mul == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                if ((false 
                            == (ExpressionParser.mul == context.SymbolId))) {
                    context.Error("Expecting mul at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children.Add(new ParseNode(ExpressionParser.mul, "mul", context.Value, context.Line, context.Column, context.Position));
                context.Advance();
                children.Add(ExpressionParser.ParseUnary(context));
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc(context).Children);
                return new ParseNode(ExpressionParser.FactorListRightAssoc, "FactorListRightAssoc", children.ToArray(), line__, column__, position__);
            }
            // FactorListRightAssoc ->
            if ((((((ExpressionParser.Implicit2 == context.SymbolId) 
                        || (ExpressionParser.add == context.SymbolId)) 
                        || (ExpressionParser.Implicit == context.SymbolId)) 
                        || (ExpressionParser.EosSymbol == context.SymbolId)) 
                        || (ExpressionParser.Implicit4 == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.FactorListRightAssoc, "FactorListRightAssoc", children, line__, column__, position__);
            }
            context.Error("Expecting mul, Implicit2, add, Implicit, #EOS, or Implicit4 at line {0}, column {" +
                    "1}, position {2}", line__, column__, position__);
            return null;
        }
        private static ParseNode ParseTerm(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // Term -> Factor TermPart
            if ((((((ExpressionParser.add == context.SymbolId) 
                        || (ExpressionParser.Implicit == context.SymbolId)) 
                        || (ExpressionParser.integer == context.SymbolId)) 
                        || (ExpressionParser.identifier == context.SymbolId)) 
                        || (ExpressionParser.Implicit3 == context.SymbolId))) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(ExpressionParser.ParseFactor(context));
                children.AddRange(ExpressionParser.ParseTermPart(context).Children);
                return new ParseNode(ExpressionParser.Term, "Term", children.ToArray(), line__, column__, position__);
            }
            context.Error("Expecting add, Implicit, integer, identifier, or Implicit3 at line {0}, column {1" +
                    "}, position {2}", line__, column__, position__);
            return null;
        }
        /// <summary>
        /// Parses a production of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseTerm(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return ExpressionParser.ParseTerm(context);
        }
        /// <summary>
        /// Parses a production of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode Parse(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return ExpressionParser.ParseTerm(context);
        }
        private static ParseNode ParseTermPart(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // TermPart -> TermList
            if (((ExpressionParser.add == context.SymbolId) 
                        || (ExpressionParser.Implicit == context.SymbolId))) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.AddRange(ExpressionParser.ParseTermList(context).Children);
                return new ParseNode(ExpressionParser.TermPart, "TermPart", children.ToArray(), line__, column__, position__);
            }
            // TermPart ->
            if (((ExpressionParser.EosSymbol == context.SymbolId) 
                        || (ExpressionParser.Implicit4 == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.TermPart, "TermPart", children, line__, column__, position__);
            }
            context.Error("Expecting add, Implicit, #EOS, or Implicit4 at line {0}, column {1}, position {2}" +
                    "", line__, column__, position__);
            return null;
        }
        private static ParseNode ParseFactor(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // Factor -> Unary FactorPart
            if ((((((ExpressionParser.add == context.SymbolId) 
                        || (ExpressionParser.Implicit == context.SymbolId)) 
                        || (ExpressionParser.integer == context.SymbolId)) 
                        || (ExpressionParser.identifier == context.SymbolId)) 
                        || (ExpressionParser.Implicit3 == context.SymbolId))) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.Add(ExpressionParser.ParseUnary(context));
                children.AddRange(ExpressionParser.ParseFactorPart(context).Children);
                return new ParseNode(ExpressionParser.Factor, "Factor", children.ToArray(), line__, column__, position__);
            }
            context.Error("Expecting add, Implicit, integer, identifier, or Implicit3 at line {0}, column {1" +
                    "}, position {2}", line__, column__, position__);
            return null;
        }
        /// <summary>
        /// Parses a production of the form:
        /// Factor= Unary { ( "*" | "/" ) Unary }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Factor -> Unary FactorPart
        /// </remarks>
        /// <param name="tokenizer">The tokenizer to parse with</param><returns>A <see cref="ParseNode" /> representing the parsed tokens</returns>
        public static ParseNode ParseFactor(System.Collections.Generic.IEnumerable<Token> tokenizer) {
            ParserContext context = new ParserContext(tokenizer);
            context.EnsureStarted();
            return ExpressionParser.ParseFactor(context);
        }
        private static ParseNode ParseFactorPart(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // FactorPart -> FactorList
            if (((ExpressionParser.mul == context.SymbolId) 
                        || (ExpressionParser.Implicit2 == context.SymbolId))) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                children.AddRange(ExpressionParser.ParseFactorList(context).Children);
                return new ParseNode(ExpressionParser.FactorPart, "FactorPart", children.ToArray(), line__, column__, position__);
            }
            // FactorPart ->
            if (((((ExpressionParser.add == context.SymbolId) 
                        || (ExpressionParser.Implicit == context.SymbolId)) 
                        || (ExpressionParser.EosSymbol == context.SymbolId)) 
                        || (ExpressionParser.Implicit4 == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.FactorPart, "FactorPart", children, line__, column__, position__);
            }
            context.Error("Expecting mul, Implicit2, add, Implicit, #EOS, or Implicit4 at line {0}, column {" +
                    "1}, position {2}", line__, column__, position__);
            return null;
        }
        private static ParseNode ParseTermListRightAssoc2(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // TermListRightAssoc2 -> Implicit Factor TermListRightAssoc2
            if ((ExpressionParser.Implicit == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                if ((false 
                            == (ExpressionParser.Implicit == context.SymbolId))) {
                    context.Error("Expecting Implicit at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children.Add(new ParseNode(ExpressionParser.Implicit, "Implicit", context.Value, context.Line, context.Column, context.Position));
                context.Advance();
                children.Add(ExpressionParser.ParseFactor(context));
                children.AddRange(ExpressionParser.ParseTermListRightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.TermListRightAssoc2, "TermListRightAssoc2", children.ToArray(), line__, column__, position__);
            }
            // TermListRightAssoc2 ->
            if (((ExpressionParser.EosSymbol == context.SymbolId) 
                        || (ExpressionParser.Implicit4 == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.TermListRightAssoc2, "TermListRightAssoc2", children, line__, column__, position__);
            }
            context.Error("Expecting Implicit, #EOS, or Implicit4 at line {0}, column {1}, position {2}", line__, column__, position__);
            return null;
        }
        private static ParseNode ParseFactorListRightAssoc2(ParserContext context) {
            int line__ = context.Line;
            int column__ = context.Column;
            long position__ = context.Position;
            // FactorListRightAssoc2 -> Implicit2 Unary FactorListRightAssoc2
            if ((ExpressionParser.Implicit2 == context.SymbolId)) {
                System.Collections.Generic.List<ParseNode> children = new System.Collections.Generic.List<ParseNode>();
                if ((false 
                            == (ExpressionParser.Implicit2 == context.SymbolId))) {
                    context.Error("Expecting Implicit2 at line {0}, column {1}, position {2}", context.Line, context.Column, context.Position);
                }
                children.Add(new ParseNode(ExpressionParser.Implicit2, "Implicit2", context.Value, context.Line, context.Column, context.Position));
                context.Advance();
                children.Add(ExpressionParser.ParseUnary(context));
                children.AddRange(ExpressionParser.ParseFactorListRightAssoc2(context).Children);
                return new ParseNode(ExpressionParser.FactorListRightAssoc2, "FactorListRightAssoc2", children.ToArray(), line__, column__, position__);
            }
            // FactorListRightAssoc2 ->
            if (((((ExpressionParser.add == context.SymbolId) 
                        || (ExpressionParser.Implicit == context.SymbolId)) 
                        || (ExpressionParser.EosSymbol == context.SymbolId)) 
                        || (ExpressionParser.Implicit4 == context.SymbolId))) {
                ParseNode[] children = new ParseNode[0];
                return new ParseNode(ExpressionParser.FactorListRightAssoc2, "FactorListRightAssoc2", children, line__, column__, position__);
            }
            context.Error("Expecting Implicit2, add, Implicit, #EOS, or Implicit4 at line {0}, column {1}, p" +
                    "osition {2}", line__, column__, position__);
            return null;
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <returns>The result of the evaluation</returns>
        public static int Evaluate(ParseNode node) {
            return ExpressionParser.EvaluateTerm(node);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        /// <returns>The result of the evaluation</returns>
        public static int Evaluate(ParseNode node, object state) {
            return ExpressionParser.EvaluateTerm(node, state);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateTerm(ParseNode node, object state) {
            if ((ExpressionParser.Term == node.SymbolId)) {
                int result = ExpressionParser.EvaluateFactor(node.Children[0], state);
                int i = 2;
                for (
                ; (i < node.Children.Length); 
                ) {
                    if ((node.Children[(i - 1)].SymbolId == ParsleyDemo.ExpressionParser.add)) {
                        result = (result + ExpressionParser.EvaluateFactor(node.Children[i], state));
                    }
                    else {
                        result = (result - ExpressionParser.EvaluateFactor(node.Children[i], state));
                    }
                    i = (i + 2);
                }
                return ((int)(ExpressionParser._ChangeType(result, typeof(int))));
            }
            throw new SyntaxException("Expecting Term", node.Line, node.Column, node.Position);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Term= Factor { ( "+" | "-" ) Factor }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Term -> Factor TermPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateTerm(ParseNode node) {
            return ExpressionParser.EvaluateTerm(node, null);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Factor= Unary { ( "*" | "/" ) Unary }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Factor -> Unary FactorPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateFactor(ParseNode node, object state) {
            if ((ExpressionParser.Factor == node.SymbolId)) {
                int result = ExpressionParser.EvaluateUnary(node.Children[0], state);
                int i = 2;
                for (
                ; (i < node.Children.Length); 
                ) {
                    // Child always returns an object type so
                    // be sure to cast as necessary
                    if ((node.Children[(i - 1)].SymbolId == ParsleyDemo.ExpressionParser.mul)) {
                        result = (result * ((int)(ExpressionParser._EvaluateAny(node.Children[i], state))));
                    }
                    else {
                        result = (result / ((int)(ExpressionParser._EvaluateAny(node.Children[i], state))));
                    }
                    i = (i + 2);
                }
                return ((int)(ExpressionParser._ChangeType(result, typeof(int))));
            }
            throw new SyntaxException("Expecting Factor", node.Line, node.Column, node.Position);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Factor= Unary { ( "*" | "/" ) Unary }
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Factor -> Unary FactorPart
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateFactor(ParseNode node) {
            return ExpressionParser.EvaluateFactor(node, null);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Unary= ( "+" | "-" ) Unary | Leaf
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Unary -> add Unary
        /// Unary -> Implicit Unary
        /// Unary -> Leaf
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateUnary(ParseNode node, object state) {
            if ((ExpressionParser.Unary == node.SymbolId)) {
                if ((node.Children.Length == 1)) {
                    return ((int)(ExpressionParser._ChangeType(ExpressionParser.EvaluateLeaf(node.Children[0], state), typeof(int))));
                }
                if ((node.Children[0].SymbolId == ParsleyDemo.ExpressionParser.add)) {
                    return ((int)(ExpressionParser._ChangeType(ExpressionParser.EvaluateUnary(node.Children[1], state), typeof(int))));
                }
                else {
                    return ((int)(ExpressionParser._ChangeType((0 - ExpressionParser.EvaluateUnary(node.Children[1], state)), typeof(int))));
                }
            }
            throw new SyntaxException("Expecting Unary", node.Line, node.Column, node.Position);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Unary= ( "+" | "-" ) Unary | Leaf
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Unary -> add Unary
        /// Unary -> Implicit Unary
        /// Unary -> Leaf
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateUnary(ParseNode node) {
            return ExpressionParser.EvaluateUnary(node, null);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Leaf= integer | identifier | "(" Term ")"
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Leaf -> integer
        /// Leaf -> identifier
        /// Leaf -> Implicit3 Term Implicit4
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateLeaf(ParseNode node, object state) {
            if ((ExpressionParser.Leaf == node.SymbolId)) {
                if ((node.Children.Length == 1)) {
                    if ((node.Children[0].SymbolId == ParsleyDemo.ExpressionParser.integer)) {
                        return ((int)(ExpressionParser._ChangeType(node.Children[0].Value, typeof(int))));
                    }
                    else {
                        if ((state != null)) {
                            int val;
                            IDictionary<string, int> d = ((IDictionary<string, int>)(state));
                            if (d.TryGetValue(node.Children[0].Value, out val)) {
                                return ((int)(ExpressionParser._ChangeType(val, typeof(int))));
                            }
                        }
                        throw new SyntaxException(string.Format("Reference to undefined variable {0}", node.Children[0].Value), node.Line, node.Column, node.Position);
                    }
                }
                else {
                    return ((int)(ExpressionParser._ChangeType(ExpressionParser.EvaluateTerm(node.Children[1], state), typeof(int))));
                }
            }
            throw new SyntaxException("Expecting Leaf", node.Line, node.Column, node.Position);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Leaf= integer | identifier | "(" Term ")"
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Leaf -> integer
        /// Leaf -> identifier
        /// Leaf -> Implicit3 Term Implicit4
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <returns>The result of the evaluation</returns>
        public static int EvaluateLeaf(ParseNode node) {
            return ExpressionParser.EvaluateLeaf(node, null);
        }
        private static object _ChangeType(object obj, System.Type type) {
            System.ComponentModel.TypeConverter typeConverter = System.ComponentModel.TypeDescriptor.GetConverter(obj);
            if (((null == typeConverter) 
                        || (false == typeConverter.CanConvertTo(type)))) {
                return System.Convert.ChangeType(obj, type);
            }
            return typeConverter.ConvertTo(obj, type);
        }
        private static object _EvaluateAny(ParseNode node, object state) {
            if ((node.SymbolId == ExpressionParser.Term)) {
                return ExpressionParser.EvaluateTerm(node, state);
            }
            if ((node.SymbolId == ExpressionParser.Factor)) {
                return ExpressionParser.EvaluateFactor(node, state);
            }
            if ((node.SymbolId == ExpressionParser.Unary)) {
                return ExpressionParser.EvaluateUnary(node, state);
            }
            if ((node.SymbolId == ExpressionParser.Leaf)) {
                return ExpressionParser.EvaluateLeaf(node, state);
            }
            if ((node.SymbolId == ExpressionParser.add)) {
                return node.Value;
            }
            if ((node.SymbolId == ExpressionParser.mul)) {
                return node.Value;
            }
            if ((node.SymbolId == ExpressionParser.integer)) {
                return node.Value;
            }
            if ((node.SymbolId == ExpressionParser.identifier)) {
                return node.Value;
            }
            return null;
        }
    }
    /// <summary>
    /// 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")]
    internal class SyntaxException : Exception {
        private int _line;
        private int _column;
        private long _position;
        /// <summary>
        /// Creates a syntax exception with the specified arguments
        /// </summary>
        /// <param name="message">The error message</param>
        /// <param name="line">The line where the error occurred</param>
        /// <param name="column">The column where the error occured</param>
        /// <param name="position">The position where the error occured</param>
        public SyntaxException(string message, int line, int column, long position) : 
                base(SyntaxException._GetMessage(message, line, column, position)) {
            this._line = line;
            this._column = column;
            this._position = position;
        }
        /// <summary>
        /// The line where the error occurred
        /// </summary>
        public int Line {
            get {
                return this._line;
            }
        }
        /// <summary>
        /// The column where the error occurred
        /// </summary>
        public int Column {
            get {
                return this._column;
            }
        }
        /// <summary>
        /// The position where the error occurred
        /// </summary>
        public long Position {
            get {
                return this._position;
            }
        }
        static string _GetMessage(string message, int line, int column, long position) {
            return string.Format("{0} at line {1}, column {2}, position {3}", message, line, column, position);
        }
    }
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")]
    internal partial class ParseNode {
        private int _symbolId;
        private string _symbol;
        private string _value;
        private int _line;
        private int _column;
        private long _position;
        private ParseNode[] _children;
        public ParseNode(int symbolId, string symbol, ParseNode[] children, int line, int column, long position) {
            this._symbolId = symbolId;
            this._symbol = symbol;
            this._value = null;
            this._children = children;
            this._line = line;
            this._column = column;
            this._position = position;
        }
        public ParseNode(int symbolId, string symbol, string value, int line, int column, long position) {
            this._symbolId = symbolId;
            this._symbol = symbol;
            this._value = value;
            this._children = null;
            this._line = line;
            this._column = column;
            this._position = position;
        }
        public bool IsNonTerminal {
            get {
                return (null != this._children);
            }
        }
        public ParseNode[] Children {
            get {
                return this._children;
            }
        }
        public int SymbolId {
            get {
                return this._symbolId;
            }
        }
        public string Symbol {
            get {
                return this._symbol;
            }
        }
        public string Value {
            get {
                return this._value;
            }
        }
        public int Line {
            get {
                return this._line;
            }
        }
        public int Column {
            get {
                return this._column;
            }
        }
        public long Position {
            get {
                return this._position;
            }
        }
    }
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")]
    internal partial class ParserContext : Object, IDisposable {
        private int _state;
        private IEnumerator<Token> _e;
        private LookAheadEnumerator<Token> _el;
        private Token _t;
        private int _advanceCount;
        private int _line;
        private int _column;
        private long _position;
        public ParserContext(IEnumerable<Token> tokenizer) : 
                this(tokenizer.GetEnumerator(), true) {
        }
        private ParserContext(IEnumerator<Token> enumerator, bool wrap) {
            this._e = enumerator;
            if (wrap) {
                this._el = new LookAheadEnumerator<Token>(enumerator);
                this._e = this._el;
                // we need both pointers to point to the lookahead
            }
            this._state = -1;
            this._t.SymbolId = -1;
            this._advanceCount = 0;
        }
        public void SetLocation(int line, int column, long position) {
            this._line = line;
            this._column = column;
            this._position = position;
        }
        public void EnsureStarted() {
            if ((-1 == this._state)) {
                this.Advance();
            }
        }
        public ParserContext GetLookAhead() {
            if ((null == this._el)) {
                throw new NotSupportedException("This parser context does not support lookahead.");
            }
            ParserContext result = new ParserContext(this._el.LookAhead.GetEnumerator(), true);
            result.SetLocation((this.Line - 1), (this.Column - 1), this.Position);
            return result;
        }
        public Token Current {
            get {
                return this._t;
            }
        }
        public ParserContext GetLookAhead(bool start) {
            ParserContext result = this.GetLookAhead();
            if (start) {
                result.EnsureStarted();
            }
            return result;
        }
        public int AdvanceCount {
            get {
                return this._advanceCount;
            }
        }
        public void ResetAdvanceCount() {
            this._advanceCount = 0;
        }
        public int SymbolId {
            get {
                return this._t.SymbolId;
            }
        }
        public string Value {
            get {
                return this._t.Value;
            }
        }
        public int Line {
            get {
                return this._t.Line;
            }
        }
        public int Column {
            get {
                return this._t.Column;
            }
        }
        public long Position {
            get {
                return this._t.Position;
            }
        }
        public bool IsEnded {
            get {
                return (-2 == this._state);
            }
        }
        public bool Advance() {
            if ((false == this._e.MoveNext())) {
                this._t.SymbolId = -2;
                this._state = -2;
            }
            else {
                // sanity check. should never happen
                if ((int.MaxValue == this._advanceCount)) {
                    this._advanceCount = -1;
                }
                this._advanceCount = (this._advanceCount + 1);
                this._state = 0;
                this._t = this._e.Current;
                this._t.Line = (this._t.Line + this._line);
                this._t.Column = (this._t.Column + this._column);
                this._t.Position = (this._t.Position + this._position);
                return true;
            }
            return false;
        }
        public void Error(string message, object arg1, object arg2, object arg3) {
            throw new SyntaxException(string.Format(message, arg1, arg2, arg3), this.Line, this.Column, this.Position);
        }
        public void Error(string message, object arg1, object arg2) {
            throw new SyntaxException(string.Format(message, arg1, arg2), this.Line, this.Column, this.Position);
        }
        public void Error(string message, object arg) {
            throw new SyntaxException(string.Format(message, arg), this.Line, this.Column, this.Position);
        }
        public void Error(string message) {
            throw new SyntaxException(message, this.Line, this.Column, this.Position);
        }
        public void Dispose() {
            this._e.Dispose();
            this._state = -3;
        }
    }
    /// <summary>
    /// An enumerator that provides lookahead without advancing the cursor
    /// </summary>
    /// <typeparam name="T">The type to enumerate</typeparam>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")]
    internal class LookAheadEnumerator<T> : object, IEnumerator<T>
     {
        private const int _Enumerating = 0;
        private const int _NotStarted = -2;
        private const int _Ended = -1;
        private const int _Disposed = -3;
        private IEnumerator<T> _inner;
        private int _state;
        // for the lookahead queue
        private const int _DefaultCapacity = 16;
        private const float _GrowthFactor = 0.9F;
        private T[] _queue;
        private int _queueHead;
        private int _queueCount;
        /// <summary>
        /// Creates a new instance. Once this is created, the inner/wrapped enumerator must not be touched.
        /// </summary>
        /// <param name="inner"></param>
        public LookAheadEnumerator(IEnumerator<T> inner) {
            this._inner = inner;
            this._state = LookAheadEnumerator<T>._NotStarted;
            this._queue = new T[LookAheadEnumerator<T>._DefaultCapacity];
            this._queueHead = 0;
            this._queueCount = 0;
        }
        /// <summary>
        /// Discards the lookahead and advances the cursor to the physical position.
        /// </summary>
        public void DiscardLookAhead() {
            for (
            ; (1 < this._queueCount); 
            ) {
                this._Dequeue();
            }
        }
        /// <summary>
        /// Retrieves the value under the cursor
        /// </summary>
        public T Current {
            get {
                if ((0 > this._state)) {
                    if ((LookAheadEnumerator<T>._NotStarted == this._state)) {
                        throw new InvalidOperationException("The cursor is before the start of the enumeration.");
                    }
                    if ((LookAheadEnumerator<T>._Ended == this._state)) {
                        throw new InvalidOperationException("The cursor is after the end of the enumeration.");
                    }
                    throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
                }
                return this._queue[this._queueHead];
            }
        }
        // legacy enum support (required)
        object System.Collections.IEnumerator.Current {
            get {
                return this.Current;
            }
        }
        internal int QueueCount {
            get {
                return this._queueCount;
            }
        }
        /// <summary>
        /// Attempts to peek the specified number of positions from the current position without advancing
        /// </summary>
        /// <param name="lookahead">The offset from the current position to peek at</param>
        /// <param name="value">The value returned</param>
        /// <returns>True if the peek could be satisfied, otherwise false</returns>
        public bool TryPeek(int lookahead, out T value) {
            if ((LookAheadEnumerator<T>._Disposed == this._state)) {
                throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
            }
            if ((0 > lookahead)) {
                throw new ArgumentOutOfRangeException("lookahead");
            }
            if ((LookAheadEnumerator<T>._Ended == this._state)) {
                value = default(T);
                return false;
            }
            if ((LookAheadEnumerator<T>._NotStarted == this._state)) {
                if ((0 == lookahead)) {
                    value = default(T);
                    return false;
                }
            }
            if ((lookahead < this._queueCount)) {
                value = this._queue[((lookahead + this._queueHead) 
                            % this._queue.Length)];
                return true;
            }
            lookahead = (lookahead - this._queueCount);
            value = default(T);
            for (
            ; ((0 <= lookahead) 
                        && this._inner.MoveNext()); 
            ) {
                value = this._inner.Current;
                this._Enqueue(value);
                lookahead = (lookahead - 1);
            }
            return (-1 == lookahead);
        }
        /// <summary>
        /// Peek the specified number of positions from the current position without advancing
        /// </summary>
        /// <param name="lookahead">The offset from the current position to peek at</param>
        /// <returns>The value at the specified position</returns>
        public T Peek(int lookahead) {
            T value;
            if ((false == this.TryPeek(lookahead, out value))) {
                throw new InvalidOperationException("There were not enough values in the enumeration to satisfy the request");
            }
            return value;
        }
        internal bool IsEnumerating {
            get {
                return (-1 < this._state);
            }
        }
        internal bool IsEnded {
            get {
                return (LookAheadEnumerator<T>._Ended == this._state);
            }
        }
        /// <summary>
        /// Retrieves a lookahead cursor from the current cursor that can be navigated without moving the main cursor
        /// </summary>
        public IEnumerable<T> LookAhead {
            get {
                if ((0 > this._state)) {
                    if ((this._state == LookAheadEnumerator<T>._NotStarted)) {
                        throw new InvalidOperationException("The cursor is before the start of the enumeration.");
                    }
                    if ((this._state == LookAheadEnumerator<T>._Ended)) {
                        throw new InvalidOperationException("The cursor is after the end of the enumeration.");
                    }
                    throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
                }
                return new LookAheadEnumeratorEnumerable<T>(this);
            }
        }
        /// <summary>
        /// Advances the cursor
        /// </summary>
        /// <returns>True if more input was read, otherwise false</returns>
        bool System.Collections.IEnumerator.MoveNext() {
            if ((0 > this._state)) {
                if ((LookAheadEnumerator<T>._Disposed == this._state)) {
                    throw new ObjectDisposedException(typeof(LookAheadEnumerator<T>).Name);
                }
                if ((LookAheadEnumerator<T>._Ended == this._state)) {
                    return false;
                }
                if ((LookAheadEnumerator<T>._NotStarted == this._state)) {
                    if ((0 < this._queueCount)) {
                        this._state = LookAheadEnumerator<T>._Enumerating;
                        return true;
                    }
                    if ((false == this._inner.MoveNext())) {
                        this._state = LookAheadEnumerator<T>._Ended;
                        return false;
                    }
                    this._Enqueue(this._inner.Current);
                    this._state = LookAheadEnumerator<T>._Enumerating;
                    return true;
                }
            }
            this._Dequeue();
            if ((0 == this._queueCount)) {
                if ((false == this._inner.MoveNext())) {
                    this._state = LookAheadEnumerator<T>._Ended;
                    return false;
                }
                this._Enqueue(this._inner.Current);
            }
            return true;
        }
        /// <summary>
        /// Resets the cursor, and clears the queue.
        /// </summary>
        void System.Collections.IEnumerator.Reset() {
            this._inner.Reset();
            if (((0 < this._queueCount) 
                        && (null == default(T)))) {
                System.Array.Clear(this._queue, this._queueHead, (this._queue.Length - this._queueHead));
                if (((this._queueHead + this._queueCount) 
                            >= this._queue.Length)) {
                    System.Array.Clear(this._queue, 0, (this._queueHead 
                                    + (this._queueCount % this._queue.Length)));
                }
            }
            this._queueHead = 0;
            this._queueCount = 0;
            this._state = LookAheadEnumerator<T>._NotStarted;
        }
        #region IDisposable Support
        /// <summary>
        /// Disposes of this instance
        /// </summary>
        void System.IDisposable.Dispose() {
            if ((false 
                        == (LookAheadEnumerator<T>._Disposed == this._state))) {
                this._inner.Dispose();
                this._state = LookAheadEnumerator<T>._Disposed;
            }
        }
        void _Enqueue(T item) {
            if ((this._queueCount == this._queue.Length)) {
                T[] arr = new T[((int)((this._queue.Length 
                            * (1 + LookAheadEnumerator<T>._GrowthFactor))))];
                if (((this._queueHead + this._queueCount) 
                            <= this._queue.Length)) {
                    System.Array.Copy(this._queue, arr, this._queueCount);
                    this._queueHead = 0;
                    arr[this._queueCount] = item;
                    this._queueCount = (this._queueCount + 1);
                    this._queue = arr;
                }
                else {
                    System.Array.Copy(this._queue, this._queueHead, arr, 0, (this._queue.Length - this._queueHead));
                    System.Array.Copy(this._queue, 0, arr, (this._queue.Length - this._queueHead), this._queueHead);
                    this._queueHead = 0;
                    arr[this._queueCount] = item;
                    this._queueCount = (this._queueCount + 1);
                    this._queue = arr;
                }
            }
            else {
                this._queue[((this._queueHead + this._queueCount) 
                            % this._queue.Length)] = item;
                this._queueCount = (this._queueCount + 1);
            }
        }
        T _Dequeue() {
            if ((0 == this._queueCount)) {
                throw new InvalidOperationException("The queue is empty");
            }
            T result = this._queue[this._queueHead];
            this._queue[this._queueHead] = default(T);
            this._queueHead = (this._queueHead + 1);
            this._queueHead = (this._queueHead % this._queue.Length);
            this._queueCount = (this._queueCount - 1);
            return result;
        }
        #endregion
    }
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")]
    internal class LookAheadEnumeratorEnumerable<T> : object, IEnumerable<T>
     {
        private LookAheadEnumerator<T> _outer;
        public LookAheadEnumeratorEnumerable(LookAheadEnumerator<T> outer) {
            this._outer = outer;
        }
        public IEnumerator<T> GetEnumerator() {
            // for some reason VB was resolving new as AddressOf, so use this.
            LookAheadEnumeratorEnumerator<T> result = ((LookAheadEnumeratorEnumerator<T>)(System.Activator.CreateInstance(typeof(LookAheadEnumeratorEnumerator<T>), this._outer)));
            return result;
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
            return this.GetEnumerator();
        }
    }
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Parsley", "0.1.2.0")]
    internal class LookAheadEnumeratorEnumerator<T> : object, IEnumerator<T>
     {
        private const int _NotStarted = -2;
        private const int _Ended = -1;
        private const int _Disposed = -3;
        private LookAheadEnumerator<T> _outer;
        private int _index;
        private T _current;
        public LookAheadEnumeratorEnumerator(LookAheadEnumerator<T> outer) {
            this._outer = outer;
            if (this._outer.IsEnumerating) {
                this._current = this._outer.Current;
            }
            this._index = LookAheadEnumeratorEnumerator<T>._NotStarted;
        }
        public T Current {
            get {
                if ((0 > this._index)) {
                    if ((this._index == LookAheadEnumeratorEnumerator<T>._NotStarted)) {
                        throw new InvalidOperationException("The cursor is before the start of the enumeration.");
                    }
                    if ((this._index == LookAheadEnumeratorEnumerator<T>._Ended)) {
                        throw new InvalidOperationException("The cursor is after the end of the enumeration.");
                    }
                    throw new ObjectDisposedException(typeof(LookAheadEnumeratorEnumerator<T>).Name);
                }
                return this._current;
            }
        }
        object System.Collections.IEnumerator.Current {
            get {
                return this.Current;
            }
        }
        void System.IDisposable.Dispose() {
            this._index = LookAheadEnumeratorEnumerator<T>._Disposed;
        }
        bool System.Collections.IEnumerator.MoveNext() {
            T value;
            if ((0 > this._index)) {
                if ((this._index == LookAheadEnumeratorEnumerator<T>._Disposed)) {
                    throw new ObjectDisposedException(typeof(LookAheadEnumeratorEnumerator<T>).Name);
                }
                if ((this._index == LookAheadEnumeratorEnumerator<T>._Ended)) {
                    return false;
                }
                this._index = -1;
            }
            this._index = (this._index + 1);
            if ((false == this._outer.TryPeek(this._index, out value))) {
                this._index = LookAheadEnumeratorEnumerator<T>._Ended;
                return false;
            }
            this._current = value;
            return true;
        }
        void System.Collections.IEnumerator.Reset() {
            this._index = LookAheadEnumeratorEnumerator<T>._NotStarted;
        }
    }
}
